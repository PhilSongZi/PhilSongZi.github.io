<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MYDB记录</title>
    <url>/post/7e29e8fb.html</url>
    <content><![CDATA[<h2 id="1-clone-本地运行">1. clone&amp;本地运行</h2>
<h3 id="1-1-环境">1.1. 环境</h3>
<ul>
<li>jdk：17.07</li>
<li>maven：3.9.2</li>
<li>os：windows 11</li>
</ul>
<h3 id="1-2-运行前设置">1.2. 运行前设置</h3>
<ul>
<li>手动创建数据库文件夹 tmp/mydb。（在项目目录下。）</li>
</ul>
<h3 id="1-3-问题">1.3. 问题</h3>
<ol>
<li>java.lang.ClassNotFoundException: “top.guoziyang.mydb.backend.Launcher”</li>
</ol>
<p>解决：IDEA中设置运行时参数。<a href="https://github.com/CN-GuoZiyang/MYDB/issues/3">参考</a></p>
<p><img src="/post/7e29e8fb/IDEA%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE.png" alt="IDEA参数设置"></p>
<h3 id="1-4-效果">1.4 效果</h3>
<p><img src="/post/7e29e8fb/MYDB%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C.png" alt="MYDB运行效果"></p>
<h2 id="2-文档先行：整体架构">2. 文档先行：整体架构</h2>
<h3 id="整体架构">整体架构</h3>
<h4 id="前端（客户端）">前端（客户端）</h4>
<p>读取用户输入，发送到后端执行，输出返回结果。等待下一次输入。</p>
<h4 id="SQL解析器（后面补充）">SQL解析器（后面补充）</h4>
<p>解析SQL，包装成对应的对象。</p>
<h4 id="后端">后端</h4>
<p>解析SQL，若合法，尝试执行并返回结果。</p>
<p>模块划分：各个模块通过接口向其依赖的模块提供方法</p>
<ol>
<li>Transaction Manager（TM）</li>
<li>Data Manager（DM）</li>
<li>Version Manager（VM）</li>
<li>Index Manager（IM）</li>
<li>Table Manager（TBM）</li>
</ol>
<p>五个模块的依赖图如下，拓补排序得出实现顺序为：TM -&gt; DM -&gt; VM -&gt; IM -&gt; TBM</p>
<p><img src="/post/7e29e8fb/%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96%E5%9B%BE.png" alt="模块依赖图"></p>
<p>各个模块的职责：</p>
<ol>
<li>TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。</li>
<li>DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：1) 分页管理 DB 文件，并进行缓存；2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。</li>
<li>VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。</li>
<li>IM 实现了基于 B+ 树的索引，目前 where 只支持已索引字段。</li>
<li>TBM 实现了对字段和表的管理。同时，解析 SQL 语句，并根据语句操作表。</li>
</ol>
<h2 id="3-Transaction-Manager（TM）">3. Transaction Manager（TM）</h2>
<p>TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。</p>
<h3 id="XID-文件">XID  文件</h3>
<p>XID 文件规则：</p>
<p>每个事物都有一个 xid，这个 ID 是一个事务的<strong>唯一标识</strong>。事务的 xid 从 <strong>1</strong> 开始编号，自增，不可重复。规定 xid 为 0 的事务是超级事务（super transaction），想在没有申请事务的情况下进行一些操作时，可将操作的 xid 设置为 0，超级事务的状态一直是 committed。</p>
<p>MYDB 中事务的状态：</p>
<ol>
<li>active，进行中</li>
<li>committed，已提交</li>
<li>aborted，已撤销（回滚）</li>
</ol>
<p>XID 文件内容的结构：</p>
<ol>
<li>给每个事务分配<strong>一个字节</strong>的空间来保存其<strong>状态</strong>。</li>
<li>XID 文件头部保存一个 <strong>8 字节数字</strong>，记录此 XID 文件管理<strong>事务的个数</strong>。</li>
<li>事务 xid 在文件中的状态存储位置在 <strong>(xid-1)+8 字节处</strong>。（xid-1 是因为 xid 为 0 的状态不需要记录。）</li>
</ol>
<h3 id="TransactionManager">TransactionManager</h3>
<p>提供的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">begin</span><span class="params">()</span>;                       <span class="comment">// 开启一个新事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span>;              <span class="comment">// 提交一个事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">long</span> xid)</span>;               <span class="comment">// 取消一个事务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">(<span class="type">long</span> xid)</span>;         <span class="comment">// 查询一个事务的状态是否是正在进行的状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCommitted</span><span class="params">(<span class="type">long</span> xid)</span>;      <span class="comment">// 查询一个事务的状态是否是已提交</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAborted</span><span class="params">(<span class="type">long</span> xid)</span>;        <span class="comment">// 查询一个事务的状态是否是已取消</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;                       <span class="comment">// 关闭TM</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据定义的 XID 文件结构，得到需要定义的一些常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XID文件头长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LEN_XID_HEADER_LENGTH</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 每个事务的占用长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">XID_FIELD_SIZE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 事务的三种状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_ACTIVE</span>   <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_COMMITTED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_ABORTED</span>  <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 超级事务，永远为commited状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SUPER_XID</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// XID 文件后缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">XID_SUFFIX</span> <span class="operator">=</span> <span class="string">&quot;.xid&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>在构造函数创建了一个 TransactionManager 之后，首先要对 XID 文件进行校验，以保证这是一个合法的 XID 文件。校验的方式是通过文件头的 8 字节数字反推文件的理论长度，与文件的实际长度做对比。如果不同则认为 XID 文件不合法。当校验不通过时，调用自定义方法强制停机。</p>
<p><code>begin()</code>方法：开启一个事务——</p>
<ul>
<li>首先设置 xidCounter+1 事务的状态为 committed，</li>
<li>然后 xidCounter 自增</li>
<li>同时，事务数量增加了一个，别忘记更新文件头。</li>
</ul>
<p><strong>注意点</strong>：所有文件操作在执行后都需要立刻刷入文件中，防止崩溃后文件丢失数据。</p>
<p>从查询事务状态的方法中抽象出一种公共的方法，使得实现事务状态查询时只需根据条件调用此方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测XID事务是否处于status状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkXID</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span> status)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> getXidPosition(xid);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="keyword">new</span> <span class="title class_">byte</span>[XID_FIELD_SIZE]);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.position(offset);</span><br><span class="line">        fc.read(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf.array()[<span class="number">0</span>] == status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在接口 TransactionManager 中，使用<strong>单例模式</strong> 创建 TM，其有两种方式，分别是：先新建 XID 文件再创建 TM实例（create 方法），或者从一个已有的 XID 文件中创建 TM 实例（open 方法）。要注意的是，从零创建 XID 文件时需要写一个<strong>空的 XID 文件头</strong>，即设置 xidCounter 为 0，否则后续在校验时会不合法</p>
<h2 id="4-Data-Manager（DM）">4. Data Manager（DM）</h2>
<p>DataManager（DM）功能归纳：</p>
<ul>
<li>上层模块和文件系统中的一个抽象层。向上，提供数据包装；向下，直接读写文件。</li>
<li>提供日志功能。</li>
</ul>
<h3 id="1、引用计数缓存框架">1、引用计数缓存框架</h3>
<p>分页管理和数据项（DataItem）管理涉及缓存，故抽象出一个通用缓存框架。</p>
<h4 id="引用计数法">引用计数法</h4>
<p>引用计数法（Reference counting）是一种内存管理技术，它通过计算每个对象被引用的次数来判断是否需要回收该对象。当对象被创建时，引用计数为1，每当有一个新的引用指向该对象时，计数加1，当引用失效时，计数减1。当计数为0时，该对象就可以被回收。</p>
<p>在MYDB的实践中，需要的效果是，只有上层模块主动释放引用，缓存在确保没有模块在使用这个资源了，才会去驱逐资源。</p>
<p>于是，选择引用计数法。增加了一个方法 release(key)，用于在上册模块不使用某个资源时，释放对资源的引用。当引用归零时，缓存就会驱逐这个资源。</p>
<p>同样，在缓存满了之后，引用计数法无法自动释放缓存，此时应该直接报错（和 JVM 似的，直接 OOM）。</p>
<h4 id="LRU">LRU</h4>
<p>LRU（least recently used）是一种缓存淘汰算法。它的特点是根据数据最近被访问的时间来决定哪些数据应该被保留，哪些数据应该被淘汰。当缓存达到一定容量时，会淘汰掉最近最少使用的数据。</p>
<p>如果使用 LRU 缓存，那么只需要设计一个 get(key) 接口即可，释放缓存可以在缓存满了之后自动完成。</p>
<p>however，当某时刻缓存满了，缓存驱逐一个资源，此时上层模块想将某个资源强制刷回3数据源，这个资源恰恰是刚被驱逐的资源。此时的上层模块会发现，资源在缓存中消失了，那么，是否有必要做回源操作？</p>
<ul>
<li>不回源。由于没法确定缓存被驱逐的时间，更没法确定被驱逐之后数据项是否被修改，这样是极其不安全的</li>
<li>回源。如果数据项被驱逐时的数据和现在又是相同的，那就是一次无效回源</li>
<li>放回缓存里，等下次被驱逐时回源。看起来解决了问题，但是此时缓存已经满了，这意味着你还需要驱逐一个资源才能放进去。这有可能会导致缓存抖动问题。</li>
</ul>
<h4 id="实现">实现</h4>
<p><code>AbstractCache</code>类作为抽象缓存类，定义两个方法交由子类实现。</p>
<p>实现引用计数，需要维护一个资源引用个数的HashMap，为了多线程访问，需要维护一个记录资源访问情况的HashMap。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当资源不在缓存时的获取行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当资源被驱逐时的写回行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(T obj)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Long, T&gt; cache;                     <span class="comment">// 实际缓存的数据</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Long, Integer&gt; references;          <span class="comment">// 资源的引用个数</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Long, Boolean&gt; getting;             <span class="comment">// 正在被获取的资源</span></span><br></pre></td></tr></table></figure>
<p>获取资源的<code>get()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> T <span class="title function_">get</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.在通过 get() 方法获取资源时，首先进入一个死循环，来无限尝试从缓存里获取。</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">// 1.1.首先就需要检查这个时候是否有其他线程正在从数据源获取这个资源，如果有，就过会再来看看</span></span><br><span class="line">            <span class="keyword">if</span>(getting.containsKey(key)) &#123;</span><br><span class="line">                <span class="comment">// 请求的资源正在被其他线程获取</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.2.如果没有其他线程在获取这个资源，那么就可以尝试从缓存中获取了</span></span><br><span class="line">            <span class="keyword">if</span>(cache.containsKey(key)) &#123;</span><br><span class="line">                <span class="comment">// 资源在缓存中，直接返回</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">                <span class="comment">// 记得给资源的引用计数加一</span></span><br><span class="line">                references.put(key, references.get(key) + <span class="number">1</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.3.尝试获取该资源</span></span><br><span class="line">            <span class="comment">// a.判断缓存是否已满，如果已满，就抛出一个异常</span></span><br><span class="line">            <span class="keyword">if</span>(maxResource &gt; <span class="number">0</span> &amp;&amp; count == maxResource) &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                <span class="keyword">throw</span> Error.CacheFullException;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// b.如果缓存未满，就在 getting 中注册一下，该线程准备从数据源获取资源了</span></span><br><span class="line">            count ++;</span><br><span class="line">            getting.put(key, <span class="literal">true</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从数据源获取资源</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = getForCache(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 如果获取失败，就把 getting 中的注册信息清除掉</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            count --;</span><br><span class="line">            getting.remove(key);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        getting.remove(key);       <span class="comment">// 获取完成要从 getting 中清除注册信息</span></span><br><span class="line">        cache.put(key, obj);</span><br><span class="line">        references.put(key, <span class="number">1</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>释放资源的<code>release</code>方法：当引用计数references 逐渐 -1 减到 0 后，就可以回源并删除缓存中相关的结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.释放资源</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(<span class="type">long</span> key)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 释放一个缓存时，直接从 references 中减 1，如果已经减到 0 了，就可以回源，并且删除缓存中所有相关的结构</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ref</span> <span class="operator">=</span> references.get(key) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(ref == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">                <span class="comment">// 调用抽象方法释放缓存</span></span><br><span class="line">                releaseForCache(obj);</span><br><span class="line">                <span class="comment">// 删除缓存中所有相关的结构</span></span><br><span class="line">                references.remove(key);</span><br><span class="line">                cache.remove(key);</span><br><span class="line">                count --;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                references.put(key, ref);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、共享内存数组">2、共享内存数组</h3>
<p>在Java中，<strong>数组</strong>被视为一个<strong>对象</strong>，其在内存中也是以对象的形式存储的。在 Java 中，当执行类似 subArray 的操作时，只会在底层进行一个复制，<strong>无法同一片内存</strong>。所以，要实现共享内存数组，定义一个<code>SubArray</code>类，规定这个数组的可使用范围：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] raw;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubArray</span><span class="params">(<span class="type">byte</span>[] raw, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.raw = raw;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、数据页的缓存与管理">3、数据页的缓存与管理</h3>
<h4 id="页面缓存">页面缓存</h4>
<p>默认数据页大小定为 8K，首先，需要定义出页面的结构。注意这个页面是存储在内存中的，与已经持久化到磁盘的抽象页面有区别。</p>
<p>定义一个页面如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageImpl</span> <span class="keyword">implements</span> <span class="title class_">Page</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pageNumber;  <span class="comment">// 页号，从1开始</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data;  <span class="comment">// 此页面实际包含的字节数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> dirty;  <span class="comment">// 标识是否是脏页面。缓存驱逐时，脏页面需要被写回磁盘</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 保存了一个 PageCache 的引用，方便在拿到 Page 的引用时可以快速对这个页面的缓存进行释放操作。</span></span><br><span class="line">    <span class="keyword">private</span> PageCache pc;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>页面缓存接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PageCache</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">newPage</span><span class="params">(<span class="type">byte</span>[] initData)</span>;</span><br><span class="line">    Page <span class="title function_">getPage</span><span class="params">(<span class="type">int</span> pgno)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(Page page)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">truncateByBgno</span><span class="params">(<span class="type">int</span> maxPgno)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getPageNumber</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">flushPage</span><span class="params">(Page pg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>页面缓存的具体实现类，需要继承抽象缓存框架，并且实现 <code>getForCache() </code>和 <code>releaseForCache() </code>两个抽象方法。由于数据源就是文件系统，<code>getForCache() </code>直接从文件中读取，并包裹成 Page 即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Page <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> (<span class="type">int</span>)key;</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> PageCacheImpl.pageOffset(pgno);</span><br><span class="line"></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(PAGE_SIZE);</span><br><span class="line">    fileLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.position(offset);</span><br><span class="line">        fc.read(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    fileLock.unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageImpl</span>(pgno, buf.array(), <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">pageOffset</span><span class="params">(<span class="type">int</span> pgno)</span> &#123;</span><br><span class="line">    <span class="comment">// 页号从 1 开始</span></span><br><span class="line">    <span class="keyword">return</span> (pgno-<span class="number">1</span>) * PAGE_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 releaseForCache() 驱逐页面时，也只需要根据页面是否是脏页面，来决定是否需要写回文件系统：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(pg.isDirty()) &#123;</span><br><span class="line">        flush(pg);</span><br><span class="line">        pg.setDirty(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> pg.getPageNumber();</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> pageOffset(pgno);</span><br><span class="line"></span><br><span class="line">    fileLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(pg.getData());</span><br><span class="line">        fc.position(offset);</span><br><span class="line">        fc.write(buf);</span><br><span class="line">        fc.force(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fileLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PageCache 还使用了一个 AtomicInteger，来记录了当前打开的数据库文件有多少页。这个数字在数据库文件被打开时就会被计算，并在新建页面时自增。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">newPage</span><span class="params">(<span class="type">byte</span>[] initData)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> pageNumbers.incrementAndGet();</span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageImpl</span>(pgno, initData, <span class="literal">null</span>);</span><br><span class="line">    flush(pg);  <span class="comment">// 新建的页面需要立刻写回</span></span><br><span class="line">    <span class="keyword">return</span> pgno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据页管理">数据页管理</h4>
<p><strong>第一页</strong>：</p>
<p>数据库文件的第一页，通常用作一些特殊用途，比如存储一些元数据，用来启动检查什么的。MYDB 的第一页，只是用来做启动检查。具体的原理是，在每次数据库启动时，会生成一串随机字节，存储在 100 ~ 107 字节。在数据库正常关闭时，会将这串字节，拷贝到第一页的 108 ~ 115 字节。</p>
<p>这样数据库在每次启动时，就会检查第一页两处的字节是否相同，以此来判断上一次是否正常关闭。如果是异常关闭，就需要执行数据的恢复流程。</p>
<p>启动时设置初始字节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcOpen</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    setVcOpen(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcOpen</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    System.arraycopy(RandomUtil.randomBytes(LEN_VC), <span class="number">0</span>, raw, OF_VC, LEN_VC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭时拷贝字节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcClose</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    setVcClose(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcClose</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    System.arraycopy(raw, OF_VC, raw, OF_VC+LEN_VC, LEN_VC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>校验字节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkVc</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> checkVc(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkVc</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.equals(Arrays.copyOfRange(raw, OF_VC, OF_VC+LEN_VC), Arrays.copyOfRange(raw, OF_VC+LEN_VC, OF_VC+<span class="number">2</span>*LEN_VC));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>普通页</strong>：</p>
<p>一个普通页面以一个 2 字节无符号数起始，表示这一页的空闲位置的偏移。剩下的部分都是实际存储的数据。</p>
<p>所以对普通页的管理，基本都是围绕着对 FSO（Free Space Offset）进行的。</p>
<p>例如向页面插入数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将raw插入pg中，返回插入位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">insert</span><span class="params">(Page pg, <span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">short</span> <span class="variable">offset</span> <span class="operator">=</span> getFSO(pg.getData());</span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length);</span><br><span class="line">    setFSO(pg.getData(), (<span class="type">short</span>)(offset + raw.length));</span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在写入之前获取 FSO，来确定写入的位置，并在写入之后更新 FSO。FSO 的操作如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFSO</span><span class="params">(<span class="type">byte</span>[] raw, <span class="type">short</span> ofData)</span> &#123;</span><br><span class="line">    System.arraycopy(Parser.short2Byte(ofData), <span class="number">0</span>, raw, OF_FREE, OF_DATA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取pg的FSO</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">getFSO</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getFSO(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">getFSO</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Parser.parseShort(Arrays.copyOfRange(raw, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取页面的空闲空间大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getFreeSpace</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PageCache.PAGE_SIZE - (<span class="type">int</span>)getFSO(pg.getData());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩余两个函数 recoverInsert() 和 recoverUpdate() 用于在数据库崩溃后重新打开时，恢复例程直接插入数据以及修改数据使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将raw插入pg中的offset位置，并将pg的offset设置为较大的offset</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recoverInsert</span><span class="params">(Page pg, <span class="type">byte</span>[] raw, <span class="type">short</span> offset)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length);</span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> <span class="variable">rawFSO</span> <span class="operator">=</span> getFSO(pg.getData());</span><br><span class="line">    <span class="keyword">if</span>(rawFSO &lt; offset + raw.length) &#123;</span><br><span class="line">        setFSO(pg.getData(), (<span class="type">short</span>)(offset+raw.length));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将raw插入pg中的offset位置，不更新update</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recoverUpdate</span><span class="params">(Page pg, <span class="type">byte</span>[] raw, <span class="type">short</span> offset)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-Version-Manager（VM）">5. Version Manager（VM）</h2>
<h2 id="6-Index-Manager-（IM）">6. Index Manager （IM）</h2>
<h2 id="7-Table-Manager（TBM）">7. Table Manager（TBM）</h2>
<h2 id="8-SQL词法解析器">8. SQL词法解析器</h2>
<h2 id="9-Server-和-Client">9. Server 和 Client</h2>
<h2 id="10-总结（从实现功能出发，由点到面逐渐总结对应的MySQL）">10. 总结（从实现功能出发，由点到面逐渐总结对应的MySQL）</h2>
<h3 id="实现的功能">实现的功能</h3>
<h4 id="数据的可靠性和数据恢复">数据的可靠性和数据恢复</h4>
<h4 id="两段锁协议（2PL）实现可串行化调度">两段锁协议（2PL）实现可串行化调度</h4>
<h4 id="MVCC">MVCC</h4>
<h4 id="两种事务隔离级别（读提交和可重复读）">两种事务隔离级别（读提交和可重复读）</h4>
<h4 id="死锁处理">死锁处理</h4>
<h4 id="简单的表和字段管理">简单的表和字段管理</h4>
<h4 id="简单的-SQL-解析">简单的 SQL 解析</h4>
<h4 id="基于-socket-的-server-和-client">基于 socket 的 server 和 client</h4>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>MYDB</tag>
        <tag>轮子</tag>
      </tags>
  </entry>
  <entry>
    <title>Wetab</title>
    <url>/post/32e2265d.html</url>
    <content><![CDATA[<blockquote>
<p>Wetab笔记，给你更好的笔记体验</p>
<p>这里是<a href="https://www.wetab.link">Wetab新标签官网</a> (右键点击打开链接)</p>
</blockquote>
<p>以下特性可以为你的笔记带来非常棒的体验：</p>
<ul>
<li>
<p>[x] 📝 <strong>所见即所得的 Markdown</strong> - 以一种优雅的方式编写 markdown</p>
</li>
<li>
<p>[x] 👍 <strong>Emoji</strong> - 支持 emoji 快捷指令和选择器</p>
</li>
<li>
<p>[x] 💾 <strong>剪贴板</strong> - 支持 markdown 格式的复制粘贴</p>
</li>
<li>
<p>[x] ⌨️ <strong>换行模式</strong> - 你可以使用“Enter”和“Shift + Enter”两种方式进行换行</p>
</li>
<li>
<p>[x] ⚡ <strong>斜线指令</strong> - 在空白处输入状态下通过“/”可以完成丰富的输入指令</p>
</li>
<li>
<p>[x] 🧮 <strong>数学支持</strong> - 你可以完成数学公式的描写</p>
</li>
<li>
<p>[x] 📊 <strong>表格支持</strong> - 拥有流畅的 ui 的表格支持</p>
</li>
<li>
<p>[x] 📰 <strong>图表支持</strong> - 基于<a href="https://mermaid-js.github.io/mermaid/#/">mermaid</a>的图表支持</p>
</li>
</ul>
<hr>
<p>你可以添加行内代码例如 <code>inline code</code> 和代码块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips: 使用<code>Mod-Enter</code>来退出块级元素，例如代码块。</p>
</blockquote>
<hr>
<p>你可以输入<code>||</code>和一个空格来创建表格：</p>
<table>
<thead>
<tr>
<th style="text-align:left">表头 1</th>
<th style="text-align:center">表头 2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">内容 1</td>
<td style="text-align:center"><s>内容 1</s></td>
</tr>
<tr>
<td style="text-align:left">内容 2</td>
<td style="text-align:center"><strong>内容</strong> 2</td>
</tr>
</tbody>
</table>
<hr>
<p>数学公式通过 <a href="https://en.wikipedia.org/wiki/TeX">TeX 表达式</a>支持。</p>
<p>这里我们有行内公式： $E = mc^2$，你可以点击并编辑它。</p>
<p>数学公式块也是支持的。</p>
<p>$$<br>
\begin{aligned}<br>
T( (v_1 + v_2) \otimes w) &amp;= T(v_1 \otimes w) + T(v_2 \otimes w) \<br>
T( v \otimes (w_1 + w_2)) &amp;= T(v \otimes w_1) + T(v \otimes w_2) \<br>
T( (\alpha v) \otimes w ) &amp;= T( \alpha ( v \otimes w) ) \<br>
T( v \otimes (\alpha w) ) &amp;= T( \alpha ( v \otimes w) ) \<br>
\end{aligned}<br>
$$</p>
<p>你可以输入<code>$$</code>和一个空格来创建数学公式块。</p>
<hr>
<p>使用 <a href="https://www.webfx.com/tools/emoji-cheat-sheet/">emoji 快捷指令</a> 例如 <code>:+1:</code> 来添加 emoji.</p>
<p>在输入时，你也许注意到了 emoji 过滤器，尝试输入<code>:baby</code>来查看它。</p>
<hr>
<p>你可以输入 <code>```mermaid</code> 来添加图表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    EditorState--&gt;EditorView;</span><br><span class="line">    EditorView--&gt;DOMEvent;</span><br><span class="line">    DOMEvent--&gt;Transaction;</span><br><span class="line">    Transaction--&gt;EditorState;</span><br></pre></td></tr></table></figure>
<hr>
<p>Wetab笔记基于 <a href="https://milkdown.dev/">Milkdown</a> 完成</p>
]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>离人</title>
    <url>/post/14e24de8.html</url>
    <content><![CDATA[<h2 id="1">1</h2>
<p>不懂事的老小孩，家里人都不关注的笨蛋，忘了给自家孙子上户口的生产队队长，拿自己儿子名字贷款给队里的工程的老不修，“人穷水都穷”连个孙娃子都收拾不干净的老头——以上，就是多年以后还留在我脑海中关于爷爷的全部印象了。</p>
<p>还记得那个三年级的午后，外婆来学校接我，说带我去看爷爷，我懵懵懂懂地跟着去了，看完了，懵懵懂懂地走了，哦，原来是爷爷帮人插秧的时候晕倒了，没抢救回来，于是，我很自然的接受了这样一个事实——爷爷死了，那个编了一天的竹篾拿去换点钱给小孙子买饮料的老头死了。</p>
<p>因为家庭的原因，我从很小的时候就一直是跟着外公外婆家一起生活的，对于这个爷爷，了解也就十分有限。倒不如说，关于他的很多事，很多印象，全是从外公外婆和爸妈口中听来，最后自行拼接而成的。每逢过年，都是必须要要去上坟的，在这个时候，听一听爸妈讲讲他过去的事，听一听爸妈给他讲他走之后他儿孙的事，再祈愿老人家在天之灵给现世的人保佑，在香蜡钱纸燃烧的火光中、在噼里啪啦的鞭炮声中，代际间的传承就就以这样的形式完成了。</p>
<h2 id="2">2</h2>
<p>年龄和脾气之间肯定是有一定关系的，无他，从我自己的经验来看就是这样，从我身边的人变化来看也是这样。</p>
<p>小学的时候吧，我的邻居家有个年龄很大的老太太，她家养了一条老母狗，很凶，真的很凶，每天我去上学从他家门口经过都心惊肉跳，走的次数多了，最后还是没躲过被咬了一回，因此，我对老太太印象也非常不好。</p>
<p>那一年，老太太家的枇杷树结果了，很多很大，我很馋，馋但是不敢。后来，老太太叫我自己上树去摘就是了，小孩子哪能受得了鼓励，坐在树上就开始一顿吃。外公刚干完活回来，见我坐在邻居家的枇杷树上大吃，很生气地叫我下来，我没理他，没想到竟然扔小石子过来，于是，我大哭着回家了。外婆回来，知道了情况，抄起二指宽的篾条就朝外公身上打去，一边打一遍骂，“哪有你这样教育娃娃的，那是拿石头打的吗，不晓得轻重，你看我今天打不打得你好看”。</p>
<p>暴躁，不知轻重，大概就是那时候外公的脾气了。</p>
<p>上高中了，我运气好，在同学的推荐下得到了市高中的青睐，分数上线就要，免学杂费。当时也没有月假一说，法定假期中时间长点的才能回家，于是，回家的次数就这样变少了。奇怪的是，我跟外公这个老头的关系倒是莫名其妙好了很多，好像几天不见这个人就褪去了往日的暴躁，转身拥抱了相反的平和。家里的打米机不好用了，一看是筛子坏了，行，你小子去街上买一张回来吧；今天要抽水去灌那片花生地，走吧，咱爷俩一块把水管和水泵扛过去；读了几天书手脚也没变慢嘛，还阔以，今天就把这片谷子打完了；“人民渠嘛，还是我切修的，当时毛老汉……”；“嗯，东西拿齐没得，武汉也没得好远嘛，当年我也是切过那边了，你切了好生学习哈，上大学了也不是给你放松的，嗯，屋头我晓得，你走嘛”……</p>
<p>平和，宁静，像一坛老酒，这是那时候外公的脾气。</p>
<h2 id="3">3</h2>
<p>一晃又是几年，好似我从未认真看过外公这个老头一样，他怎么一下子这么瘦弱了，弯腰驼背的了，眼神没有往日的犀利，嘴角却含着似有若无的笑意，像村里那口老井，记录了一切但是又将其深深埋在水底，几无人可触达。</p>
<p>前不久爸打电话给我，告诉我外公确诊了胃癌，叫我给家里打个电话好歹问一下，但是我一直不敢往家里打电话，我在害怕，在逃避，害怕自己辜负他们的期待，害怕看见他们的眼神，害怕听见他们的声音，我在逃避自己的责任，但是我又还能再躲多久呢？</p>
<p>曾经我对皮包骨头这个词的印象只停留在字典里，直到我再见到我的外公，那是怎样的一副光景？曾经力担千斤的肌肉再没有一丝一毫留存在这个老人身上，肋骨勾勒出的胸膛就这样毫无遮掩地展现着，同弯曲的脊梁骨一起狰狞地展示着时间的伟力，展示着“病”这一人世间大苦楚的威力，眉头轻蹙的样子像是在忍受着无时无刻不在的痛楚，我简直不忍再看。面对着这一切，我无话可说，我无能为力，世上难道还有什么东西能再换回这个老人的时光吗？</p>
<p>树欲静而风不止，子欲养而亲不待。初闻不识曲中意，再听已是曲中人。罢，珍惜眼前人吧。</p>
<h2 id="end">end</h2>
<p>“真没想到我们在这样一个地方告别，但是跟人告别的时候，还是要用力一点，因为你多说一句，说不定就是最后一句，多看一眼，弄不好就是最后一眼。”——《后会无期》</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu(wsl)安装Redis并搭建集群</title>
    <url>/post/ac35e331.html</url>
    <content><![CDATA[<h2 id="Ubuntu（wsl）安装Redis并搭建集群">Ubuntu（wsl）安装Redis并搭建集群</h2>
<h3 id="起因">起因</h3>
<p>配置Redis集群，Windows本机已经有了Redis，就想在wsl中装Redis集群。</p>
<h3 id="踩坑历程">踩坑历程</h3>
<ol>
<li>还就那个经典的：</li>
</ol>
<p>启动wsl时报错 <code>占位程序接收到错误数据。 Error code: Wsl/Service/0x800706f7</code>。行吧，不连梯子上不去网站，连上梯子就总有幺蛾子。解决办法：终端管理员权限运行<code>netsh winsock reset</code>，或者使用<code>NoLSP.exe</code>启动wsl。</p>
<ol start="2">
<li>Redis 安装：</li>
</ol>
<p>从<a href="http://download.redis.io/releases/">redis发行网站</a>上下载最新版本的<code>redis-7.2.0.tar.gz</code>，解压，cd到目录下，<code>make</code>构建。</p>
<p>来力：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(.<span class="property">venv</span>) vagrant@<span class="attr">vagrant</span>:<span class="regexp">/vagrant/</span>redis-<span class="number">6.0</span><span class="number">.6</span>$ make</span><br><span class="line">cd src &amp;&amp; make all</span><br><span class="line">make[<span class="number">1</span>]: <span class="title class_">Entering</span> directory <span class="string">&#x27;/vagrant/redis-6.0.6/src&#x27;</span></span><br><span class="line">/bin/<span class="attr">sh</span>: <span class="number">1</span>: pkg-<span class="attr">config</span>: not found</span><br><span class="line">    <span class="variable constant_">CC</span> <span class="title class_">Makefile</span>.<span class="property">dep</span></span><br><span class="line">/bin/<span class="attr">sh</span>: <span class="number">1</span>: pkg-<span class="attr">config</span>: not found</span><br><span class="line">make[<span class="number">1</span>]: <span class="title class_">Warning</span>: <span class="title class_">File</span> <span class="string">&#x27;Makefile.dep&#x27;</span> has modification time <span class="number">1.3</span> s <span class="keyword">in</span> the future</span><br><span class="line">    <span class="variable constant_">CC</span> adlist.<span class="property">o</span></span><br><span class="line">/bin/<span class="attr">sh</span>: <span class="number">1</span>: <span class="attr">cc</span>: not found</span><br><span class="line"><span class="title class_">Makefile</span>:<span class="number">315</span>: recipe <span class="keyword">for</span> target <span class="string">&#x27;adlist.o&#x27;</span> failed</span><br><span class="line">make[<span class="number">1</span>]: *** [adlist.<span class="property">o</span>] <span class="title class_">Error</span> <span class="number">127</span></span><br><span class="line">make[<span class="number">1</span>]: <span class="title class_">Leaving</span> directory <span class="string">&#x27;/vagrant/redis-6.0.6/src&#x27;</span></span><br><span class="line"><span class="title class_">Makefile</span>:<span class="number">6</span>: recipe <span class="keyword">for</span> target <span class="string">&#x27;all&#x27;</span> failed</span><br><span class="line"><span class="attr">make</span>: *** [all] <span class="title class_">Error</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>解决办法：</p>
<ul>
<li>少了<code>pkg-config</code>，安装之，顺便安装了<code>gcc</code>和<code>tcl</code>（没有<code>tcl</code>在 <code>make test</code>时会报错）。</li>
<li>安装<code>gcc</code>和<code>tcl</code>时会出现：<code>/sbin/ldconfig.real: /usr/lib/wsl/lib/libcuda.so.1 is not a symbolic link</code>这个问题，可<a href="https://github.com/microsoft/WSL/issues/5663">参考链接</a>（目前未深究……）。</li>
<li>然后删除解压出来的 redis 文件夹，重新解压再重新 make 。大成功。参考：<a href="https://stackoverflow.com/questions/63611270/redis-make-failing-ubuntu-18-04">ubuntu(wsl)安装redis时make报错</a></li>
</ul>
<p><img src="/post/ac35e331/Redis%E5%AE%89%E8%A3%85.jpg" alt="img"></p>
<ol start="3">
<li>Redis集群设置</li>
</ol>
<p>搭建三个节点，对应端口分别是7000,7001,7002。配置如下：<a href="https://blog.hhui.top/hexblog/2019/09/25/190925-Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%89%8B%E5%86%8C/">Redis集群搭建手册</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p data/7000 data/7001 data/7002 log/7000 log/7001 log/7002 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面的配置，一次操作三遍，分别获得r7000.conf r7001.conf r7002.conf</span></span><br><span class="line">cp redis.conf r7000.conf</span><br><span class="line">vim r7000.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 下面是我们需要修改的地方</span></span></span><br><span class="line">port 7000 # 端口号</span><br><span class="line">pidfile /var/run/redis_7000.pid # pid进程文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志和数据存储路径</span></span><br><span class="line">logfile &quot;/home/yihui/redis/log/7000/redis.log&quot;</span><br><span class="line">dir &quot;/home/yihui/redis/data/7000/&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后台启动</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启集群</span></span><br><span class="line">cluster-enabled yes</span><br></pre></td></tr></table></figure>
<p>启动Redis，设置集群，集群至少需要三主节点，设置主从时最少要六个节点，不是很有必要啊，直接不要从节点了：</p>
<p><img src="/post/ac35e331/Redis%E9%9B%86%E7%BE%A4%E8%AE%BE%E7%BD%AE.jpg" alt="img"></p>
<p>最后用<code>redis-cli</code>测试一下：</p>
<p><img src="/post/ac35e331/Redis%E9%9B%86%E7%BE%A4%E6%B5%8B%E8%AF%95.jpg" alt="img"></p>
<h3 id="番外">番外</h3>
<p>关于<code>hexo</code>中图片显示问题，<a href="https://blog.csdn.net/m0_43401436/article/details/107191688">这里</a>讲得很清楚，csdn 中难得的好文了。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>过滤器Filter</title>
    <url>/post/31fabe4c.html</url>
    <content><![CDATA[<h3 id="Filter">Filter</h3>
<h4 id="filter-流程">filter 流程</h4>
<p><img src="/post/31fabe4c/Filter%E6%B5%81%E7%A8%8B.jpg" alt="Filter流程"></p>
<p>一个 http 请求过来之后：</p>
<ul>
<li>首先进入 filter，执行相关业务逻辑</li>
<li>若判定通行，则进入 Servlet 逻辑，Servlet 执行完毕之后，又返回 Filter，最后在返回给请求方</li>
<li>判定失败，直接返回，不需要将请求发给 Servlet</li>
</ul>
<h4 id="应用场景">应用场景</h4>
<ul>
<li>在 filter 层，获取用户的身份</li>
<li>可以考虑在 filter 层做一些常规的校验 (如参数校验，referer 校验、权限控制等)</li>
<li>可以在 filter 层做运维、安全防护相关的工作(如全链路打点，可以在 flter 层分配一个 traceld;也可以在这一层做限流等)</li>
</ul>
<h4 id="使用">使用</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;, filterName = &quot;reqRecordFilter&quot;, asyncSupported = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReqRecordFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">REQ_LOG</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;req&quot;</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回给前端的traceId，用于日志追踪</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GLOBAL_TRACE_ID_HEADER</span> <span class="operator">=</span> <span class="string">&quot;g-trace-id&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GlobalInitService globalInitService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StatisticsSettingService statisticsSettingService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            request = <span class="built_in">this</span>.initReqInfo((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);</span><br><span class="line">            CrossUtil.buildCors(request, (HttpServletResponse) servletResponse);</span><br><span class="line">            filterChain.doFilter(request, servletResponse);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            buildRequestLog(ReqInfoContext.getReqInfo(), request, System.currentTimeMillis() - start);</span><br><span class="line">            <span class="comment">// 一个链路请求完毕，清空MDC相关的变量(如GlobalTraceId，用户信息)</span></span><br><span class="line">            MdcUtil.clear();</span><br><span class="line">            ReqInfoContext.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  	# ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>init：初始化时执行</p>
</li>
<li>
<p>destory： 销毁时执行</p>
</li>
<li>
<p>doFilter：filter 规则命中的请求，都会走进来</p>
</li>
<li>
<ul>
<li>三个参数，注意第三个 FilterChain，这里是经典的责任链设计模式</li>
<li>执行 filterChain.doFilter(servletRequest，servletResponse) 表示会继续将请求执行下去若不执行这一句，表示这一次的 http 请求到此为止了，后面的走不下去了</li>
</ul>
</li>
</ul>
<h4 id="注册（过滤器Filter注册到Spring容器）">注册（过滤器Filter注册到Spring容器）</h4>
<ol>
<li>使用 @WebFilter 注解，标注到自己实现的过滤器上</li>
</ol>
<p>WebFilter 常用属性如下，其中 urIPatterns 最为常用，表示这个 flter 适用于哪些 url 请求(默认场景下全部请求都被拦截)</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>fileName</td>
<td>String</td>
<td>指定过滤器的 name 属性，等价于 <filter-name>。</filter-name></td>
</tr>
<tr>
<td>value</td>
<td>String[]</td>
<td>该属性等价于 urlPatterns 属性，但是两者不应同时使用。</td>
</tr>
<tr>
<td>urlPatterns</td>
<td>String[]</td>
<td>指定一组过滤器的URL匹配模式。等价于<url-pattern>标签。</url-pattern></td>
</tr>
<tr>
<td>srvletNames</td>
<td>String[]</td>
<td>指定过滤器将应用于哪些Servlet。取值是 @WebSerlvet 中的name属性的取值，或者是web.xml中的<servlet-name>的取值。</servlet-name></td>
</tr>
<tr>
<td>dispatcherTypes</td>
<td>DispatcherType</td>
<td>指定过滤器的转发模式，具体取值包括：ASYNC/ERROR/FORWARD/INCLUDE/REQUEST.</td>
</tr>
<tr>
<td>initParams</td>
<td>WebinitParam[]</td>
<td>指定一组过滤器初始化参数，等价于<init-param>标签。</init-param></td>
</tr>
<tr>
<td>asyncSupported</td>
<td>boolean</td>
<td>声明过滤器是否支持异步操作模式，等价于<async-supported>标签。</async-supported></td>
</tr>
<tr>
<td>description</td>
<td>String</td>
<td>该过滤器的描述信息，等价于<description>标签。</description></td>
</tr>
<tr>
<td>displayName</td>
<td>String</td>
<td>该过滤器的显示名，通常配合工具使用，等价于 <display-name> 标签</display-name></td>
</tr>
</tbody>
</table>
<p>使用这个注解时，请注意，需要在<strong>启动类/配置类</strong>上添加 <strong>ServletComponentScan</strong> 注解来启用.</p>
<p><strong>注意点1</strong>：@WebFilter 注解结合@Order 来定义 filter 注解，可能并不会生效。</p>
<p><strong>注意点2</strong>：@WebFilter 声明的Filter，优先级为 2147483647 (最低优先级）。</p>
<ol start="2">
<li>FilterRegistrationBean</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public FilterRegistrationBean&lt;Filter&gt; orderFilter() &#123;</span><br><span class="line">		FilterRegistrationBean&lt;Filter&gt; filter = new FilterRegistrationBean&lt;&gt;();</span><br><span class="line">		filter.setName(&quot;regRecordFilter&quot;);</span><br><span class="line">		filter.seturlPatterns(Arrays.asList(&quot;/**&quot;));</span><br><span class="line">		filter.setFilter(new RegRecordFilter());  //指定优先级</span><br><span class="line">		filter.setorder(-1);</span><br><span class="line">		return filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实例">实例</h4>
<p>技术派中，Filter 应用到了以下几个地方:</p>
<ul>
<li>身份识别，并保存身份到 RegInfoContext 上下文中。详情博文: <a href="https://www.yuque.com/itwanger/az7yww/yk1x4v6wt5gz103q">https://www.yuque.com/itwanger/az7yww/yk1x4v6wt5gz103q</a></li>
<li>记录请求记录，详情博文: <a href="https://www.yuque.com/itwanger/az7yww/wb3pz26699c86nuz">https://www.yuque.com/itwanger/az7yww/wb3pz26699c86nuz</a></li>
<li>添加跨域支持，详情博文: <a href="https://www.yuque.com/itwanger/az7yww/pznv1robndgbuyhh">https://www.yuque.com/itwanger/az7yww/pznv1robndgbuyhh</a></li>
</ul>
<h4 id="filter-在技术派中的应用总结">filter 在技术派中的应用总结</h4>
<p><img src="/post/31fabe4c/Filter%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.png" alt="Filter知识点总结"></p>
<h4 id="最后">最后</h4>
<p><a href="https://github.com/itwanger/paicoding">技术派项目地址</a></p>
]]></content>
      <categories>
        <category>coding</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
</search>
