<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MYDB记录</title>
    <url>/post/7e29e8fb.html</url>
    <content><![CDATA[<h2 id="1-clone-本地运行">1. clone&amp;本地运行</h2>
<h3 id="1-1-环境">1.1. 环境</h3>
<ul>
<li>jdk：17.07</li>
<li>maven：3.9.2</li>
<li>os：windows 11</li>
</ul>
<h3 id="1-2-运行前设置">1.2. 运行前设置</h3>
<ul>
<li>none</li>
</ul>
<h3 id="1-3-问题">1.3. 问题</h3>
<ul>
<li>none</li>
</ul>
<h2 id="2-文档先行：整体架构">2. 文档先行：整体架构</h2>
<h3 id="整体架构">整体架构</h3>
<h4 id="前端（客户端）">前端（客户端）</h4>
<p>读取用户输入，发送到后端执行，输出返回结果。等待下一次输入。</p>
<h4 id="SQL解析器（后面补充）">SQL解析器（后面补充）</h4>
<p>解析SQL，包装成对应的对象。</p>
<h4 id="后端">后端</h4>
<p>解析SQL，若合法，尝试执行并返回结果。</p>
<p>模块划分：各个模块通过接口向其依赖的模块提供方法</p>
<ol>
<li>Transaction Manager（TM）</li>
<li>Data Manager（DM）</li>
<li>Version Manager（VM）</li>
<li>Index Manager（IM）</li>
<li>Table Manager（TBM）</li>
</ol>
<p>五个模块的依赖图如下，拓补排序得出实现顺序为：TM -&gt; DM -&gt; VM -&gt; IM -&gt; TBM</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35904594/1692178246671-63ef0550-24a3-4244-bee2-0f6676035fd0.png" alt="img"></p>
<p>各个模块的职责：</p>
<ol>
<li>TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。</li>
<li>DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：1) 分页管理 DB 文件，并进行缓存；2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。</li>
<li>VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。</li>
<li>IM 实现了基于 B+ 树的索引，目前 where 只支持已索引字段。</li>
<li>TBM 实现了对字段和表的管理。同时，解析 SQL 语句，并根据语句操作表。</li>
</ol>
<h2 id="3-Transaction-Manager（TM）">3. Transaction Manager（TM）</h2>
<p>TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。</p>
<h3 id="XID-文件">XID  文件</h3>
<p>XID 文件规则：</p>
<p>每个事物都有一个 xid，这个 ID 是一个事务的<strong>唯一标识</strong>。事务的 xid 从 <strong>1</strong> 开始编号，自增，不可重复。规定 xid 为 0 的事务是超级事务（super transaction），想在没有申请事务的情况下进行一些操作时，可将操作的 xid 设置为 0，超级事务的状态一直是 committed。</p>
<p>MYDB 中事务的状态：</p>
<ol>
<li>active，进行中</li>
<li>committed，已提交</li>
<li>aborted，已撤销（回滚）</li>
</ol>
<p>XID 文件内容的结构：</p>
<ol>
<li>给每个事务分配<strong>一个字节</strong>的空间来保存其<strong>状态</strong>。</li>
<li>XID 文件头部保存一个 <strong>8 字节数字</strong>，记录此 XID 文件管理<strong>事务的个数</strong>。</li>
<li>事务 xid 在文件中的状态存储位置在 <strong>(xid-1)+8 字节处</strong>。（xid-1 是因为 xid 为 0 的状态不需要记录。）</li>
</ol>
<h3 id="TransactionManager">TransactionManager</h3>
<p>提供的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">begin</span><span class="params">()</span>;                       <span class="comment">// 开启一个新事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span>;              <span class="comment">// 提交一个事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">long</span> xid)</span>;               <span class="comment">// 取消一个事务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">(<span class="type">long</span> xid)</span>;         <span class="comment">// 查询一个事务的状态是否是正在进行的状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCommitted</span><span class="params">(<span class="type">long</span> xid)</span>;      <span class="comment">// 查询一个事务的状态是否是已提交</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAborted</span><span class="params">(<span class="type">long</span> xid)</span>;        <span class="comment">// 查询一个事务的状态是否是已取消</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;                       <span class="comment">// 关闭TM</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据定义的 XID 文件结构，得到需要定义的一些常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XID文件头长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LEN_XID_HEADER_LENGTH</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 每个事务的占用长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">XID_FIELD_SIZE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 事务的三种状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_ACTIVE</span>   <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_COMMITTED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_ABORTED</span>  <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 超级事务，永远为commited状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SUPER_XID</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// XID 文件后缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">XID_SUFFIX</span> <span class="operator">=</span> <span class="string">&quot;.xid&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>在构造函数创建了一个 TransactionManager 之后，首先要对 XID 文件进行校验，以保证这是一个合法的 XID 文件。校验的方式是通过文件头的 8 字节数字反推文件的理论长度，与文件的实际长度做对比。如果不同则认为 XID 文件不合法。当校验不通过时，调用自定义方法强制停机。</p>
<p><code>begin()</code>方法：开启一个事务——</p>
<ul>
<li>首先设置 xidCounter+1 事务的状态为 committed，</li>
<li>然后 xidCounter 自增</li>
<li>同时，事务数量增加了一个，别忘记更新文件头。</li>
</ul>
<p><strong>注意点</strong>：所有文件操作在执行后都需要立刻刷入文件中，防止崩溃后文件丢失数据。</p>
<p>从查询事务状态的方法中抽象出一种公共的方法，使得实现事务状态查询时只需根据条件调用此方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测XID事务是否处于status状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkXID</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span> status)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> getXidPosition(xid);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="keyword">new</span> <span class="title class_">byte</span>[XID_FIELD_SIZE]);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.position(offset);</span><br><span class="line">        fc.read(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf.array()[<span class="number">0</span>] == status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在接口 TransactionManager 中，使用<strong>单例模式</strong> 创建 TM，其有两种方式，分别是：先新建 XID 文件再创建 TM实例（create 方法），或者从一个已有的 XID 文件中创建 TM 实例（open 方法）。要注意的是，从零创建 XID 文件时需要写一个<strong>空的 XID 文件头</strong>，即设置 xidCounter 为 0，否则后续在校验时会不合法</p>
<h2 id="4-Data-Manager（DM）">4. Data Manager（DM）</h2>
<p>DataManager（DM）功能归纳：</p>
<ul>
<li>上层模块和文件系统中的一个抽象层。向上，提供数据包装；向下，直接读写文件。</li>
<li>提供日志功能。</li>
</ul>
<h3 id="1、引用计数缓存框架">1、引用计数缓存框架</h3>
<p>分页管理和数据项（DataItem）管理涉及缓存，故抽象出一个通用缓存框架。</p>
<h4 id="引用计数法">引用计数法</h4>
<p>引用计数法（Reference counting）是一种内存管理技术，它通过计算每个对象被引用的次数来判断是否需要回收该对象。当对象被创建时，引用计数为1，每当有一个新的引用指向该对象时，计数加1，当引用失效时，计数减1。当计数为0时，该对象就可以被回收。</p>
<p>在MYDB的实践中，需要的效果是，只有上层模块主动释放引用，缓存在确保没有模块在使用这个资源了，才会去驱逐资源。</p>
<p>于是，选择引用计数法。增加了一个方法 release(key)，用于在上册模块不使用某个资源时，释放对资源的引用。当引用归零时，缓存就会驱逐这个资源。</p>
<p>同样，在缓存满了之后，引用计数法无法自动释放缓存，此时应该直接报错（和 JVM 似的，直接 OOM）。</p>
<h4 id="LRU">LRU</h4>
<p>LRU（least recently used）是一种缓存淘汰算法。它的特点是根据数据最近被访问的时间来决定哪些数据应该被保留，哪些数据应该被淘汰。当缓存达到一定容量时，会淘汰掉最近最少使用的数据。</p>
<p>如果使用 LRU 缓存，那么只需要设计一个 get(key) 接口即可，释放缓存可以在缓存满了之后自动完成。</p>
<p>however，当某时刻缓存满了，缓存驱逐一个资源，此时上层模块想将某个资源强制刷回3数据源，这个资源恰恰是刚被驱逐的资源。此时的上层模块会发现，资源在缓存中消失了，那么，是否有必要做回源操作？</p>
<ul>
<li>不回源。由于没法确定缓存被驱逐的时间，更没法确定被驱逐之后数据项是否被修改，这样是极其不安全的</li>
<li>回源。如果数据项被驱逐时的数据和现在又是相同的，那就是一次无效回源</li>
<li>放回缓存里，等下次被驱逐时回源。看起来解决了问题，但是此时缓存已经满了，这意味着你还需要驱逐一个资源才能放进去。这有可能会导致缓存抖动问题。</li>
</ul>
<h4 id="实现">实现</h4>
<p><code>AbstractCache</code>类作为抽象缓存类，定义两个方法交由子类实现。</p>
<p>实现引用计数，需要维护一个资源引用个数的HashMap，为了多线程访问，需要维护一个记录资源访问情况的HashMap。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当资源不在缓存时的获取行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当资源被驱逐时的写回行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(T obj)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Long, T&gt; cache;                     <span class="comment">// 实际缓存的数据</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Long, Integer&gt; references;          <span class="comment">// 资源的引用个数</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Long, Boolean&gt; getting;             <span class="comment">// 正在被获取的资源</span></span><br></pre></td></tr></table></figure>
<p>获取资源的<code>get()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> T <span class="title function_">get</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.在通过 get() 方法获取资源时，首先进入一个死循环，来无限尝试从缓存里获取。</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">// 1.1.首先就需要检查这个时候是否有其他线程正在从数据源获取这个资源，如果有，就过会再来看看</span></span><br><span class="line">            <span class="keyword">if</span>(getting.containsKey(key)) &#123;</span><br><span class="line">                <span class="comment">// 请求的资源正在被其他线程获取</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.2.如果没有其他线程在获取这个资源，那么就可以尝试从缓存中获取了</span></span><br><span class="line">            <span class="keyword">if</span>(cache.containsKey(key)) &#123;</span><br><span class="line">                <span class="comment">// 资源在缓存中，直接返回</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">                <span class="comment">// 记得给资源的引用计数加一</span></span><br><span class="line">                references.put(key, references.get(key) + <span class="number">1</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.3.尝试获取该资源</span></span><br><span class="line">            <span class="comment">// a.判断缓存是否已满，如果已满，就抛出一个异常</span></span><br><span class="line">            <span class="keyword">if</span>(maxResource &gt; <span class="number">0</span> &amp;&amp; count == maxResource) &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                <span class="keyword">throw</span> Error.CacheFullException;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// b.如果缓存未满，就在 getting 中注册一下，该线程准备从数据源获取资源了</span></span><br><span class="line">            count ++;</span><br><span class="line">            getting.put(key, <span class="literal">true</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从数据源获取资源</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = getForCache(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 如果获取失败，就把 getting 中的注册信息清除掉</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            count --;</span><br><span class="line">            getting.remove(key);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        getting.remove(key);       <span class="comment">// 获取完成要从 getting 中清除注册信息</span></span><br><span class="line">        cache.put(key, obj);</span><br><span class="line">        references.put(key, <span class="number">1</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>释放资源的<code>release</code>方法：当引用计数references 逐渐 -1 减到 0 后，就可以回源并删除缓存中相关的结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.释放资源</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(<span class="type">long</span> key)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 释放一个缓存时，直接从 references 中减 1，如果已经减到 0 了，就可以回源，并且删除缓存中所有相关的结构</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ref</span> <span class="operator">=</span> references.get(key) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(ref == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">                <span class="comment">// 调用抽象方法释放缓存</span></span><br><span class="line">                releaseForCache(obj);</span><br><span class="line">                <span class="comment">// 删除缓存中所有相关的结构</span></span><br><span class="line">                references.remove(key);</span><br><span class="line">                cache.remove(key);</span><br><span class="line">                count --;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                references.put(key, ref);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、共享内存数组">2、共享内存数组</h3>
<p>在Java中，<strong>数组</strong>被视为一个<strong>对象</strong>，其在内存中也是以对象的形式存储的。在 Java 中，当执行类似 subArray 的操作时，只会在底层进行一个复制，<strong>无法同一片内存</strong>。所以，要实现共享内存数组，定义一个<code>SubArray</code>类，规定这个数组的可使用范围：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] raw;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubArray</span><span class="params">(<span class="type">byte</span>[] raw, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.raw = raw;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-Version-Manager（VM）">5. Version Manager（VM）</h2>
<h2 id="6-Index-Manager-（IM）">6. Index Manager （IM）</h2>
<h2 id="7-Table-Manager（TBM）">7. Table Manager（TBM）</h2>
<h2 id="8-SQL词法解析器">8. SQL词法解析器</h2>
<h2 id="9-Server-和-Client">9. Server 和 Client</h2>
<h2 id="10-总结（从实现功能出发，由点到面逐渐总结对应的MySQL）">10. 总结（从实现功能出发，由点到面逐渐总结对应的MySQL）</h2>
<h3 id="实现的功能">实现的功能</h3>
<h4 id="数据的可靠性和数据恢复">数据的可靠性和数据恢复</h4>
<h4 id="两段锁协议（2PL）实现可串行化调度">两段锁协议（2PL）实现可串行化调度</h4>
<h4 id="MVCC">MVCC</h4>
<h4 id="两种事务隔离级别（读提交和可重复读）">两种事务隔离级别（读提交和可重复读）</h4>
<h4 id="死锁处理">死锁处理</h4>
<h4 id="简单的表和字段管理">简单的表和字段管理</h4>
<h4 id="简单的-SQL-解析">简单的 SQL 解析</h4>
<h4 id="基于-socket-的-server-和-client">基于 socket 的 server 和 client</h4>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>MYDB</tag>
        <tag>轮子</tag>
      </tags>
  </entry>
  <entry>
    <title>Wetab</title>
    <url>/post/32e2265d.html</url>
    <content><![CDATA[<blockquote>
<p>Wetab笔记，给你更好的笔记体验</p>
<p>这里是<a href="https://www.wetab.link">Wetab新标签官网</a> (右键点击打开链接)</p>
</blockquote>
<p>以下特性可以为你的笔记带来非常棒的体验：</p>
<ul>
<li>
<p>[x] 📝 <strong>所见即所得的 Markdown</strong> - 以一种优雅的方式编写 markdown</p>
</li>
<li>
<p>[x] 👍 <strong>Emoji</strong> - 支持 emoji 快捷指令和选择器</p>
</li>
<li>
<p>[x] 💾 <strong>剪贴板</strong> - 支持 markdown 格式的复制粘贴</p>
</li>
<li>
<p>[x] ⌨️ <strong>换行模式</strong> - 你可以使用“Enter”和“Shift + Enter”两种方式进行换行</p>
</li>
<li>
<p>[x] ⚡ <strong>斜线指令</strong> - 在空白处输入状态下通过“/”可以完成丰富的输入指令</p>
</li>
<li>
<p>[x] 🧮 <strong>数学支持</strong> - 你可以完成数学公式的描写</p>
</li>
<li>
<p>[x] 📊 <strong>表格支持</strong> - 拥有流畅的 ui 的表格支持</p>
</li>
<li>
<p>[x] 📰 <strong>图表支持</strong> - 基于<a href="https://mermaid-js.github.io/mermaid/#/">mermaid</a>的图表支持</p>
</li>
</ul>
<hr>
<p>你可以添加行内代码例如 <code>inline code</code> 和代码块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips: 使用<code>Mod-Enter</code>来退出块级元素，例如代码块。</p>
</blockquote>
<hr>
<p>你可以输入<code>||</code>和一个空格来创建表格：</p>
<table>
<thead>
<tr>
<th style="text-align:left">表头 1</th>
<th style="text-align:center">表头 2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">内容 1</td>
<td style="text-align:center"><s>内容 1</s></td>
</tr>
<tr>
<td style="text-align:left">内容 2</td>
<td style="text-align:center"><strong>内容</strong> 2</td>
</tr>
</tbody>
</table>
<hr>
<p>数学公式通过 <a href="https://en.wikipedia.org/wiki/TeX">TeX 表达式</a>支持。</p>
<p>这里我们有行内公式： $E = mc^2$，你可以点击并编辑它。</p>
<p>数学公式块也是支持的。</p>
<p>$$<br>
\begin{aligned}<br>
T( (v_1 + v_2) \otimes w) &amp;= T(v_1 \otimes w) + T(v_2 \otimes w) \<br>
T( v \otimes (w_1 + w_2)) &amp;= T(v \otimes w_1) + T(v \otimes w_2) \<br>
T( (\alpha v) \otimes w ) &amp;= T( \alpha ( v \otimes w) ) \<br>
T( v \otimes (\alpha w) ) &amp;= T( \alpha ( v \otimes w) ) \<br>
\end{aligned}<br>
$$</p>
<p>你可以输入<code>$$</code>和一个空格来创建数学公式块。</p>
<hr>
<p>使用 <a href="https://www.webfx.com/tools/emoji-cheat-sheet/">emoji 快捷指令</a> 例如 <code>:+1:</code> 来添加 emoji.</p>
<p>在输入时，你也许注意到了 emoji 过滤器，尝试输入<code>:baby</code>来查看它。</p>
<hr>
<p>你可以输入 <code>```mermaid</code> 来添加图表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    EditorState--&gt;EditorView;</span><br><span class="line">    EditorView--&gt;DOMEvent;</span><br><span class="line">    DOMEvent--&gt;Transaction;</span><br><span class="line">    Transaction--&gt;EditorState;</span><br></pre></td></tr></table></figure>
<hr>
<p>Wetab笔记基于 <a href="https://milkdown.dev/">Milkdown</a> 完成</p>
]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>过滤器Filter</title>
    <url>/post/31fabe4c.html</url>
    <content><![CDATA[<h3 id="Filter">Filter</h3>
<h4 id="filter-流程">filter 流程</h4>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fspring.hhui.top%2Fspring-blog%2Fimgs%2F190323%2F00.jpg&amp;sign=dbe2eb02c85bcb96cd3078214dbf49d629aed33c3fd6cf8aff8a4839d5e2dabf" alt="img"></p>
<p>一个 http 请求过来之后：</p>
<ul>
<li>首先进入 filter，执行相关业务逻辑</li>
<li>若判定通行，则进入 Servlet 逻辑，Servlet 执行完毕之后，又返回 Filter，最后在返回给请求方</li>
<li>判定失败，直接返回，不需要将请求发给 Servlet</li>
</ul>
<h4 id="应用场景">应用场景</h4>
<ul>
<li>在 filter 层，获取用户的身份</li>
<li>可以考虑在 filter 层做一些常规的校验 (如参数校验，referer 校验、权限控制等)</li>
<li>可以在 filter 层做运维、安全防护相关的工作(如全链路打点，可以在 flter 层分配一个 traceld;也可以在这一层做限流等)</li>
</ul>
<h4 id="使用">使用</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@WebFilter(urlPatterns = &quot;/*&quot;, filterName = &quot;reqRecordFilter&quot;, asyncSupported = true)</span><br><span class="line">public class ReqRecordFilter implements Filter &#123;</span><br><span class="line">    private static Logger REQ_LOG = LoggerFactory.getLogger(&quot;req&quot;);</span><br><span class="line">    /**</span><br><span class="line">     * 返回给前端的traceId，用于日志追踪</span><br><span class="line">     */</span><br><span class="line">    private static final String GLOBAL_TRACE_ID_HEADER = &quot;g-trace-id&quot;;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private GlobalInitService globalInitService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StatisticsSettingService statisticsSettingService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        HttpServletRequest request = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            request = this.initReqInfo((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);</span><br><span class="line">            CrossUtil.buildCors(request, (HttpServletResponse) servletResponse);</span><br><span class="line">            filterChain.doFilter(request, servletResponse);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            buildRequestLog(ReqInfoContext.getReqInfo(), request, System.currentTimeMillis() - start);</span><br><span class="line">            // 一个链路请求完毕，清空MDC相关的变量(如GlobalTraceId，用户信息)</span><br><span class="line">            MdcUtil.clear();</span><br><span class="line">            ReqInfoContext.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	@Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  	# ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>init：初始化时执行</p>
</li>
<li>
<p>destory： 销毁时执行</p>
</li>
<li>
<p>doFilter：filter 规则命中的请求，都会走进来</p>
</li>
<li>
<ul>
<li>三个参数，注意第三个 FilterChain，这里是经典的责任链设计模式</li>
<li>执行 filterChain.doFilter(servletRequest，servletResponse) 表示会继续将请求执行下去若不执行这一句，表示这一次的 http 请求到此为止了，后面的走不下去了</li>
</ul>
</li>
</ul>
<h4 id="注册（过滤器Filter注册到Spring容器）">注册（过滤器Filter注册到Spring容器）</h4>
<ol>
<li>使用 @WebFilter 注解，标注到自己实现的过滤器上</li>
</ol>
<p>WebFilter 常用属性如下，其中 urIPatterns 最为常用，表示这个 flter 适用于哪些 url 请求(默认场景下全部请求都被拦截)</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>fileName</td>
<td>String</td>
<td>指定过滤器的 name 属性，等价于 <filter-name>。</td>
</tr>
<tr>
<td>value</td>
<td>String[]</td>
<td>该属性等价于 urlPatterns 属性，但是两者不应同时使用。</td>
</tr>
<tr>
<td>urlPatterns</td>
<td>String[]</td>
<td>指定一组过滤器的URL匹配模式。等价于<url-pattern>标签。</td>
</tr>
<tr>
<td>srvletNames</td>
<td>String[]</td>
<td>指定过滤器将应用于哪些Servlet。取值是 @WebSerlvet 中的name属性的取值，或者是web.xml中的<servlet-name>的取值。</td>
</tr>
<tr>
<td>dispatcherTypes</td>
<td>DispatcherType</td>
<td>指定过滤器的转发模式，具体取值包括：ASYNC/ERROR/FORWARD/INCLUDE/REQUEST.</td>
</tr>
<tr>
<td>initParams</td>
<td>WebinitParam[]</td>
<td>指定一组过滤器初始化参数，等价于<init-param>标签。</td>
</tr>
<tr>
<td>asyncSupported</td>
<td>boolean</td>
<td>声明过滤器是否支持异步操作模式，等价于<async-supported>标签。</td>
</tr>
<tr>
<td>description</td>
<td>String</td>
<td>该过滤器的描述信息，等价于<description>标签。</td>
</tr>
<tr>
<td>displayName</td>
<td>String</td>
<td>该过滤器的显示名，通常配合工具使用，等价于 <display-name> 标签</td>
</tr>
</tbody>
</table>
<p>使用这个注解时，请注意，需要在<strong>启动类/配置类</strong>上添加 <strong>ServletComponentScan</strong> 注解来启用.</p>
<p><strong>注意点1</strong>：@WebFilter 注解结合@Order 来定义 filter 注解，可能并不会生效。</p>
<p><strong>注意点2</strong>：@WebFilter 声明的Filter，优先级为 2147483647 (最低优先级）。</p>
<ol start="2">
<li>FilterRegistrationBean</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public FilterRegistrationBean&lt;Filter&gt; orderFilter() &#123;</span><br><span class="line">		FilterRegistrationBean&lt;Filter&gt; filter = new FilterRegistrationBean&lt;&gt;();</span><br><span class="line">		filter.setName(&quot;regRecordFilter&quot;);</span><br><span class="line">		filter.seturlPatterns(Arrays.asList(&quot;/**&quot;));</span><br><span class="line">		filter.setFilter(new RegRecordFilter());  //指定优先级</span><br><span class="line">		filter.setorder(-1);</span><br><span class="line">		return filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实例">实例</h4>
<p>技术派中，Filter 应用到了以下几个地方:</p>
<ul>
<li>身份识别，并保存身份到 RegInfoContext 上下文中。详情博文: <a href="https://www.yuque.com/itwanger/az7yww/yk1x4v6wt5gz103q">https://www.yuque.com/itwanger/az7yww/yk1x4v6wt5gz103q</a></li>
<li>记录请求记录，详情博文: <a href="https://www.yuque.com/itwanger/az7yww/wb3pz26699c86nuz">https://www.yuque.com/itwanger/az7yww/wb3pz26699c86nuz</a></li>
<li>添加跨域支持，详情博文: <a href="https://www.yuque.com/itwanger/az7yww/pznv1robndgbuyhh">https://www.yuque.com/itwanger/az7yww/pznv1robndgbuyhh</a></li>
</ul>
<h4 id="filter-在技术派中的应用总结">filter 在技术派中的应用总结</h4>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35904594/1693227389336-59e1e8c1-aa85-450d-911d-2e4dacffadbb.png" alt="img"></p>
<h4 id="最后">最后</h4>
<p><a href="https://github.com/itwanger/paicoding">技术派项目地址</a></p>
]]></content>
      <categories>
        <category>coding</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>离人</title>
    <url>/post/14e24de8.html</url>
    <content><![CDATA[<h2 id="1">1</h2>
<p>不懂事的老小孩，家里人都不关注的笨蛋，忘了给自家孙子上户口的生产队队长，拿自己儿子名字贷款给队里的工程的老不修，“人穷水都穷”连个孙娃子都收拾不干净的老头——以上，就是多年以后还留在我脑海中关于爷爷的全部印象了。</p>
<p>还记得那个三年级的午后，外婆来学校接我，说带我去看爷爷，我懵懵懂懂地跟着去了，看完了，懵懵懂懂地走了，哦，原来是爷爷帮人插秧的时候晕倒了，没抢救回来，于是，我很自然的接受了这样一个事实——爷爷死了，那个编了一天的竹篾拿去换点钱给小孙子买饮料的老头死了。</p>
<p>因为家庭的原因，我从很小的时候就一直是跟着外公外婆家一起生活的，对于这个爷爷，了解也就十分有限。倒不如说，关于他的很多事，很多印象，全是从外公外婆和爸妈口中听来，最后自行拼接而成的。每逢过年，都是必须要要去上坟的，在这个时候，听一听爸妈讲讲他过去的事，听一听爸妈给他讲他走之后他儿孙的事，再祈愿老人家在天之灵给现世的人保佑，在香蜡钱纸燃烧的火光中、在噼里啪啦的鞭炮声中，代际间的传承就就以这样的形式完成了。</p>
<h2 id="2">2</h2>
<p>年龄和脾气之间肯定是有一定关系的，无他，从我自己的经验来看就是这样，从我身边的人变化来看也是这样。</p>
<p>小学的时候吧，我的邻居家有个年龄很大的老太太，她家养了一条老母狗，很凶，真的很凶，每天我去上学从他家门口经过都心惊肉跳，走的次数多了，最后还是没躲过被咬了一回，因此，我对老太太印象也非常不好。</p>
<p>那一年，老太太家的枇杷树结果了，很多很大，我很馋，馋但是不敢。后来，老太太叫我自己上树去摘就是了，小孩子哪能受得了鼓励，坐在树上就开始一顿吃。外公刚干完活回来，见我坐在邻居家的枇杷树上大吃，很生气地叫我下来，我没理他，没想到竟然扔小石子过来，于是，我大哭着回家了。外婆回来，知道了情况，抄起二指宽的篾条就朝外公身上打去，一边打一遍骂，“哪有你这样教育娃娃的，那是拿石头打的吗，不晓得轻重，你看我今天打不打得你好看”。</p>
<p>暴躁，不知轻重，大概就是那时候外公的脾气了。</p>
<p>上高中了，我运气好，在同学的推荐下得到了市高中的青睐，分数上线就要，免学杂费。当时也没有月假一说，法定假期中时间长点的才能回家，于是，回家的次数就这样变少了。奇怪的是，我跟外公这个老头的关系倒是莫名其妙好了很多，好像几天不见这个人就褪去了往日的暴躁，转身拥抱了相反的平和。家里的打米机不好用了，一看是筛子坏了，行，你小子去街上买一张回来吧；今天要抽水去灌那片花生地，走吧，咱爷俩一块把水管和水泵扛过去；读了几天书手脚也没变慢嘛，还阔以，今天就把这片谷子打完了；“人民渠嘛，还是我切修的，当时毛老汉……”；“嗯，东西拿齐没得，武汉也没得好远嘛，当年我也是切过那边了，你切了好生学习哈，上大学了也不是给你放松的，嗯，屋头我晓得，你走嘛”……</p>
<p>平和，宁静，像一坛老酒，这是那时候外公的脾气。</p>
<h2 id="3">3</h2>
<p>一晃又是几年，好似我从未认真看过外公这个老头一样，他怎么一下子这么瘦弱了，弯腰驼背的了，眼神没有往日的犀利，嘴角却含着似有若无的笑意，像村里那口老井，记录了一切但是又将其深深埋在水底，几无人可触达。</p>
<p>前不久爸打电话给我，告诉我外公确诊了胃癌，叫我给家里打个电话好歹问一下，但是我一直不敢往家里打电话，我在害怕，在逃避，害怕自己辜负他们的期待，害怕看见他们的眼神，害怕听见他们的声音，我在逃避自己的责任，但是我又还能再躲多久呢？</p>
<p>曾经我对皮包骨头这个词的印象只停留在字典里，直到我再见到我的外公，那是怎样的一副光景？曾经力担千斤的肌肉再没有一丝一毫留存在这个老人身上，肋骨勾勒出的胸膛就这样毫无遮掩地展现着，同弯曲的脊梁骨一起狰狞地展示着时间的伟力，展示着“病”这一人世间大苦楚的威力，眉头轻蹙的样子像是在忍受着无时无刻不在的痛楚，我简直不忍再看。面对着这一切，我无话可说，我无能为力，世上难道还有什么东西能再换回这个老人的时光吗？</p>
<p>树欲静而风不止，子欲养而亲不待。初闻不识曲中意，再听已是曲中人。罢，珍惜眼前人吧。</p>
<h2 id="end">end</h2>
<p>“真没想到我们在这样一个地方告别，但是跟人告别的时候，还是要用力一点，因为你多说一句，说不定就是最后一句，多看一眼，弄不好就是最后一眼。”——《后会无期》</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
</search>
