<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java代理模式</title>
    <url>/post/cffaadf.html</url>
    <content><![CDATA[<h2 id="Java代理模式">Java代理模式</h2>
<h3 id="代理模式">代理模式</h3>
<p>代理模式是一种比较好理解的设计模式。简单来说就是 我们<strong>使用代理对象来代替对真实对象(real object)的访问</strong>，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p>
<p>代理模式的主要作用是<strong>扩展目标对象的功能</strong>，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</p>
<p>可分为静态代理和动态代理两种。</p>
<h3 id="静态代理">静态代理</h3>
<p>静态代理中，我们<strong>对目标对象的每个方法的增强都是手动完成的</strong>，非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类）。</p>
<p>实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p>
<p>上面我们是从实现和应用角度来说的静态代理，从 <strong>JVM</strong> 层面来说， 静态代理在<strong>编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件</strong>。</p>
<p>静态代理实现步骤：</p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。</li>
</ol>
<p>这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</p>
<p><strong>代码</strong>：</p>
<ol>
<li>定义接口，功能是发送信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>实现接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message：&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>代理对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsProxy</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsProxy</span><span class="params">(SmsService smsService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.smsService = smsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">// before方法</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;before send message&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        smsService.send(message);</span><br><span class="line">        <span class="comment">// after方法</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;before send message&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>();</span><br><span class="line">        <span class="type">SmsProxy</span> <span class="variable">smsProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsProxy</span>(smsService);</span><br><span class="line">        smsProxy.send(<span class="string">&quot;way of using static proxy &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态代理">动态代理</h3>
<p>相比于静态代理来说，动态代理更加灵活。</p>
<p>我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( CGLIB 动态代理机制)。</p>
<p>从 JVM 角度来说，<strong>动态代理是在运行时动态生成类字节码，并加载到 JVM 中</strong>的。</p>
<p>说到动态代理，<strong>Spring AOP、RPC 框架</strong>应该是两个不得不提的，它们的实现都依赖了动态代理。动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</p>
<h4 id="JDK动态代理">JDK动态代理</h4>
<ol>
<li><strong>简介</strong></li>
</ol>
<p>在 Java 动态代理机制中 InvocationHandler 接口和 Proxy 类是核心。Proxy 类中使用频率最高的方法是：newProxyInstance() ，这个方法主要用来生成一个代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法一共有 3 个参数：</p>
<ul>
<li>loader :类加载器，用于加载代理对象。</li>
<li>interfaces : 被代理类实现的一些接口；</li>
<li>h : 实现了 InvocationHandler 接口的对象；要实现动态代理的话，还必须需要实现InvocationHandler 来自定义处理逻辑。</li>
</ul>
<p>当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现 InvocationHandler 接口类的 invoke 方法来调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>invoke() 方法有下面三个参数：</p>
<ul>
<li>proxy :动态生成的代理类</li>
<li>method : 与代理类对象调用的方法相对应a</li>
<li>rgs : 当前 method 方法的参数</li>
</ul>
<p>也就是说：你通过Proxy 类的 newProxyInstance() 创建的代理对象在调用方法的时候，实际会调用到实现InvocationHandler 接口的类的 invoke()方法。 你可以在 invoke() 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p>
<ol start="2">
<li><strong>实现步骤</strong></li>
</ol>
<ul>
<li>定义一个接口及其实现类；</li>
<li>自定义 InvocationHandler 并重写invoke方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>
<li>通过 Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 方法创建代理对象；</li>
</ul>
<ol start="3">
<li><strong>栗子</strong></li>
</ol>
<p>还是发送短信的例子，定义接口和实现如上静态代理。</p>
<p>定义JDK动态代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020年05月11日 11:23:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取代理对象的工厂类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), <span class="comment">// 目标类的类加载器</span></span><br><span class="line">                target.getClass().getInterfaces(),  <span class="comment">// 代理需要实现的接口，可指定多个</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DebugInvocationHandler</span>(target)   <span class="comment">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> (SmsService) JdkProxyFactory.getProxy(<span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>());</span><br><span class="line">smsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="CGLIB动态代理">CGLIB动态代理</h4>
<ol>
<li><strong>介绍</strong></li>
</ol>
<p>JDK 动态代理有一个最致命的问题是其<strong>只能代理实现了接口的类</strong>。</p>
<p>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。CGLIBopen in new window(Code Generation Library)是一个基于ASMopen in new window的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了CGLIBopen in new window， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>
<p><strong>在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心。</strong></p>
<p>你需要自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodInterceptor</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">Callback</span>&#123;</span><br><span class="line">    <span class="comment">// 拦截被代理类中的方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>obj : 被代理的对象（需要增强的对象）</li>
<li>method : 被拦截的方法（需要增强的方法）</li>
<li>args : 方法入参proxy : 用于调用原始方法</li>
</ul>
<p>你可以通过 Enhancer类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 MethodInterceptor 中的 intercept 方法。</p>
<ol start="2">
<li><strong>使用步骤</strong></li>
</ol>
<ul>
<li>定义一个类；</li>
<li>自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似；</li>
<li>通过 Enhancer 类的 create()创建代理类；</li>
</ul>
<ol start="3">
<li><strong>栗子</strong></li>
</ol>
<p>a. 引入依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">3.3</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>b. 实现一个使用阿里云发送短信的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.javaguide.dynamicProxy.cglibDynamicProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliSmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c. 自定义方法拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义MethodInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o           被代理的对象（需要增强的对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args        方法入参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 用于调用原始方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>d. 获取代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建动态代理增强类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 设置类加载器</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">DebugMethodInterceptor</span>());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>e. 使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AliSmsService</span> <span class="variable">aliSmsService</span> <span class="operator">=</span> (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);</span><br><span class="line">aliSmsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="小结">小结</h3>
<ol>
<li>JDK &amp; CGLIB</li>
</ol>
<ul>
<li>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li>
<li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li>
</ul>
<ol start="2">
<li>静态 &amp; 动态</li>
</ol>
<ul>
<li>灵活性：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li>
<li>JVM 层面：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java值传递</title>
    <url>/post/419426b4.html</url>
    <content><![CDATA[<h2 id="Java值传递">Java值传递</h2>
<h3 id="形参-实参">形参&amp;实参</h3>
<ul>
<li>形参：用来定义<strong>方法</strong>，接收实参。无需确定值。</li>
<li>实参：用于传递给方法，需要有确定的值。</li>
</ul>
<h3 id="值传递-引用传递">值传递&amp;引用传递</h3>
<ul>
<li>值传递：方法接收的是<strong>实参值的拷贝</strong>，会创建副本。</li>
<li>引用传递：方法接收的直接是实参所引用的<strong>对象在堆中的地址</strong>，不会创建副本，对形参的修改将影响到实参。</li>
</ul>
<h3 id="Java值传递-2">Java值传递</h3>
<h4 id="传递基本类型">传递基本类型</h4>
<p>一个方法不能修改一个基本数据类型的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    swap(num1, num2);</span><br><span class="line">    System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">    System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">num1 = <span class="number">10</span></span><br><span class="line">num2 = <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>num1 num2 是实参。a b 是形参，从输出可以看到，a b 值交换并不影响 num1 num2，因为交换的只是创建的副本。</p>
<h4 id="传递引用类型参数">传递引用类型参数</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">      System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">      change(arr);</span><br><span class="line">      System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">      <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">      array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><code>change</code>方法中的形参<code>array</code><strong>拷贝</strong>的是实参<code>arr</code>对象在<strong>堆中的地址</strong>，因此，两个参数实际指向的是同一个对象！所以在方法内部对形参的修改会影响到实参。</p>
<h4 id="引用类型传递2">引用类型传递2</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">xiaoZhang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">xiaoLi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">    swap(xiaoZhang, xiaoLi);</span><br><span class="line">    System.out.println(<span class="string">&quot;xiaoZhang:&quot;</span> + xiaoZhang.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;xiaoLi:&quot;</span> + xiaoLi.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Person person1, Person person2)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">temp</span> <span class="operator">=</span> person1;</span><br><span class="line">    person1 = person2;</span><br><span class="line">    person2 = temp;</span><br><span class="line">    System.out.println(<span class="string">&quot;person1:&quot;</span> + person1.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;person2:&quot;</span> + person2.getName());</span><br><span class="line">&#125;</span><br><span class="line">person1:小李</span><br><span class="line">person2:小张</span><br><span class="line">xiaoZhang:小张</span><br><span class="line">xiaoLi:小李</span><br></pre></td></tr></table></figure>
<p>swap 方法的参数 person1 和 person2 只是拷贝的实参 xiaoZhang 和 xiaoLi 的地址。因此， person1 和 person2 的互换只是<strong>拷贝的两个地址的互换</strong>罢了，并不会影响到实参 xiaoZhang 和 xiaoLi 。</p>
<h4 id="小结">小结</h4>
<p>Java 中将实参传递给方法（或函数）的方式是 值传递：</p>
<ul>
<li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li>
<li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本</li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>VueCoreLanguage</title>
    <url>/post/2eb6dd78.html</url>
    <content><![CDATA[<h2 id="1-介绍-入门">1. 介绍&amp;入门</h2>
<h3 id="是什么">是什么</h3>
<p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
<h2 id="2-核心语法">2. 核心语法</h2>
<h3 id="栗子">栗子</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=, chrome&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;VueLearning Time&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;!-- 1.2 插值表达式 --&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; title &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;!-- &lt;p&gt;&#123;&#123; content &#125;&#125;&lt;/p&gt; --&gt;</span><br><span class="line">    &lt;!-- &lt;p&gt;&#123;&#123; 1+2+3&#125;&#125;&lt;/p&gt; --&gt;</span><br><span class="line">    &lt;!-- &lt;p&gt;&#123;&#123; 1 &gt; 2 ? &#x27;对&#x27; : &#x27;错&#x27;&#125;&#125;&lt;/p&gt; --&gt;</span><br><span class="line">    &lt;!-- 可以看到 method 方法（output()）执行了三次，computed 计算属性（outputContent）执行了一次 --&gt;</span><br><span class="line">    &lt;!-- &lt;p&gt;&#123;&#123; output() &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; output() &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; output() &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; outputContent &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; outputContent &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; outputContent &#125;&#125;&lt;/p&gt;  --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 4.指令：内容指令，渲染指令，属性指令 --&gt;</span><br><span class="line">    &lt;!-- 内容指令 --&gt;</span><br><span class="line">    &lt;!-- &lt;p v-text=&quot;htmlContent&quot;&gt;123&lt;/p&gt; --&gt;</span><br><span class="line">    &lt;!-- &lt;p v-html=&quot;htmlContent&quot;&gt;123&lt;/p&gt; --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 渲染指令 --&gt;</span><br><span class="line">    &lt;!-- &lt;p v-for=&quot;item in 5&quot;&gt;这是内容&lt;/p&gt; --&gt;</span><br><span class="line">    &lt;!-- &lt;p v-for=&quot;(item, key, index) in obj&quot;&gt;这是内容：&#123;&#123; item &#125;&#125;&#123;&#123; key &#125;&#125;&#123;&#123; index &#125;&#125;&lt;/p&gt;  在循环中会产生索引&gt; --&gt;</span><br><span class="line">    &lt;!-- &lt;p v-for=&quot;(item, key, index) in arr&quot;&gt;这是内容：&#123;&#123; item &#125;&#125;&lt;/p&gt; --&gt;</span><br><span class="line">    &lt;!-- &lt;p v-if=&quot;bool&quot;&gt;标签内容&lt;/p&gt; --&gt;</span><br><span class="line">    &lt;!-- &lt;p v-show=&quot;bool&quot;&gt;标签内容&lt;/p&gt; --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 属性指令 --&gt;</span><br><span class="line">    &lt;!-- &lt;p v-bind:title=&quot;title&quot;&gt;这是内容&lt;/p&gt; --&gt;</span><br><span class="line">    &lt;!-- &lt;p :title=&quot;title&quot;&gt;这是内容&lt;/p&gt; --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 事件指令 --&gt;</span><br><span class="line">    &lt;!-- &lt;button v-on:click=&quot;output&quot;&gt;点击&lt;/button&gt; --&gt;</span><br><span class="line">    &lt;!-- &lt;button @click=&quot;output&quot;&gt;点击&lt;/button&gt; --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 表单指令 : v-model 可以实现双向数据绑定--&gt;</span><br><span class="line">    &lt;input v-model=&quot;inputValue&quot; type=&quot;text&quot;&gt;</span><br><span class="line">    &lt;p v-text=&quot;inputValue&quot;&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 5.修饰符 --&gt;</span><br><span class="line">    &lt;input v-model.trim=&quot;inputValue&quot; type=&quot;text&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script src=&quot;./vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    const app = new Vue(&#123;</span><br><span class="line">      // 1.响应式数据与插值表达式</span><br><span class="line">      el: &#x27;#app&#x27;, // 挂载点</span><br><span class="line">      data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          title: &#x27;这是标题文本&#x27;,</span><br><span class="line">          content: &#x27;这是内容文本&#x27;,</span><br><span class="line">          htmlContent: &#x27;这是一个&lt;span&gt;span&lt;/span&gt;标签&#x27;,</span><br><span class="line">          arr: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;],</span><br><span class="line">          obj: &#123;a:10, b:20, c:30, d:40&#125;,</span><br><span class="line">          bool: true,</span><br><span class="line">          inputValue: &#x27;默认输入内容&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      // 1.3 methods 属性</span><br><span class="line">      methods: &#123;</span><br><span class="line">        output () &#123;</span><br><span class="line">          console.log(&#x27;method方法执行了&#x27;)</span><br><span class="line">          return &#x27;标题为：&#x27; + this.title + &#x27;；&#x27; + &#x27;内容为：&#x27; + this.content</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      // 2.计算属性：具有缓存性，只有当依赖的数据发生改变时，才会重新执行</span><br><span class="line">      computed: &#123;</span><br><span class="line">        outputContent () &#123;</span><br><span class="line">          console.log(&#x27;computed方法执行了&#x27;)</span><br><span class="line">          return &#x27;标题为：&#x27; + this.title + &#x27;；&#x27; + &#x27;内容为：&#x27; + this.content</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      // 3.侦听器：当依赖的数据发生改变时，执行回调函数</span><br><span class="line">      watch: &#123;</span><br><span class="line">        title (newVal, oldVal) &#123;</span><br><span class="line">          console.log(newVal, oldVal)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="响应式数据与插值表达式">响应式数据与插值表达式</h3>
<h4 id="响应式数据">响应式数据</h4>
<p>当一个 Vue 实例被创建时，它将 data 对象中的所有的 property 加入到 Vue 的<strong>响应式系统</strong>中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p>
<p>数据改变时，视图才会进行重新渲染，注意，当实例创建时就已经存在于<code>data</code>中的 property 才是<strong>响应式</strong>的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 新建实例: vm ViewModel</span><br><span class="line">var vm = new Vue (&#123;</span><br><span class="line">  el: &#x27;#example&#x27;,</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。</p>
<p>比如 <a href="https://v2.cn.vuejs.org/v2/api/#created">created</a> 钩子可以用来在一个实例被创建之后执行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: 1</span><br><span class="line">  &#125;,</span><br><span class="line">  created: function () &#123;</span><br><span class="line">    // `this` 指向 vm 实例</span><br><span class="line">    console.log(&#x27;a is: &#x27; + this.a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// =&gt; &quot;a is: 1&quot;</span><br></pre></td></tr></table></figure>
<p>也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 <a href="https://v2.cn.vuejs.org/v2/api/#mounted">mounted</a>、<a href="https://v2.cn.vuejs.org/v2/api/#updated">updated</a> 和 <a href="https://v2.cn.vuejs.org/v2/api/#destroyed">destroyed</a>。生命周期钩子的 this 上下文指向调用它的 Vue 实例。</p>
<p>实例的生命周期：</p>
<p><img src="/post/2eb6dd78/lifecycle.png" alt="lifecycle"></p>
<h4 id="插值表达式："><strong>插值表达式：</strong></h4>
<p><strong>文本</strong>：</p>
<p>“Mustache”语法（双大括号）的文本插值：<code>&lt;span&gt;Message:&#123;&#123; msg &#125;&#125;&lt;/span&gt;</code>。Mustache 标签将会被替代为对应数据对象上 msg property 的值。无论何时，绑定的数据对象上 msg property 发生了改变，插值处的内容都会更新。可以使用<code>v-once</code>指令执行一次性插值。</p>
<p><strong>HTML</strong>：</p>
<p>双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，需要使用 <a href="https://v2.cn.vuejs.org/v2/api/#v-html">v-html指令</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Using mustaches: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>这个 span 的内容将会被替换成为 property 值 rawHtml，直接作为 HTML——会忽略解析 property 值中的数据绑定。注意，你不能使用 v-html 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。反之，对于用户界面 (UI)，组件更适合作为可重用和可组合的基本单位。</p>
<p><strong>Attribute</strong>：</p>
<p>Mustache 语法不能作用在 HTML attribute 上，遇到这种情况应该使用 <a href="https://v2.cn.vuejs.org/v2/api/#v-bind">v-bind指令</a>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;dynamicId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于布尔 attribute ，v-bind ：</p>
<p>如果 isButtonDisabled 的值是 null、undefined 或 false，则 disabled attribute 甚至不会被包含在渲染出来的 <button> 元素中。</button></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-bind:disabled</span>=<span class="string">&quot;isButtonDisabled&quot;</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>JavaScript表达式</strong>：</p>
<p>表达式会在所属实例的数据作用域下面作为JavaScript被解析。（每个绑定只能包含单个表达式。）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;&#123; number + <span class="number">1</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; ok ? <span class="string">&#x27;YES&#x27;</span> : <span class="string">&#x27;NO&#x27;</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; message.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>) &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;div v-<span class="attr">bind</span>:id=<span class="string">&quot;&#x27;list-&#x27; + id&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 这是语句，不是表达式 --&gt;</span><br><span class="line">&#123;&#123; <span class="keyword">var</span> a = <span class="number">1</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span><br><span class="line">&#123;&#123; <span class="keyword">if</span> (ok) &#123; <span class="keyword">return</span> message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="栗子-2">栗子</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=, chrome&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;VueLearning Time&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;!-- 1.2 插值表达式 --&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; title &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;!-- &lt;p&gt;&#123;&#123; content &#125;&#125;&lt;/p&gt; --&gt;</span><br><span class="line">    &lt;!-- &lt;p&gt;&#123;&#123; 1+2+3&#125;&#125;&lt;/p&gt; --&gt;</span><br><span class="line">    &lt;!-- &lt;p&gt;&#123;&#123; 1 &gt; 2 ? &#x27;对&#x27; : &#x27;错&#x27;&#125;&#125;&lt;/p&gt; --&gt;</span><br><span class="line">    &lt;!-- 可以看到 method 方法（output()）执行了三次，computed 计算属性（outputContent）执行了一次 --&gt;</span><br><span class="line">    &lt;!-- &lt;p&gt;&#123;&#123; output() &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; output() &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; output() &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; outputContent &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; outputContent &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; outputContent &#125;&#125;&lt;/p&gt;  --&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script src=&quot;./vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    const app = new Vue(&#123;</span><br><span class="line">      // 1.响应式数据与插值表达式</span><br><span class="line">      el: &#x27;#app&#x27;, // 挂载点</span><br><span class="line">      data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          title: &#x27;这是标题文本&#x27;,</span><br><span class="line">          content: &#x27;这是内容文本&#x27;,</span><br><span class="line">          htmlContent: &#x27;这是一个&lt;span&gt;span&lt;/span&gt;标签&#x27;,</span><br><span class="line">          arr: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;],</span><br><span class="line">          obj: &#123;a:10, b:20, c:30, d:40&#125;,</span><br><span class="line">          bool: true,</span><br><span class="line">          inputValue: &#x27;默认输入内容&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="计算属性">计算属性</h3>
<p>对复杂逻辑的处理，放在计算属性中。</p>
<p>栗子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: &quot;&#123;&#123; message &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &#x27;#example&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#x27;Hello&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 计算属性的 getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      // `this` 指向 vm 实例</span><br><span class="line">      return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们可以将同一函数定义为一个方法而非计算属性，两者结果一致，但是<strong>计算属性是基于它们的响应式依赖进行缓存</strong>的，只有在相关响应式依赖发生改变时才会重新求值。</p>
<p>计算属性的<code>setter</code>：(默认只有 getter 可自定义 setter)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ...</span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    // getter</span><br><span class="line">    get: function () &#123;</span><br><span class="line">      return this.firstName + &#x27; &#x27; + this.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    // setter</span><br><span class="line">    set: function (newValue) &#123;</span><br><span class="line">      var names = newValue.split(&#x27; &#x27;)</span><br><span class="line">      this.firstName = names[0]</span><br><span class="line">      this.lastName = names[names.length - 1]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>
<h3 id="侦听器">侦听器</h3>
<p>当依赖的数据发生改变时，执行回调函数。</p>
<p>使用场景：需要在数据变化时执行异步或开销较大的操作时，十分优越。</p>
<p>栗子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">                                     </span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &#x27;#demo&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &#x27;Foo&#x27;,</span><br><span class="line">    lastName: &#x27;Bar&#x27;,</span><br><span class="line">    fullName: &#x27;Foo Bar&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    firstName: function (val) &#123;</span><br><span class="line">      this.fullName = val + &#x27; &#x27; + this.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    lastName: function (val) &#123;</span><br><span class="line">      this.fullName = this.firstName + &#x27; &#x27; + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>栗子2：使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;watch-example&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Ask a yes/no question:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;question&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; answer &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> watchExampleVM = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">el</span>: <span class="string">&#x27;#watch-example&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">question</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">answer</span>: <span class="string">&#x27;I cannot give you an answer until you ask a question!&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">watch</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">question</span>: <span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">&#x27;Waiting for you to stop typing...&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="title function_">debouncedGetAnswer</span>()</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 请参考：https://lodash.com/docs#debounce</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">debouncedGetAnswer</span> = _.<span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">getAnswer</span>, <span class="number">500</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">getAnswer</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">question</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;?&#x27;</span>) === -<span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">&#x27;Questions usually contain a question mark. ;-)&#x27;</span></span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">&#x27;Thinking...&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> vm = <span class="variable language_">this</span></span></span><br><span class="line"><span class="language-javascript">        axios.<span class="title function_">get</span>(<span class="string">&#x27;https://yesno.wtf/api&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">          .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            vm.<span class="property">answer</span> = _.<span class="title function_">capitalize</span>(response.<span class="property">data</span>.<span class="property">answer</span>)</span></span><br><span class="line"><span class="language-javascript">          &#125;)</span></span><br><span class="line"><span class="language-javascript">          .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            vm.<span class="property">answer</span> = <span class="string">&#x27;Error! Could not reach the API. &#x27;</span> + error</span></span><br><span class="line"><span class="language-javascript">          &#125;)</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="指令">指令</h3>
<p>指令 (Directives) 是带有 v- 前缀的特殊 attribute。指令 attribute 的值预期是<strong>单个 JavaScript 表达式</strong> (v-for 例外)。当表达式的值改变时，指令将其产生的连带影响，响应式地作用于 DOM。</p>
<p>如下，<code>v-if</code>根据表达式<code>seen</code>值的真假来插入or移除<code>&lt;p&gt;</code>元素：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;seen&quot;</span>&gt;</span>现在你看到我了<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>指令分类and栗子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 4.指令：内容指令，渲染指令，属性指令 --&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 内容指令 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">&quot;htmlContent&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-html</span>=<span class="string">&quot;htmlContent&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 渲染指令 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;item in 5&quot;</span>&gt;</span>这是内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, key, index) in obj&quot;</span>&gt;</span>这是内容：&#123;&#123; item &#125;&#125;&#123;&#123; key &#125;&#125;&#123;&#123; index &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  在循环中会产生索引&gt;</span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, key, index) in arr&quot;</span>&gt;</span>这是内容：&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;bool&quot;</span>&gt;</span>标签内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">&quot;bool&quot;</span>&gt;</span>标签内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 属性指令 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-bind:title</span>=<span class="string">&quot;title&quot;</span>&gt;</span>这是内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span> <span class="attr">:title</span>=<span class="string">&quot;title&quot;</span>&gt;</span>这是内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 事件指令 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;output&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;output&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 表单指令 : v-model 可以实现双向数据绑定--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;inputValue&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">&quot;inputValue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="修饰符">修饰符</h3>
<p>修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p><strong>缩写</strong>：</p>
<p>Vue 为 v-bind 和 v-on 这两个最常用的指令，提供了特定简写：</p>
<p>v-bind：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">key</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>v-on：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">event</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-组件">3. 组件</h2>
<p>所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象 (一些根实例特有的选项除外)。</p>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>MYDB记录</title>
    <url>/post/7e29e8fb.html</url>
    <content><![CDATA[<h2 id="1-clone-本地运行">1. clone&amp;本地运行</h2>
<h3 id="1-1-环境">1.1. 环境</h3>
<ul>
<li>jdk：17.07</li>
<li>maven：3.9.2</li>
<li>os：windows 11</li>
</ul>
<h3 id="1-2-运行前设置">1.2. 运行前设置</h3>
<ul>
<li>手动创建数据库文件夹 tmp/mydb。（在项目目录下。）</li>
</ul>
<h3 id="1-3-问题">1.3. 问题</h3>
<ol>
<li>java.lang.ClassNotFoundException: “top.guoziyang.mydb.backend.Launcher”</li>
</ol>
<p>解决：IDEA中设置运行时参数。<a href="https://github.com/CN-GuoZiyang/MYDB/issues/3">参考</a></p>
<p><img src="/post/7e29e8fb/IDEA%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE.png" alt="IDEA参数设置"></p>
<h3 id="1-4-效果">1.4 效果</h3>
<p><img src="/post/7e29e8fb/MYDB%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C.png" alt="MYDB运行效果"></p>
<h2 id="2-文档先行：整体架构">2. 文档先行：整体架构</h2>
<h3 id="整体架构">整体架构</h3>
<h4 id="前端（客户端）">前端（客户端）</h4>
<p>读取用户输入，发送到后端执行，输出返回结果。等待下一次输入。</p>
<h4 id="SQL解析器（后面补充）">SQL解析器（后面补充）</h4>
<p>解析SQL，包装成对应的对象。</p>
<h4 id="后端">后端</h4>
<p>解析SQL，若合法，尝试执行并返回结果。</p>
<p>模块划分：各个模块通过接口向其依赖的模块提供方法</p>
<ol>
<li>Transaction Manager（TM）</li>
<li>Data Manager（DM）</li>
<li>Version Manager（VM）</li>
<li>Index Manager（IM）</li>
<li>Table Manager（TBM）</li>
</ol>
<p>五个模块的依赖图如下，拓补排序得出实现顺序为：TM -&gt; DM -&gt; VM -&gt; IM -&gt; TBM</p>
<p><img src="/post/7e29e8fb/%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96%E5%9B%BE.png" alt="模块依赖图"></p>
<p>各个模块的职责：</p>
<ol>
<li>TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。</li>
<li>DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：1) 分页管理 DB 文件，并进行缓存；2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。</li>
<li>VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。</li>
<li>IM 实现了基于 B+ 树的索引，目前 where 只支持已索引字段。</li>
<li>TBM 实现了对字段和表的管理。同时，解析 SQL 语句，并根据语句操作表。</li>
</ol>
<h2 id="3-Transaction-Manager（TM）">3. Transaction Manager（TM）</h2>
<p>TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。</p>
<h3 id="XID-文件">XID  文件</h3>
<p>XID 文件规则：</p>
<p>每个事物都有一个 xid，这个 ID 是一个事务的<strong>唯一标识</strong>。事务的 xid 从 <strong>1</strong> 开始编号，自增，不可重复。规定 xid 为 0 的事务是超级事务（super transaction），想在没有申请事务的情况下进行一些操作时，可将操作的 xid 设置为 0，超级事务的状态一直是 committed。</p>
<p>MYDB 中事务的状态：</p>
<ol>
<li>active，进行中</li>
<li>committed，已提交</li>
<li>aborted，已撤销（回滚）</li>
</ol>
<p>XID 文件内容的结构：</p>
<ol>
<li>给每个事务分配<strong>一个字节</strong>的空间来保存其<strong>状态</strong>。</li>
<li>XID 文件头部保存一个 <strong>8 字节数字</strong>，记录此 XID 文件管理<strong>事务的个数</strong>。</li>
<li>事务 xid 在文件中的状态存储位置在 <strong>(xid-1)+8 字节处</strong>。（xid-1 是因为 xid 为 0 的状态不需要记录。）</li>
</ol>
<h3 id="TransactionManager">TransactionManager</h3>
<p>提供的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">begin</span><span class="params">()</span>;                       <span class="comment">// 开启一个新事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span>;              <span class="comment">// 提交一个事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">long</span> xid)</span>;               <span class="comment">// 取消一个事务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">(<span class="type">long</span> xid)</span>;         <span class="comment">// 查询一个事务的状态是否是正在进行的状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCommitted</span><span class="params">(<span class="type">long</span> xid)</span>;      <span class="comment">// 查询一个事务的状态是否是已提交</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAborted</span><span class="params">(<span class="type">long</span> xid)</span>;        <span class="comment">// 查询一个事务的状态是否是已取消</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;                       <span class="comment">// 关闭TM</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据定义的 XID 文件结构，得到需要定义的一些常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XID文件头长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LEN_XID_HEADER_LENGTH</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 每个事务的占用长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">XID_FIELD_SIZE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 事务的三种状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_ACTIVE</span>   <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_COMMITTED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_ABORTED</span>  <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 超级事务，永远为commited状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SUPER_XID</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// XID 文件后缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">XID_SUFFIX</span> <span class="operator">=</span> <span class="string">&quot;.xid&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>在构造函数创建了一个 TransactionManager 之后，首先要对 XID 文件进行校验，以保证这是一个合法的 XID 文件。校验的方式是通过文件头的 8 字节数字反推文件的理论长度，与文件的实际长度做对比。如果不同则认为 XID 文件不合法。当校验不通过时，调用自定义方法强制停机。</p>
<p><code>begin()</code>方法：开启一个事务——</p>
<ul>
<li>首先设置 xidCounter+1 事务的状态为 committed，</li>
<li>然后 xidCounter 自增</li>
<li>同时，事务数量增加了一个，别忘记更新文件头。</li>
</ul>
<p><strong>注意点</strong>：所有文件操作在执行后都需要立刻刷入文件中，防止崩溃后文件丢失数据。</p>
<p>从查询事务状态的方法中抽象出一种公共的方法，使得实现事务状态查询时只需根据条件调用此方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测XID事务是否处于status状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkXID</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span> status)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> getXidPosition(xid);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="keyword">new</span> <span class="title class_">byte</span>[XID_FIELD_SIZE]);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.position(offset);</span><br><span class="line">        fc.read(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf.array()[<span class="number">0</span>] == status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在接口 TransactionManager 中，使用<strong>单例模式</strong> 创建 TM，其有两种方式，分别是：先新建 XID 文件再创建 TM实例（create 方法），或者从一个已有的 XID 文件中创建 TM 实例（open 方法）。要注意的是，从零创建 XID 文件时需要写一个<strong>空的 XID 文件头</strong>，即设置 xidCounter 为 0，否则后续在校验时会不合法</p>
<h2 id="4-Data-Manager（DM）">4. Data Manager（DM）</h2>
<p>DataManager（DM）功能归纳：</p>
<ul>
<li>上层模块和文件系统中的一个抽象层。向上，提供数据包装；向下，直接读写文件。</li>
<li>提供日志功能。</li>
</ul>
<h3 id="1、引用计数缓存框架">1、引用计数缓存框架</h3>
<p>分页管理和数据项（DataItem）管理涉及缓存，故抽象出一个通用缓存框架。</p>
<h4 id="引用计数法">引用计数法</h4>
<p>引用计数法（Reference counting）是一种内存管理技术，它通过计算每个对象被引用的次数来判断是否需要回收该对象。当对象被创建时，引用计数为1，每当有一个新的引用指向该对象时，计数加1，当引用失效时，计数减1。当计数为0时，该对象就可以被回收。</p>
<p>在MYDB的实践中，需要的效果是，只有上层模块主动释放引用，缓存在确保没有模块在使用这个资源了，才会去驱逐资源。</p>
<p>于是，选择引用计数法。增加了一个方法 release(key)，用于在上册模块不使用某个资源时，释放对资源的引用。当引用归零时，缓存就会驱逐这个资源。</p>
<p>同样，在缓存满了之后，引用计数法无法自动释放缓存，此时应该直接报错（和 JVM 似的，直接 OOM）。</p>
<h4 id="LRU">LRU</h4>
<p>LRU（least recently used）是一种缓存淘汰算法。它的特点是根据数据最近被访问的时间来决定哪些数据应该被保留，哪些数据应该被淘汰。当缓存达到一定容量时，会淘汰掉最近最少使用的数据。</p>
<p>如果使用 LRU 缓存，那么只需要设计一个 get(key) 接口即可，释放缓存可以在缓存满了之后自动完成。</p>
<p>however，当某时刻缓存满了，缓存驱逐一个资源，此时上层模块想将某个资源强制刷回3数据源，这个资源恰恰是刚被驱逐的资源。此时的上层模块会发现，资源在缓存中消失了，那么，是否有必要做回源操作？</p>
<ul>
<li>不回源。由于没法确定缓存被驱逐的时间，更没法确定被驱逐之后数据项是否被修改，这样是极其不安全的</li>
<li>回源。如果数据项被驱逐时的数据和现在又是相同的，那就是一次无效回源</li>
<li>放回缓存里，等下次被驱逐时回源。看起来解决了问题，但是此时缓存已经满了，这意味着你还需要驱逐一个资源才能放进去。这有可能会导致缓存抖动问题。</li>
</ul>
<h4 id="实现">实现</h4>
<p><code>AbstractCache</code>类作为抽象缓存类，定义两个方法交由子类实现。</p>
<p>实现引用计数，需要维护一个资源引用个数的HashMap，为了多线程访问，需要维护一个记录资源访问情况的HashMap。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当资源不在缓存时的获取行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当资源被驱逐时的写回行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(T obj)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Long, T&gt; cache;                     <span class="comment">// 实际缓存的数据</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Long, Integer&gt; references;          <span class="comment">// 资源的引用个数</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Long, Boolean&gt; getting;             <span class="comment">// 正在被获取的资源</span></span><br></pre></td></tr></table></figure>
<p>获取资源的<code>get()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> T <span class="title function_">get</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.在通过 get() 方法获取资源时，首先进入一个死循环，来无限尝试从缓存里获取。</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">// 1.1.首先就需要检查这个时候是否有其他线程正在从数据源获取这个资源，如果有，就过会再来看看</span></span><br><span class="line">            <span class="keyword">if</span>(getting.containsKey(key)) &#123;</span><br><span class="line">                <span class="comment">// 请求的资源正在被其他线程获取</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.2.如果没有其他线程在获取这个资源，那么就可以尝试从缓存中获取了</span></span><br><span class="line">            <span class="keyword">if</span>(cache.containsKey(key)) &#123;</span><br><span class="line">                <span class="comment">// 资源在缓存中，直接返回</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">                <span class="comment">// 记得给资源的引用计数加一</span></span><br><span class="line">                references.put(key, references.get(key) + <span class="number">1</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.3.尝试获取该资源</span></span><br><span class="line">            <span class="comment">// a.判断缓存是否已满，如果已满，就抛出一个异常</span></span><br><span class="line">            <span class="keyword">if</span>(maxResource &gt; <span class="number">0</span> &amp;&amp; count == maxResource) &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                <span class="keyword">throw</span> Error.CacheFullException;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// b.如果缓存未满，就在 getting 中注册一下，该线程准备从数据源获取资源了</span></span><br><span class="line">            count ++;</span><br><span class="line">            getting.put(key, <span class="literal">true</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从数据源获取资源</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = getForCache(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 如果获取失败，就把 getting 中的注册信息清除掉</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            count --;</span><br><span class="line">            getting.remove(key);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        getting.remove(key);       <span class="comment">// 获取完成要从 getting 中清除注册信息</span></span><br><span class="line">        cache.put(key, obj);</span><br><span class="line">        references.put(key, <span class="number">1</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>释放资源的<code>release</code>方法：当引用计数references 逐渐 -1 减到 0 后，就可以回源并删除缓存中相关的结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.释放资源</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(<span class="type">long</span> key)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 释放一个缓存时，直接从 references 中减 1，如果已经减到 0 了，就可以回源，并且删除缓存中所有相关的结构</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ref</span> <span class="operator">=</span> references.get(key) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(ref == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">                <span class="comment">// 调用抽象方法释放缓存</span></span><br><span class="line">                releaseForCache(obj);</span><br><span class="line">                <span class="comment">// 删除缓存中所有相关的结构</span></span><br><span class="line">                references.remove(key);</span><br><span class="line">                cache.remove(key);</span><br><span class="line">                count --;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                references.put(key, ref);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、共享内存数组">2、共享内存数组</h3>
<p>在Java中，<strong>数组</strong>被视为一个<strong>对象</strong>，其在内存中也是以对象的形式存储的。在 Java 中，当执行类似 subArray 的操作时，只会在底层进行一个复制，<strong>无法同一片内存</strong>。所以，要实现共享内存数组，定义一个<code>SubArray</code>类，规定这个数组的可使用范围：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] raw;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubArray</span><span class="params">(<span class="type">byte</span>[] raw, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.raw = raw;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、数据页的缓存与管理">3、数据页的缓存与管理</h3>
<h4 id="页面缓存">页面缓存</h4>
<p>默认数据页大小定为 8K，首先，需要定义出页面的结构。注意这个页面是存储在内存中的，与已经持久化到磁盘的抽象页面有区别。</p>
<p>定义一个页面如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageImpl</span> <span class="keyword">implements</span> <span class="title class_">Page</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pageNumber;  <span class="comment">// 页号，从1开始</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data;  <span class="comment">// 此页面实际包含的字节数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> dirty;  <span class="comment">// 标识是否是脏页面。缓存驱逐时，脏页面需要被写回磁盘</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 保存了一个 PageCache 的引用，方便在拿到 Page 的引用时可以快速对这个页面的缓存进行释放操作。</span></span><br><span class="line">    <span class="keyword">private</span> PageCache pc;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>页面缓存接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PageCache</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">newPage</span><span class="params">(<span class="type">byte</span>[] initData)</span>;</span><br><span class="line">    Page <span class="title function_">getPage</span><span class="params">(<span class="type">int</span> pgno)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(Page page)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">truncateByBgno</span><span class="params">(<span class="type">int</span> maxPgno)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getPageNumber</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">flushPage</span><span class="params">(Page pg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>页面缓存的具体实现类，需要继承抽象缓存框架，并且实现 <code>getForCache() </code>和 <code>releaseForCache() </code>两个抽象方法。由于数据源就是文件系统，<code>getForCache() </code>直接从文件中读取，并包裹成 Page 即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Page <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> (<span class="type">int</span>)key;</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> PageCacheImpl.pageOffset(pgno);</span><br><span class="line"></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(PAGE_SIZE);</span><br><span class="line">    fileLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.position(offset);</span><br><span class="line">        fc.read(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    fileLock.unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageImpl</span>(pgno, buf.array(), <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">pageOffset</span><span class="params">(<span class="type">int</span> pgno)</span> &#123;</span><br><span class="line">    <span class="comment">// 页号从 1 开始</span></span><br><span class="line">    <span class="keyword">return</span> (pgno-<span class="number">1</span>) * PAGE_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 releaseForCache() 驱逐页面时，也只需要根据页面是否是脏页面，来决定是否需要写回文件系统：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(pg.isDirty()) &#123;</span><br><span class="line">        flush(pg);</span><br><span class="line">        pg.setDirty(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> pg.getPageNumber();</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> pageOffset(pgno);</span><br><span class="line"></span><br><span class="line">    fileLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(pg.getData());</span><br><span class="line">        fc.position(offset);</span><br><span class="line">        fc.write(buf);</span><br><span class="line">        fc.force(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fileLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PageCache 还使用了一个 AtomicInteger，来记录了当前打开的数据库文件有多少页。这个数字在数据库文件被打开时就会被计算，并在新建页面时自增。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">newPage</span><span class="params">(<span class="type">byte</span>[] initData)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> pageNumbers.incrementAndGet();</span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageImpl</span>(pgno, initData, <span class="literal">null</span>);</span><br><span class="line">    flush(pg);  <span class="comment">// 新建的页面需要立刻写回</span></span><br><span class="line">    <span class="keyword">return</span> pgno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据页管理">数据页管理</h4>
<p><strong>第一页</strong>：</p>
<p>数据库文件的第一页，通常用作一些特殊用途，比如存储一些元数据，用来启动检查什么的。MYDB 的第一页，只是用来做启动检查。具体的原理是，在每次数据库启动时，会生成一串随机字节，存储在 100 ~ 107 字节。在数据库正常关闭时，会将这串字节，拷贝到第一页的 108 ~ 115 字节。</p>
<p>这样数据库在每次启动时，就会检查第一页两处的字节是否相同，以此来判断上一次是否正常关闭。如果是异常关闭，就需要执行数据的恢复流程。</p>
<p>启动时设置初始字节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcOpen</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    setVcOpen(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcOpen</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    System.arraycopy(RandomUtil.randomBytes(LEN_VC), <span class="number">0</span>, raw, OF_VC, LEN_VC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭时拷贝字节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcClose</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    setVcClose(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcClose</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    System.arraycopy(raw, OF_VC, raw, OF_VC+LEN_VC, LEN_VC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>校验字节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkVc</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> checkVc(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkVc</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.equals(Arrays.copyOfRange(raw, OF_VC, OF_VC+LEN_VC), Arrays.copyOfRange(raw, OF_VC+LEN_VC, OF_VC+<span class="number">2</span>*LEN_VC));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>普通页</strong>：</p>
<p>一个普通页面以一个 2 字节无符号数起始，表示这一页的空闲位置的偏移。剩下的部分都是实际存储的数据。</p>
<p>所以对普通页的管理，基本都是围绕着对 FSO（Free Space Offset）进行的。</p>
<p>例如向页面插入数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将raw插入pg中，返回插入位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">insert</span><span class="params">(Page pg, <span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">short</span> <span class="variable">offset</span> <span class="operator">=</span> getFSO(pg.getData());</span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length);</span><br><span class="line">    setFSO(pg.getData(), (<span class="type">short</span>)(offset + raw.length));</span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在写入之前获取 FSO，来确定写入的位置，并在写入之后更新 FSO。FSO 的操作如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFSO</span><span class="params">(<span class="type">byte</span>[] raw, <span class="type">short</span> ofData)</span> &#123;</span><br><span class="line">    System.arraycopy(Parser.short2Byte(ofData), <span class="number">0</span>, raw, OF_FREE, OF_DATA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取pg的FSO</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">getFSO</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getFSO(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">getFSO</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Parser.parseShort(Arrays.copyOfRange(raw, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取页面的空闲空间大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getFreeSpace</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PageCache.PAGE_SIZE - (<span class="type">int</span>)getFSO(pg.getData());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩余两个函数 recoverInsert() 和 recoverUpdate() 用于在数据库崩溃后重新打开时，恢复例程直接插入数据以及修改数据使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将raw插入pg中的offset位置，并将pg的offset设置为较大的offset</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recoverInsert</span><span class="params">(Page pg, <span class="type">byte</span>[] raw, <span class="type">short</span> offset)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length);</span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> <span class="variable">rawFSO</span> <span class="operator">=</span> getFSO(pg.getData());</span><br><span class="line">    <span class="keyword">if</span>(rawFSO &lt; offset + raw.length) &#123;</span><br><span class="line">        setFSO(pg.getData(), (<span class="type">short</span>)(offset+raw.length));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将raw插入pg中的offset位置，不更新update</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recoverUpdate</span><span class="params">(Page pg, <span class="type">byte</span>[] raw, <span class="type">short</span> offset)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-Version-Manager（VM）">5. Version Manager（VM）</h2>
<blockquote>
<p>VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。</p>
</blockquote>
<p>类似于 Data Manager 是 MYDB 的数据管理核心，Version Manager 是 MYDB 的事务和数据版本的管理核心。</p>
<h3 id="2PL与MVCC">2PL与MVCC</h3>
<h4 id="冲突与-2PL">冲突与 2PL</h4>
<p>首先来定义数据库的冲突，暂时不考虑插入操作，只看更新操作（U）和读操作（R），两个操作只要满足下面三个条件，就可以说这两个操作相互冲突：</p>
<ul>
<li>这两个操作是由不同的事务执行的</li>
<li>这两个操作操作的是同一个数据项</li>
<li>这两个操作至少有一个是更新操作</li>
</ul>
<p>那么这样，对同一个数据操作的冲突，其实就只有下面这两种情况：</p>
<ul>
<li>两个不同事务的 U 操作冲突</li>
<li>两个不同事务的 U、R 操作冲突</li>
</ul>
<p>那么冲突或者不冲突，意义何在？作用在于，<strong>交换两个互不冲突的操作的顺序，不会对最终的结果造成影响</strong>，而交换两个冲突操作的顺序，则是会有影响的。</p>
<p>现在我们先抛开冲突不谈，记得在第四章举的例子吗，在并发情况下，两个事务同时操作 x。假设 x 的初值是 0：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T1 begin</span><br><span class="line">T2 begin</span><br><span class="line">R1(x) // T1读到0</span><br><span class="line">R2(x) // T2读到0</span><br><span class="line">U1(0+1) // T1尝试把x+1</span><br><span class="line">U2(0+1) // T2尝试把x+1</span><br><span class="line">T1 commit</span><br><span class="line">T2 commit</span><br></pre></td></tr></table></figure>
<p>最后 x 的结果是 1，这个结果显然与期望的不符。</p>
<p>VM 的一个很重要的职责，就是实现了调度序列的可串行化。MYDB 采用两段锁协议（2PL）来实现。当采用 2PL 时，如果某个事务 i 已经对 x 加锁，且另一个事务 j 也想操作 x，但是这个操作与事务 i 之前的操作相互冲突的话，事务 j 就会被阻塞。譬如，T1 已经因为 U1(x) 锁定了 x，那么 T2 对 x 的读或者写操作都会被阻塞，T2 必须等待 T1 释放掉对 x 的锁。</p>
<p>由此来看，2PL 确实保证了调度序列的可串行话，但是不可避免地导致了事务间的相互阻塞，甚至可能导致死锁。MYDB 为了提高事务处理的效率，降低阻塞概率，实现了 MVCC。</p>
<h4 id="MVCC">MVCC</h4>
<p>在介绍 MVCC 之前，首先明确记录和版本的概念。</p>
<p>DM 层向上层提供了数据项（Data Item）的概念，VM 通过管理所有的数据项，向上层提供了记录（Entry）的概念。上层模块通过 VM 操作数据的最小单位，就是记录。VM 则在其内部，为每个记录，维护了多个版本（Version）。每当上层模块对某个记录进行修改时，VM 就会为这个记录创建一个新的版本。</p>
<p>MYDB 通过 MVCC，降低了事务的阻塞概率。譬如，T1 想要更新记录 X 的值，于是 T1 需要首先获取 X 的锁，接着更新，也就是创建了一个新的 X 的版本，假设为 x3。假设 T1 还没有释放 X 的锁时，T2 想要读取 X 的值，这时候就不会阻塞，MYDB 会返回一个较老版本的 X，例如 x2。这样最后执行的结果，就等价于，T2 先执行，T1 后执行，调度序列依然是可串行化的。如果 X 没有一个更老的版本，那只能等待 T1 释放锁了。所以只是降低了概率。</p>
<p>还记得我们在第四章中，为了保证数据的可恢复，VM 层传递到 DM 的操作序列需要满足以下两个规则：</p>
<p>规定 1：正在进行的事务，不会读取其他任何未提交的事务产生的数据。</p>
<p>规定 2：正在进行的事务，不会修改其他任何未提交的事务修改或产生的数据。</p>
<p>由于 2PL 和 MVCC，我们可以看到，这两个条件都被很轻易地满足了。</p>
<h3 id="记录的实现">记录的实现</h3>
<p>对于一条记录来说，MYDB 使用 Entry 类维护了其结构。虽然理论上，MVCC 实现了多版本，但是在实现中，VM 并没有提供 Update 操作，对于字段的更新操作由后面的表和字段管理（TBM）实现。所以在 VM 的实现中，一条记录只有一个版本。</p>
<p>一条记录存储在一条 Data Item 中，所以 Entry 中保存一个 DataItem 的引用即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_XMIN</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_XMAX</span> <span class="operator">=</span> OF_XMIN+<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_DATA</span> <span class="operator">=</span> OF_XMAX+<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> uid;</span><br><span class="line">    <span class="keyword">private</span> DataItem dataItem;</span><br><span class="line">    <span class="keyword">private</span> VersionManager vm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Entry <span class="title function_">loadEntry</span><span class="params">(VersionManager vm, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DataItem</span> <span class="variable">di</span> <span class="operator">=</span> ((VersionManagerImpl)vm).dm.read(uid);</span><br><span class="line">        <span class="keyword">return</span> newEntry(vm, di, uid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        dataItem.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们规定，一条 Entry 中存储的数据格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[XMIN] [XMAX] [DATA]</span><br></pre></td></tr></table></figure>
<p>XMIN 是创建该条记录（版本）的事务编号，而 XMAX 则是删除该条记录（版本）的事务编号。它们的作用将在下一节中说明。DATA 就是这条记录持有的数据。根据这个结构，在创建记录时调用的 wrapEntryRaw() 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] wrapEntryRaw(<span class="type">long</span> xid, <span class="type">byte</span>[] data) &#123;</span><br><span class="line">    <span class="type">byte</span>[] xmin = Parser.long2Byte(xid);</span><br><span class="line">    <span class="type">byte</span>[] xmax = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">return</span> Bytes.concat(xmin, xmax, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，如果要获取记录中持有的数据，也就需要按照这个结构来解析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以拷贝的形式返回内容</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] data() &#123;</span><br><span class="line">    dataItem.rLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SubArray</span> <span class="variable">sa</span> <span class="operator">=</span> dataItem.data();</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[sa.end - sa.start - OF_DATA];</span><br><span class="line">        System.arraycopy(sa.raw, sa.start+OF_DATA, data, <span class="number">0</span>, data.length);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        dataItem.rUnLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里以拷贝的形式返回数据，如果需要修改的话，需要对 DataItem 执行 before() 方法，这个在设置 XMAX 的值中体现了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setXmax</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    dataItem.before();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SubArray</span> <span class="variable">sa</span> <span class="operator">=</span> dataItem.data();</span><br><span class="line">        System.arraycopy(Parser.long2Byte(xid), <span class="number">0</span>, sa.raw, sa.start+OF_XMAX, <span class="number">8</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        dataItem.after(xid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>before() 和 after() 是在 DataItem 一节中就已经确定的数据项修改规则。</p>
<h3 id="事务的隔离级别">事务的隔离级别</h3>
<h4 id="读提交">读提交</h4>
<p>上面提到，如果一个记录的最新版本被加锁，当另一个事务想要修改或读取这条记录时，MYDB 就会返回一个较旧的版本的数据。这时就可以认为，最新的被加锁的版本，对于另一个事务来说，是不可见的。于是版本可见性的概念就诞生了。</p>
<p>版本的可见性与事务的隔离度是相关的。MYDB 支持的最低的事务隔离程度，是“读提交”（Read Committed），即事务在读取数据时, 只能读取已经提交事务产生的数据。保证最低的读提交的好处，第四章中已经说明（防止级联回滚与 commit 语义冲突）。</p>
<p>MYDB 实现读提交，为每个版本维护了两个变量，就是上面提到的 XMIN 和 XMAX：</p>
<ul>
<li>XMIN：创建该版本的事务编号</li>
<li>XMAX：删除该版本的事务编号</li>
</ul>
<p>XMIN 应当在版本创建时填写，而 XMAX 则在版本被删除，或者有新版本出现时填写。</p>
<p>XMAX 这个变量，也就解释了为什么 DM 层不提供删除操作，当想删除一个版本时，只需要设置其 XMAX，这样，这个版本对每一个 XMAX 之后的事务都是不可见的，也就等价于删除了。</p>
<p>如此，在读提交下，版本对事务的可见性逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(XMIN == Ti and                             // 由Ti创建且</span><br><span class="line">XMAX == NULL                            // 还未被删除</span><br><span class="line">)</span><br><span class="line">or                                          // 或</span><br><span class="line">(XMIN is commited and                       // 由一个已提交的事务创建且</span><br><span class="line">(XMAX == NULL or                        // 尚未删除或</span><br><span class="line">(XMAX != Ti and XMAX is not commited)   // 由一个未提交的事务删除</span><br><span class="line">))</span><br></pre></td></tr></table></figure>
<p>若条件为 true，则版本对 Ti 可见。那么获取 Ti 适合的版本，只需要从最新版本开始，依次向前检查可见性，如果为 true，就可以直接返回。</p>
<p>以下方法判断某个记录对事务 t 是否可见：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">readCommitted</span><span class="params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> t.xid;</span><br><span class="line">    <span class="type">long</span> <span class="variable">xmin</span> <span class="operator">=</span> e.getXmin();</span><br><span class="line">    <span class="type">long</span> <span class="variable">xmax</span> <span class="operator">=</span> e.getXmax();</span><br><span class="line">    <span class="keyword">if</span>(xmin == xid &amp;&amp; xmax == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tm.isCommitted(xmin)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(xmax == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(xmax != xid) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!tm.isCommitted(xmax)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 Transaction 结构只提供了一个 XID。</p>
<h4 id="可重复读">可重复读</h4>
<p>读提交会导致的问题大家也都很清楚，八股也背了不少。那就是不可重复读和幻读。这里我们来解决不可重复读的问题。</p>
<p>不可重复度，会导致一个事务在执行期间对同一个数据项的读取得到不同结果。如下面的结果，加入 X 初始值为 0：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T1 begin</span><br><span class="line">R1(X) // T1 读得 0</span><br><span class="line">T2 begin</span><br><span class="line">U2(X) // 将 X 修改为 1</span><br><span class="line">T2 commit</span><br><span class="line">R1(X) // T1 读的 1</span><br></pre></td></tr></table></figure>
<p>可以看到，T1 两次读 X，读到的结果不一样。如果想要避免这个情况，就需要引入更严格的隔离级别，即可重复读（repeatable read）。</p>
<p>T1 在第二次读取的时候，读到了已经提交的 T2 修改的值，导致了这个问题。于是我们可以规定：</p>
<p>事务只能读取它开始时, 就已经结束的那些事务产生的数据版本</p>
<p>这条规定，增加于，事务需要忽略：</p>
<p>在本事务后开始的事务的数据;</p>
<p>本事务开始时还是 active 状态的事务的数据</p>
<p>对于第一条，只需要比较事务 ID，即可确定。而对于第二条，则需要在事务 Ti 开始时，记录下当前活跃的所有事务 SP(Ti)，如果记录的某个版本，XMIN 在 SP(Ti) 中，也应当对 Ti 不可见。</p>
<p>于是，可重复读的判断逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(XMIN == Ti and                 <span class="comment">// 由Ti创建且</span></span><br><span class="line"> (XMAX == NULL or               <span class="comment">// 尚未被删除</span></span><br><span class="line">))</span><br><span class="line">or                              <span class="comment">// 或</span></span><br><span class="line">(XMIN is commited and           <span class="comment">// 由一个已提交的事务创建且</span></span><br><span class="line"> XMIN &lt; XID and                 <span class="comment">// 这个事务小于Ti且</span></span><br><span class="line"> XMIN is not in <span class="title function_">SP</span><span class="params">(Ti)</span> and      <span class="comment">// 这个事务在Ti开始前提交且</span></span><br><span class="line"> (XMAX == NULL or               <span class="comment">// 尚未被删除或</span></span><br><span class="line">  (XMAX != Ti and               <span class="comment">// 由其他事务删除但是</span></span><br><span class="line">   (XMAX is not commited or     <span class="comment">// 这个事务尚未提交或</span></span><br><span class="line">XMAX &gt; Ti or                    <span class="comment">// 这个事务在Ti开始之后才开始或</span></span><br><span class="line">XMAX is in <span class="title function_">SP</span><span class="params">(Ti)</span>               <span class="comment">// 这个事务在Ti开始前还未提交</span></span><br><span class="line">))))</span><br></pre></td></tr></table></figure>
<p>于是，需要提供一个结构，来抽象一个事务，以保存快照数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> xid;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> level;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;Long, Boolean&gt; snapshot;</span><br><span class="line">    <span class="keyword">public</span> Exception err;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> autoAborted;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Transaction <span class="title function_">newTransaction</span><span class="params">(<span class="type">long</span> xid, <span class="type">int</span> level, Map&lt;Long, Transaction&gt; active)</span> &#123;</span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transaction</span>();</span><br><span class="line">        t.xid = xid;</span><br><span class="line">        t.level = level;</span><br><span class="line">        <span class="keyword">if</span>(level != <span class="number">0</span>) &#123;</span><br><span class="line">            t.snapshot = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(Long x : active.keySet()) &#123;</span><br><span class="line">                t.snapshot.put(x, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInSnapshot</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(xid == TransactionManagerImpl.SUPER_XID) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> snapshot.containsKey(xid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方法中的 active，保存着当前所有 active 的事务。于是，可重复读的隔离级别下，一个版本是否对事务可见的判断如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">repeatableRead</span><span class="params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> t.xid;</span><br><span class="line">    <span class="type">long</span> <span class="variable">xmin</span> <span class="operator">=</span> e.getXmin();</span><br><span class="line">    <span class="type">long</span> <span class="variable">xmax</span> <span class="operator">=</span> e.getXmax();</span><br><span class="line">    <span class="keyword">if</span>(xmin == xid &amp;&amp; xmax == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tm.isCommitted(xmin) &amp;&amp; xmin &lt; xid &amp;&amp; !t.isInSnapshot(xmin)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(xmax == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(xmax != xid) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!tm.isCommitted(xmax)  xmax &gt; xid  t.isInSnapshot(xmax)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="死锁检测">死锁检测</h3>
<h4 id="版本跳跃问题">版本跳跃问题</h4>
<p>说到版本跳跃之前，顺便提一嘴，MVCC 的实现，使得 MYDB 在撤销或是回滚事务很简单：只需要将这个事务标记为 aborted 即可。根据前一章提到的可见性，每个事务都只能看到其他 committed 的事务所产生的数据，一个 aborted 事务产生的数据，就不会对其他事务产生任何影响了，也就相当于，这个事务不曾存在过。</p>
<p>版本跳跃问题，考虑如下的情况，假设 X 最初只有 x0 版本，T1 和 T2 都是可重复读的隔离级别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T1 begin</span><br><span class="line">T2 begin</span><br><span class="line"><span class="title function_">R1</span><span class="params">(X)</span> <span class="comment">// T1读取x0</span></span><br><span class="line">R2(X) <span class="comment">// T2读取x0</span></span><br><span class="line">U1(X) <span class="comment">// T1将X更新到x1</span></span><br><span class="line">T1 commit</span><br><span class="line"><span class="title function_">U2</span><span class="params">(X)</span> <span class="comment">// T2将X更新到x2</span></span><br><span class="line">T2 commit</span><br></pre></td></tr></table></figure>
<p>这种情况实际运行起来是没问题的，但是逻辑上不太正确。T1 将 X 从 x0 更新为了 x1，这是没错的。但是 T2 则是将 X 从 x0 更新成了 x2，跳过了 x1 版本。</p>
<p>读提交是允许版本跳跃的，而可重复读则是不允许版本跳跃的。解决版本跳跃的思路也很简单：如果 Ti 需要修改 X，而 X 已经被 Ti 不可见的事务 Tj 修改了，那么要求 Ti 回滚。</p>
<p>上一节中就总结了，Ti 不可见的 Tj，有两种情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XID(Tj) &gt; XID(Ti)</span><br><span class="line">Tj in <span class="title function_">SP</span><span class="params">(Ti)</span></span><br></pre></td></tr></table></figure>
<p>于是版本跳跃的检查也就很简单了，取出要修改的数据 X 的最新提交版本，并检查该最新版本的创建者对当前事务是否可见：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isVersionSkip</span><span class="params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">xmax</span> <span class="operator">=</span> e.getXmax();</span><br><span class="line">    <span class="keyword">if</span>(t.level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tm.isCommitted(xmax) &amp;&amp; (xmax &gt; t.xid  t.isInSnapshot(xmax));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="死锁检测-2">死锁检测</h4>
<p>上一节提到了 2PL 会阻塞事务，直至持有锁的线程释放锁。可以将这种等待关系抽象成有向边，例如 Tj 在等待 Ti，就可以表示为 Tj --&gt; Ti。这样，无数有向边就可以形成一个图（不一定是连通图）。检测死锁也就简单了，只需要查看这个图中是否有环即可。</p>
<p>MYDB 使用一个 LockTable 对象，在内存中维护这张图。维护结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; x2u;  <span class="comment">// 某个XID已经获得的资源的UID列表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Long&gt; u2x;        <span class="comment">// UID被某个XID持有</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; wait; <span class="comment">// 正在等待UID的XID列表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Lock&gt; waitLock;   <span class="comment">// 正在等待资源的XID的锁</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Long&gt; waitU;      <span class="comment">// XID正在等待的UID</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在每次出现等待的情况时，就尝试向图中增加一条边，并进行死锁检测。如果检测到死锁，就撤销这条边，不允许添加，并撤销该事务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不需要等待则返回null，否则返回锁对象</span></span><br><span class="line"><span class="comment">// 会造成死锁则抛出异常</span></span><br><span class="line"><span class="keyword">public</span> Lock <span class="title function_">add</span><span class="params">(<span class="type">long</span> xid, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isInList(x2u, xid, uid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!u2x.containsKey(uid)) &#123;</span><br><span class="line">            u2x.put(uid, xid);</span><br><span class="line">            putIntoList(x2u, xid, uid);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        waitU.put(xid, uid);</span><br><span class="line">        putIntoList(wait, xid, uid);</span><br><span class="line">        <span class="keyword">if</span>(hasDeadLock()) &#123;</span><br><span class="line">            waitU.remove(xid);</span><br><span class="line">            removeFromList(wait, uid, xid);</span><br><span class="line">            <span class="keyword">throw</span> Error.DeadlockException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        l.lock();</span><br><span class="line">        waitLock.put(xid, l);</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 add，如果需要等待的话，会返回一个上了锁的 Lock 对象。调用方在获取到该对象时，需要尝试获取该对象的锁，由此实现阻塞线程的目的，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">l</span> <span class="operator">=</span> lt.add(xid, uid);</span><br><span class="line"><span class="keyword">if</span>(l != <span class="literal">null</span>) &#123;</span><br><span class="line">    l.lock();   <span class="comment">// 阻塞在这一步</span></span><br><span class="line">    l.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找图中是否有环的算法也非常简单，就是一个深搜，只是需要注意这个图不一定是连通图。思路就是为每个节点设置一个访问戳，都初始化为 -1，随后遍历所有节点，以每个非 -1 的节点作为根进行深搜，并将深搜该连通图中遇到的所有节点都设置为同一个数字，不同的连通图数字不同。这样，如果在遍历某个图时，遇到了之前遍历过的节点，说明出现了环。</p>
<p>实现很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasDeadLock</span><span class="params">()</span> &#123;</span><br><span class="line">    xidStamp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    stamp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> xid : x2u.keySet()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">s</span> <span class="operator">=</span> xidStamp.get(xid);</span><br><span class="line">        <span class="keyword">if</span>(s != <span class="literal">null</span> &amp;&amp; s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stamp ++;</span><br><span class="line">        <span class="keyword">if</span>(dfs(xid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">stp</span> <span class="operator">=</span> xidStamp.get(xid);</span><br><span class="line">    <span class="keyword">if</span>(stp != <span class="literal">null</span> &amp;&amp; stp == stamp) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stp != <span class="literal">null</span> &amp;&amp; stp &lt; stamp) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    xidStamp.put(xid, stamp);</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">uid</span> <span class="operator">=</span> waitU.get(xid);</span><br><span class="line">    <span class="keyword">if</span>(uid == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">x</span> <span class="operator">=</span> u2x.get(uid);</span><br><span class="line">    <span class="keyword">assert</span> x != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个事务 commit 或者 abort 时，就可以释放所有它持有的锁，并将自身从等待图中删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;Long&gt; l = x2u.get(xid);</span><br><span class="line">        <span class="keyword">if</span>(l != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(l.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">Long</span> <span class="variable">uid</span> <span class="operator">=</span> l.remove(<span class="number">0</span>);</span><br><span class="line">                selectNewXID(uid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        waitU.remove(xid);</span><br><span class="line">        x2u.remove(xid);</span><br><span class="line">        waitLock.remove(xid);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>while 循环释放掉了这个线程所有持有的资源的锁，这些资源可以被等待的线程所获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从等待队列中选择一个xid来占用uid</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">selectNewXID</span><span class="params">(<span class="type">long</span> uid)</span> &#123;</span><br><span class="line">    u2x.remove(uid);</span><br><span class="line">    List&lt;Long&gt; l = wait.get(uid);</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">assert</span> l.size() &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> l.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!waitLock.containsKey(xid)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            u2x.put(uid, xid);</span><br><span class="line">            <span class="type">Lock</span> <span class="variable">lo</span> <span class="operator">=</span> waitLock.remove(xid);</span><br><span class="line">            waitU.remove(xid);</span><br><span class="line">            lo.unlock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l.size() == <span class="number">0</span>) wait.remove(uid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 List 开头开始尝试解锁，还是个公平锁。解锁时，将该 Lock 对象 unlock 即可，这样业务线程就获取到了锁，就可以继续执行了。</p>
<h3 id="VM实现">VM实现</h3>
<p>VM 层通过 VersionManager 接口，向上层提供功能，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VersionManager</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] read(<span class="type">long</span> xid, <span class="type">long</span> uid) <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">insert</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="type">long</span> xid, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="title function_">begin</span><span class="params">(<span class="type">int</span> level)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">long</span> xid)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，VM 的实现类还被设计为 Entry 的缓存，需要继承 AbstractCache<Entry>。需要实现的获取到缓存和从缓存释放的方法很简单：</Entry></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Entry <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> Entry.loadEntry(<span class="built_in">this</span>, uid);</span><br><span class="line">    <span class="keyword">if</span>(entry == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Error.NullEntryException;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(Entry entry)</span> &#123;</span><br><span class="line">    entry.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>begin() 开启一个事务，并初始化事务的结构，将其存放在 activeTransaction 中，用于检查和快照使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">begin</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> tm.begin();</span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> Transaction.newTransaction(xid, level, activeTransaction);</span><br><span class="line">        activeTransaction.put(xid, t);</span><br><span class="line">        <span class="keyword">return</span> xid;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>commit() 方法提交一个事务，主要就是 free 掉相关的结构，并且释放持有的锁，并修改 TM 状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);</span><br><span class="line">    lock.unlock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(t.err != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> t.err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(NullPointerException n) &#123;</span><br><span class="line">        System.out.println(xid);</span><br><span class="line">        System.out.println(activeTransaction.keySet());</span><br><span class="line">        Panic.panic(n);</span><br><span class="line">    &#125;</span><br><span class="line">    lock.lock();</span><br><span class="line">    activeTransaction.remove(xid);</span><br><span class="line">    lock.unlock();</span><br><span class="line">    lt.remove(xid);</span><br><span class="line">    tm.commit(xid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>abort 事务的方法则有两种，手动和自动。手动指的是调用 abort() 方法，而自动，则是在事务被检测出出现死锁时，会自动撤销回滚事务；或者出现版本跳跃时，也会自动回滚：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">internAbort</span><span class="params">(<span class="type">long</span> xid, <span class="type">boolean</span> autoAborted)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);</span><br><span class="line">    <span class="keyword">if</span>(!autoAborted) &#123;</span><br><span class="line">        activeTransaction.remove(xid);</span><br><span class="line">    &#125;</span><br><span class="line">    lock.unlock();</span><br><span class="line">    <span class="keyword">if</span>(t.autoAborted) <span class="keyword">return</span>;</span><br><span class="line">    lt.remove(xid);</span><br><span class="line">    tm.abort(xid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>read() 方法读取一个 entry，注意判断下可见性即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] read(<span class="type">long</span> xid, <span class="type">long</span> uid) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);</span><br><span class="line">    lock.unlock();</span><br><span class="line">    <span class="keyword">if</span>(t.err != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> t.err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="built_in">super</span>.get(uid);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(Visibility.isVisible(tm, t, entry)) &#123;</span><br><span class="line">            <span class="keyword">return</span> entry.data();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        entry.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>insert() 则是将数据包裹成 Entry，无脑交给 DM 插入即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">insert</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);</span><br><span class="line">    lock.unlock();</span><br><span class="line">    <span class="keyword">if</span>(t.err != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> t.err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">byte</span>[] raw = Entry.wrapEntryRaw(xid, data);</span><br><span class="line">    <span class="keyword">return</span> dm.insert(xid, raw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>delete() 方法看起来略为复杂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="type">long</span> xid, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);</span><br><span class="line">    lock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t.err != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> t.err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="built_in">super</span>.get(uid);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!Visibility.isVisible(tm, t, entry)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">l</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            l = lt.add(xid, uid);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            t.err = Error.ConcurrentUpdateException;</span><br><span class="line">            internAbort(xid, <span class="literal">true</span>);</span><br><span class="line">            t.autoAborted = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> t.err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l != <span class="literal">null</span>) &#123;</span><br><span class="line">            l.lock();</span><br><span class="line">            l.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(entry.getXmax() == xid) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Visibility.isVersionSkip(tm, t, entry)) &#123;</span><br><span class="line">            t.err = Error.ConcurrentUpdateException;</span><br><span class="line">            internAbort(xid, <span class="literal">true</span>);</span><br><span class="line">            t.autoAborted = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> t.err;</span><br><span class="line">        &#125;</span><br><span class="line">        entry.setXmax(xid);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        entry.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上主要是前置的三件事：一是可见性判断，二是获取资源的锁，三是版本跳跃判断。删除的操作只有一个设置 XMAX。</p>
<h2 id="6-Index-Manager-（IM）">6. Index Manager （IM）</h2>
<p>IM，即 Index Manager，索引管理器，为 MYDB 提供了基于 B+ 树的聚簇索引。目前 MYDB 只支持基于索引查找数据，不支持全表扫描。感兴趣的同学可以自行实现。</p>
<p>在依赖关系图中可以看到，IM 直接基于 DM，而没有基于 VM。索引的数据被直接插入数据库文件中，而不需要经过版本管理。</p>
<p>本节不赘述 B+ 树算法，更多描述实现。</p>
<h3 id="二叉树索引">二叉树索引</h3>
<p>二叉树由一个个 Node 组成，每个 Node 都存储在一条 DataItem 中。结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[LeafFlag][KeyNumber][SiblingUid]</span><br><span class="line">[Son0][Key0][Son1][Key1]...[SonN][KeyN]</span><br></pre></td></tr></table></figure>
<p>其中 LeafFlag 标记了该节点是否是个叶子节点；KeyNumber 为该节点中 key 的个数；SiblingUid 是其兄弟节点存储在 DM 中的 UID。后续是穿插的子节点（SonN）和 KeyN。最后的一个 KeyN 始终为 MAX_VALUE，以此方便查找。</p>
<p>Node 类持有了其 B+ 树结构的引用，DataItem 的引用和 SubArray 的引用，用于方便快速修改数据和释放数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    BPlusTree tree;</span><br><span class="line">    DataItem dataItem;</span><br><span class="line">    SubArray raw;</span><br><span class="line">    <span class="type">long</span> uid;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是生成一个根节点的数据可以写成如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] newRootRaw(<span class="type">long</span> left, <span class="type">long</span> right, <span class="type">long</span> key)  &#123;</span><br><span class="line">    <span class="type">SubArray</span> <span class="variable">raw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubArray</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[NODE_SIZE], <span class="number">0</span>, NODE_SIZE);</span><br><span class="line">    setRawIsLeaf(raw, <span class="literal">false</span>);</span><br><span class="line">    setRawNoKeys(raw, <span class="number">2</span>);</span><br><span class="line">    setRawSibling(raw, <span class="number">0</span>);</span><br><span class="line">    setRawKthSon(raw, left, <span class="number">0</span>);</span><br><span class="line">    setRawKthKey(raw, key, <span class="number">0</span>);</span><br><span class="line">    setRawKthSon(raw, right, <span class="number">1</span>);</span><br><span class="line">    setRawKthKey(raw, Long.MAX_VALUE, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> raw.raw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该根节点的初始两个子节点为 left 和 right, 初始键值为 key。</p>
<p>类似的，生成一个空的根节点数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] newNilRootRaw()  &#123;</span><br><span class="line">    <span class="type">SubArray</span> <span class="variable">raw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubArray</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[NODE_SIZE], <span class="number">0</span>, NODE_SIZE);</span><br><span class="line">    setRawIsLeaf(raw, <span class="literal">true</span>);</span><br><span class="line">    setRawNoKeys(raw, <span class="number">0</span>);</span><br><span class="line">    setRawSibling(raw, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> raw.raw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Node 类有两个方法，用于辅助 B+ 树做插入和搜索操作，分别是 searchNext 方法和 leafSearchRange 方法。</p>
<p>searchNext 寻找对应 key 的 UID, 如果找不到, 则返回兄弟节点的 UID。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SearchNextRes <span class="title function_">searchNext</span><span class="params">(<span class="type">long</span> key)</span> &#123;</span><br><span class="line">    dataItem.rLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SearchNextRes</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchNextRes</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">noKeys</span> <span class="operator">=</span> getRawNoKeys(raw);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; noKeys; i ++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> getRawKthKey(raw, i);</span><br><span class="line">            <span class="keyword">if</span>(key &lt; ik) &#123;</span><br><span class="line">                res.uid = getRawKthSon(raw, i);</span><br><span class="line">                res.siblingUid = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.uid = <span class="number">0</span>;</span><br><span class="line">        res.siblingUid = getRawSibling(raw);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        dataItem.rUnLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>leafSearchRange 方法在当前节点进行范围查找，范围是 [leftKey, rightKey]，这里约定如果 rightKey 大于等于该节点的最大的 key, 则还同时返回兄弟节点的 UID，方便继续搜索下一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> LeafSearchRangeRes <span class="title function_">leafSearchRange</span><span class="params">(<span class="type">long</span> leftKey, <span class="type">long</span> rightKey)</span> &#123;</span><br><span class="line">    dataItem.rLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">noKeys</span> <span class="operator">=</span> getRawNoKeys(raw);</span><br><span class="line">        <span class="type">int</span> <span class="variable">kth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(kth &lt; noKeys) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> getRawKthKey(raw, kth);</span><br><span class="line">            <span class="keyword">if</span>(ik &gt;= leftKey) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            kth ++;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Long&gt; uids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(kth &lt; noKeys) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> getRawKthKey(raw, kth);</span><br><span class="line">            <span class="keyword">if</span>(ik &lt;= rightKey) &#123;</span><br><span class="line">                uids.add(getRawKthSon(raw, kth));</span><br><span class="line">                kth ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">siblingUid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(kth == noKeys) &#123;</span><br><span class="line">            siblingUid = getRawSibling(raw);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LeafSearchRangeRes</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeafSearchRangeRes</span>();</span><br><span class="line">        res.uids = uids;</span><br><span class="line">        res.siblingUid = siblingUid;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        dataItem.rUnLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 B+ 树在插入删除时，会动态调整，根节点不是固定节点，于是设置一个 bootDataItem，该 DataItem 中存储了根节点的 UID。可以注意到，IM 在操作 DM 时，使用的事务都是 SUPER_XID。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BPlusTree</span> &#123;</span><br><span class="line">    DataItem bootDataItem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">rootUid</span><span class="params">()</span> &#123;</span><br><span class="line">        bootLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SubArray</span> <span class="variable">sa</span> <span class="operator">=</span> bootDataItem.data();</span><br><span class="line">            <span class="keyword">return</span> Parser.parseLong(Arrays.copyOfRange(sa.raw, sa.start, sa.start+<span class="number">8</span>));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bootLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateRootUid</span><span class="params">(<span class="type">long</span> left, <span class="type">long</span> right, <span class="type">long</span> rightKey)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        bootLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] rootRaw = Node.newRootRaw(left, right, rightKey);</span><br><span class="line">            <span class="type">long</span> <span class="variable">newRootUid</span> <span class="operator">=</span> dm.insert(TransactionManagerImpl.SUPER_XID, rootRaw);</span><br><span class="line">            bootDataItem.before();</span><br><span class="line">            <span class="type">SubArray</span> <span class="variable">diRaw</span> <span class="operator">=</span> bootDataItem.data();</span><br><span class="line">            System.arraycopy(Parser.long2Byte(newRootUid), <span class="number">0</span>, diRaw.raw, diRaw.start, <span class="number">8</span>);</span><br><span class="line">            bootDataItem.after(TransactionManagerImpl.SUPER_XID);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bootLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IM 对上层模块主要提供两种能力：插入索引和搜索节点。向 B+ 树插入节点和搜索节点的算法和实现，不再赘述。</p>
<p>这里可能会有疑问，IM 为什么不提供删除索引的能力。当上层模块通过 VM 删除某个 Entry，实际的操作是设置其 XMAX。如果不去删除对应索引的话，当后续再次尝试读取该 Entry 时，是可以通过索引寻找到的，但是由于设置了 XMAX，寻找不到合适的版本而返回一个找不到内容的错误。</p>
<h3 id="可能的错误与恢复">可能的错误与恢复</h3>
<p>B+ 树在操作过程中，可能出现两种错误，分别是节点内部错误和节点间关系错误。</p>
<p>当节点内部错误发生时，即当 Ti 在对节点的数据进行更改时，MYDB 发生了崩溃。由于 IM 依赖于 DM，在数据库重启后，Ti 会被撤销（undo），对节点的错误影响会被消除。</p>
<p>如果出现了节点间错误，那么一定是下面这种情况：某次对 u 节点的插入操作创建了新节点 v, 此时 sibling(u)=v，但是 v 却并没有被插入到父节点中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[parent]</span><br><span class="line"></span><br><span class="line">    v</span><br><span class="line">   [u] -&gt; [v]</span><br></pre></td></tr></table></figure>
<p>正确的状态应当如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[ parent ]</span><br><span class="line"></span><br><span class="line"> v      v</span><br><span class="line">[u] -&gt; [v]</span><br></pre></td></tr></table></figure>
<p>这时，如果要对节点进行插入或者搜索操作，如果失败，就会继续迭代它的兄弟节点，最终还是可以找到 v 节点。唯一的缺点仅仅是，无法直接通过父节点找到 v 了，只能间接地通过 u 获取到 v。</p>
<h2 id="7-Table-Manager（TBM）">7. Table Manager（TBM）</h2>
<h3 id="字段与表管理">字段与表管理</h3>
<p>注意，这里的字段与表管理，不是管理各个条目中不同的字段的数值等信息，而是管理表和字段的结构数据，例如表名、表字段信息和字段索引等。</p>
<p>由于 TBM 基于 VM，单个字段信息和表信息都是直接保存在 Entry 中。字段的二进制表示如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[FieldName][TypeName][IndexUid]</span><br></pre></td></tr></table></figure>
<p>这里 FieldName 和 TypeName，以及后面的表明，存储的都是字节形式的字符串。这里规定一个字符串的存储方式，以明确其存储边界。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[StringLength][StringData]</span><br></pre></td></tr></table></figure>
<p>TypeName 为字段的类型，限定为 int32、int64 和 string 类型。如果这个字段有索引，那个 IndexUID 指向了索引二叉树的根，否则该字段为 0。</p>
<p>根据这个结构，通过一个 UID 从 VM 中读取并解析如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title function_">loadField</span><span class="params">(Table tb, <span class="type">long</span> uid)</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] raw = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        raw = ((TableManagerImpl)tb.tbm).vm.read(TransactionManagerImpl.SUPER_XID, uid);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span> raw != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Field</span>(uid, tb).parseSelf(raw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Field <span class="title function_">parseSelf</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">ParseStringRes</span> <span class="variable">res</span> <span class="operator">=</span> Parser.parseString(raw);</span><br><span class="line">    fieldName = res.str;</span><br><span class="line">    position += res.next;</span><br><span class="line">    res = Parser.parseString(Arrays.copyOfRange(raw, position, raw.length));</span><br><span class="line">    fieldType = res.str;</span><br><span class="line">    position += res.next;</span><br><span class="line">    <span class="built_in">this</span>.index = Parser.parseLong(Arrays.copyOfRange(raw, position, position+<span class="number">8</span>));</span><br><span class="line">    <span class="keyword">if</span>(index != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bt = BPlusTree.load(index, ((TableManagerImpl)tb.tbm).dm);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个字段的方法类似，将相关的信息通过 VM 持久化即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">persistSelf</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">byte</span>[] nameRaw = Parser.string2Byte(fieldName);</span><br><span class="line">    <span class="type">byte</span>[] typeRaw = Parser.string2Byte(fieldType);</span><br><span class="line">    <span class="type">byte</span>[] indexRaw = Parser.long2Byte(index);</span><br><span class="line">    <span class="built_in">this</span>.uid = ((TableManagerImpl)tb.tbm).vm.insert(xid, Bytes.concat(nameRaw, typeRaw, indexRaw));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个数据库中存在多张表，TBM 使用链表的形式将其组织起来，每一张表都保存一个指向下一张表的 UID。表的二进制结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[TableName][NextTable]</span><br><span class="line">[Field1Uid][Field2Uid]...[FieldNUid]</span><br></pre></td></tr></table></figure>
<p>这里由于每个 Entry 中的数据，字节数是确定的，于是无需保存字段的个数。根据 UID 从 Entry 中读取表数据的过程和读取字段的过程类似。</p>
<p>对表和字段的操作，有一个很重要的步骤，就是计算 Where 条件的范围，目前 MYDB 的 Where 只支持两个条件的与和或。例如有条件的 Delete，计算 Where，最终就需要获取到条件范围内所有的 UID。MYDB 只支持已索引字段作为 Where 的条件。计算 Where 的范围，具体可以查看 Table 的 parseWhere() 和 calWhere() 方法，以及 Field 类的 calExp() 方法。</p>
<p>由于 TBM 的表管理，使用的是链表串起的 Table 结构，所以就必须保存一个链表的头节点，即第一个表的 UID，这样在 MYDB 启动时，才能快速找到表信息。</p>
<p>MYDB 使用 Booter 类和 bt 文件，来管理 MYDB 的启动信息，虽然现在所需的启动信息，只有一个：头表的 UID。Booter 类对外提供了两个方法：load 和 update，并保证了其原子性。update 在修改 bt 文件内容时，没有直接对 bt 文件进行修改，而是首先将内容写入一个 bt_tmp 文件中，随后将这个文件重命名为 bt 文件。以期通过操作系统重命名文件的原子性，来保证操作的原子性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path + BOOTER_TMP_SUFFIX);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        tmp.createNewFile();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!tmp.canRead()  !tmp.canWrite()) &#123;</span><br><span class="line">        Panic.panic(Error.FileCannotRWException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(tmp)) &#123;</span><br><span class="line">        out.write(data);</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Files.move(tmp.toPath(), <span class="keyword">new</span> <span class="title class_">File</span>(path+BOOTER_SUFFIX).toPath(), StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    file = <span class="keyword">new</span> <span class="title class_">File</span>(path+BOOTER_SUFFIX);</span><br><span class="line">    <span class="keyword">if</span>(!file.canRead()  !file.canWrite()) &#123;</span><br><span class="line">        Panic.panic(Error.FileCannotRWException);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tab了Manager">Tab了Manager</h3>
<p>TBM 层对外提供服务的是 TableManager 接口，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">public interface TableManager &#123;</span><br><span class="line">    BeginRes <span class="keyword">begin</span>(<span class="keyword">Begin</span> <span class="keyword">begin</span>);</span><br><span class="line">    byte[] <span class="keyword">commit</span>(long xid) throws Exception;</span><br><span class="line">    byte[] abort(long xid);</span><br><span class="line"></span><br><span class="line">    byte[] <span class="keyword">show</span>(long xid);</span><br><span class="line">    byte[] <span class="keyword">create</span>(long xid, <span class="keyword">Create</span> <span class="keyword">create</span>) throws Exception;</span><br><span class="line"></span><br><span class="line">    byte[] <span class="keyword">insert</span>(long xid, <span class="keyword">Insert</span> <span class="keyword">insert</span>) throws Exception;</span><br><span class="line">    byte[] read(long xid, <span class="keyword">Select</span> <span class="keyword">select</span>) throws Exception;</span><br><span class="line">    byte[] <span class="keyword">update</span>(long xid, <span class="keyword">Update</span> <span class="keyword">update</span>) throws Exception;</span><br><span class="line">    byte[] <span class="keyword">delete</span>(long xid, <span class="keyword">Delete</span> <span class="keyword">delete</span>) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 TableManager 已经是直接被最外层 Server 调用（MYDB 是 C/S 结构），这些方法直接返回执行的结果，例如错误信息或者结果信息的字节数组（可读）。</p>
<p>各个方法的具体实现很简单，不再赘述，无非是调用 VM 的相关方法。唯一值得注意的一个小点是，在创建新表时，采用的时头插法，所以每次创建表都需要更新 Booter 文件。</p>
<h2 id="8-SQL词法解析器">8. SQL词法解析器</h2>
<p>Parser 实现了对类 SQL 语句的结构化解析，将语句中包含的信息封装为对应语句的类，这些类可见 top.philsongzi.mydb.backend.parser.statement 包。</p>
<p>MYDB 实现的 SQL 语句语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">begin</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">begin</span> [isolation level (read committedrepeatable read)]</span><br><span class="line">        <span class="keyword">begin</span> isolation level read committed</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">commit</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">commit</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span>abort statement<span class="operator">&gt;</span></span><br><span class="line">    abort</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">create</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span>field name<span class="operator">&gt;</span> <span class="operator">&lt;</span>field type<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span>field name<span class="operator">&gt;</span> <span class="operator">&lt;</span>field type<span class="operator">&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="operator">&lt;</span>field name<span class="operator">&gt;</span> <span class="operator">&lt;</span>field type<span class="operator">&gt;</span></span><br><span class="line">    [(index <span class="operator">&lt;</span>field name list<span class="operator">&gt;</span>)]</span><br><span class="line">        <span class="keyword">create</span> <span class="keyword">table</span> students</span><br><span class="line">        id int32,</span><br><span class="line">        name string,</span><br><span class="line">        age int32,</span><br><span class="line">        (index id name)</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">drop</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">table</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span></span><br><span class="line">        <span class="keyword">drop</span> <span class="keyword">table</span> students</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">select</span> (<span class="operator">*</span><span class="operator">&lt;</span>field name list<span class="operator">&gt;</span>) <span class="keyword">from</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span> [<span class="operator">&lt;</span><span class="keyword">where</span> statement<span class="operator">&gt;</span>]</span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">select</span> name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">and</span> id <span class="operator">&lt;</span> <span class="number">4</span></span><br><span class="line">        <span class="keyword">select</span> name, age, id <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">insert</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span> <span class="keyword">values</span> <span class="operator">&lt;</span><span class="keyword">value</span> list<span class="operator">&gt;</span></span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span> <span class="number">5</span> &quot;Zhang Yuanjia&quot; <span class="number">22</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">delete</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">from</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span> <span class="operator">&lt;</span><span class="keyword">where</span> statement<span class="operator">&gt;</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="operator">=</span> &quot;Zhang Yuanjia&quot;</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">update</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">update</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="operator">&lt;</span>field name<span class="operator">&gt;=</span><span class="operator">&lt;</span><span class="keyword">value</span><span class="operator">&gt;</span> [<span class="operator">&lt;</span><span class="keyword">where</span> statement<span class="operator">&gt;</span>]</span><br><span class="line">        <span class="keyword">update</span> student <span class="keyword">set</span> name <span class="operator">=</span> &quot;ZYJ&quot; <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">where</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">where</span> <span class="operator">&lt;</span>field name<span class="operator">&gt;</span> (<span class="operator">&gt;</span><span class="operator">&lt;=</span>) <span class="operator">&lt;</span><span class="keyword">value</span><span class="operator">&gt;</span> [(andor) <span class="operator">&lt;</span>field name<span class="operator">&gt;</span> (<span class="operator">&gt;</span><span class="operator">&lt;=</span>) <span class="operator">&lt;</span><span class="keyword">value</span><span class="operator">&gt;</span>]</span><br><span class="line">        <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">or</span> age <span class="operator">&lt;</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span>field name<span class="operator">&gt;</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span></span><br><span class="line">    [a<span class="operator">-</span>zA<span class="operator">-</span>Z][a<span class="operator">-</span>zA<span class="operator">-</span>Z0<span class="number">-9</span>_]<span class="operator">*</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span>field type<span class="operator">&gt;</span></span><br><span class="line">    int32 int64 string</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">value</span><span class="operator">&gt;</span></span><br><span class="line">    .<span class="operator">*</span></span><br></pre></td></tr></table></figure>
<p>parser 包的 Tokenizer 类，对语句进行逐字节解析，根据空白符或者上述词法规则，将语句切割成多个 token。对外提供了 peek()、pop() 方法方便取出 Token 进行解析。切割的实现不赘述。</p>
<p>Parser 类则直接对外提供了 Parse(byte[] statement) 方法，核心就是一个调用 Tokenizer 类分割 Token，并根据词法规则包装成具体的 Statement 类并返回。解析过程很简单，仅仅是根据第一个 Token 来区分语句类型，并分别处理，不再赘述。</p>
<p>虽然根据编译原理，词法分析应当写一个自动机去做的，但是又不是不能用。</p>
<h2 id="9-Server-和-Client">9. Server 和 Client</h2>
<h3 id="C-S-通信">C/S 通信</h3>
<p>MYDB 使用了一种特殊的二进制格式，用于客户端和服务端通信。当然如果嫌麻烦的话，其实直接用明文也不是不可以。</p>
<p>传输的最基本结构，是 Package：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Package</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] data;</span><br><span class="line">    Exception err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个 Package 在发送前，由 Encoder 编码为字节数组，在对方收到后同样会由 Encoder 解码成 Package 对象。编码和解码的规则如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Flag][data]</span><br></pre></td></tr></table></figure>
<p>若 flag 为 0，表示发送的是数据，那么 data 即为这份数据本身；如果 flag 为 1，表示发送的是错误，data 是 Exception.getMessage() 的错误提示信息。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Encoder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] encode(Package pkg) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pkg.getErr() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Exception</span> <span class="variable">err</span> <span class="operator">=</span> pkg.getErr();</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Intern server error!&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(err.getMessage() != <span class="literal">null</span>) &#123;</span><br><span class="line">                msg = err.getMessage();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Bytes.concat(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>&#125;, msg.getBytes());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Bytes.concat(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>&#125;, pkg.getData());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Package <span class="title function_">decode</span><span class="params">(<span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(data.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> Error.InvalidPkgDataException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(data[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Package</span>(Arrays.copyOfRange(data, <span class="number">1</span>, data.length), <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data[<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Package</span>(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="keyword">new</span> <span class="title class_">String</span>(Arrays.copyOfRange(data, <span class="number">1</span>, data.length))));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> Error.InvalidPkgDataException;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编码之后的信息会通过 Transporter 类，写入输出流发送出去。为了避免特殊字符造成问题，这里会将数据转成十六进制字符串（Hex String），并为信息末尾加上换行符。这样在发送和接收数据时，就可以很简单地使用 BufferedReader 和 Writer 来直接按行读写了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader reader;</span><br><span class="line">    <span class="keyword">private</span> BufferedWriter writer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Transporter</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">        <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        <span class="built_in">this</span>.writer = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(<span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">raw</span> <span class="operator">=</span> hexEncode(data);</span><br><span class="line">        writer.write(raw);</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] receive() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">        <span class="keyword">if</span>(line == <span class="literal">null</span>) &#123;</span><br><span class="line">            close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hexDecode(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        writer.close();</span><br><span class="line">        reader.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">hexEncode</span><span class="params">(<span class="type">byte</span>[] buf)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Hex.encodeHexString(buf, <span class="literal">true</span>)+<span class="string">&quot;n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] hexDecode(String buf) <span class="keyword">throws</span> DecoderException &#123;</span><br><span class="line">        <span class="keyword">return</span> Hex.decodeHex(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Packager 则是 Encoder 和 Transporter 的结合体，直接对外提供 send 和 receive 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Packager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Transporter transpoter;</span><br><span class="line">    <span class="keyword">private</span> Encoder encoder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Packager</span><span class="params">(Transporter transpoter, Encoder encoder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.transpoter = transpoter;</span><br><span class="line">        <span class="built_in">this</span>.encoder = encoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(Package pkg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = encoder.encode(pkg);</span><br><span class="line">        transpoter.send(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Package <span class="title function_">receive</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = transpoter.receive();</span><br><span class="line">        <span class="keyword">return</span> encoder.decode(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        transpoter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Server-和-Client-的实现">Server 和 Client 的实现</h3>
<p>Server 和 Client，偷懒直接使用了 Java 的 socket。</p>
<p>Server 启动一个 ServerSocket 监听端口，当有请求到来时直接把请求丢给一个新线程处理。这部分应该直接背板了。</p>
<p>HandleSocket 类实现了 Runnable 接口，在建立连接后初始化 Packager，随后就循环接收来自客户端的数据并处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Packager</span> <span class="variable">packager</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Transporter</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transporter</span>(socket);</span><br><span class="line">    <span class="type">Encoder</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Encoder</span>();</span><br><span class="line">    packager = <span class="keyword">new</span> <span class="title class_">Packager</span>(t, e);</span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">        e1.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Executor</span> <span class="variable">exe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Executor</span>(tbm);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">Package</span> <span class="variable">pkg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pkg = packager.receive();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">byte</span>[] sql = pkg.getData();</span><br><span class="line">    <span class="type">byte</span>[] result = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Exception</span> <span class="variable">e</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = exe.execute(sql);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">        e = e1;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    pkg = <span class="keyword">new</span> <span class="title class_">Package</span>(result, e);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        packager.send(pkg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">        e1.printStackTrace();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理的核心是 Executor 类，Executor 调用 Parser 获取到对应语句的结构化信息对象，并根据对象的类型，调用 TBM 的不同方法进行处理。具体不再赘述。</p>
<p>top.guoziyang.mydb.backend.Launcher 类，则是服务器的启动入口。这个类解析了命令行参数。很重要的参数就是 -open 或者 -create。Launcher 根据两个参数，来决定是创建数据库文件，还是启动一个已有的数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createDB</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="type">TransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> TransactionManager.create(path);</span><br><span class="line">    <span class="type">DataManager</span> <span class="variable">dm</span> <span class="operator">=</span> DataManager.create(path, DEFALUT_MEM, tm);</span><br><span class="line">    <span class="type">VersionManager</span> <span class="variable">vm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VersionManagerImpl</span>(tm, dm);</span><br><span class="line">    TableManager.create(path, vm, dm);</span><br><span class="line">    tm.close();</span><br><span class="line">    dm.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">openDB</span><span class="params">(String path, <span class="type">long</span> mem)</span> &#123;</span><br><span class="line">    <span class="type">TransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> TransactionManager.open(path);</span><br><span class="line">    <span class="type">DataManager</span> <span class="variable">dm</span> <span class="operator">=</span> DataManager.open(path, mem, tm);</span><br><span class="line">    <span class="type">VersionManager</span> <span class="variable">vm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VersionManagerImpl</span>(tm, dm);</span><br><span class="line">    <span class="type">TableManager</span> <span class="variable">tbm</span> <span class="operator">=</span> TableManager.open(path, vm, dm);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Server</span>(port, tbm).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端连接服务器的过程，也是背板。客户端有一个简单的 Shell，实际上只是读入用户的输入，并调用 Client.execute()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] execute(<span class="type">byte</span>[] stat) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Package</span> <span class="variable">pkg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Package</span>(stat, <span class="literal">null</span>);</span><br><span class="line">    <span class="type">Package</span> <span class="variable">resPkg</span> <span class="operator">=</span> rt.roundTrip(pkg);</span><br><span class="line">    <span class="keyword">if</span>(resPkg.getErr() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> resPkg.getErr();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resPkg.getData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RoundTripper 类实际上实现了单次收发动作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Package <span class="title function_">roundTrip</span><span class="params">(Package pkg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    packager.send(pkg);</span><br><span class="line">    <span class="keyword">return</span> packager.receive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后附上客户端的启动入口，很简单，把 Shell run 起来即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Launcher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">        <span class="type">Encoder</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Encoder</span>();</span><br><span class="line">        <span class="type">Transporter</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transporter</span>(socket);</span><br><span class="line">        <span class="type">Packager</span> <span class="variable">packager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Packager</span>(t, e);</span><br><span class="line"></span><br><span class="line">        <span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Client</span>(packager);</span><br><span class="line">        <span class="type">Shell</span> <span class="variable">shell</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shell</span>(client);</span><br><span class="line">        shell.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-总结（从实现功能出发，由点到面逐渐总结对应的MySQL）">10. 总结（从实现功能出发，由点到面逐渐总结对应的MySQL）</h2>
<h3 id="实现的功能">实现的功能</h3>
<h4 id="数据的可靠性和数据恢复">数据的可靠性和数据恢复</h4>
<h4 id="两段锁协议（2PL）实现可串行化调度">两段锁协议（2PL）实现可串行化调度</h4>
<h4 id="MVCC-2">MVCC</h4>
<h4 id="两种事务隔离级别（读提交和可重复读）">两种事务隔离级别（读提交和可重复读）</h4>
<h4 id="死锁处理">死锁处理</h4>
<h4 id="简单的表和字段管理">简单的表和字段管理</h4>
<h4 id="简单的-SQL-解析">简单的 SQL 解析</h4>
<h4 id="基于-socket-的-server-和-client">基于 socket 的 server 和 client</h4>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>MYDB</tag>
        <tag>轮子</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal</title>
    <url>/post/151f44ae.html</url>
    <content><![CDATA[<h2 id="ThreadLocal">ThreadLocal</h2>
<h3 id="是什么">是什么</h3>
<p>ThreadLocal：线程本地变量，访问这个变量的每个线程都会有它的一个<strong>本地拷贝</strong>，即实际操作的是自己本地内存中的变量。</p>
<p>创建之后新建线程访问都是它的副本，写入和读取可以在任何时候。</p>
<h3 id="有什么特点、用处">有什么特点、用处</h3>
<ol>
<li>用户上下文的存储：</li>
</ol>
<p>用ThreadLocal，在控制层拦截请求把用户信息存入ThreadLocal，在任何地方都可以取出信息进行使用。避免了在服务层和持久层（如rpc调用、更新用户获取）需要重新解析用户信息的操作。</p>
<ol start="2">
<li>cookie session 等的数据隔离</li>
</ol>
<p>将数据存储在当前线程的线程局部变量中，即每个线程持有的都是一个ThreadLocal的副本，从而做到了数据隔离。</p>
<ol start="3">
<li>数据库连接池</li>
</ol>
<h3 id="如何实现的">如何实现的</h3>
<ul>
<li>Thread类有⼀个类型为ThreadLocal.ThreadLocalMap的实例变量threadlocals，每个线程都有<strong>⼀个属于自己的ThreadLocalMap</strong>。</li>
<li>ThreadLocalMap 内部维护着 Entry 数组，每个  Entry 代表⼀个完整的对象，key是ThreadLocal的弱引⽤，value是ThreadLocal的泛型值。</li>
<li>每个线程在往ThreadLocal⾥设置值的时候，都是<strong>往⾃⼰的ThreadLocalMap⾥存</strong>，读也是以某个ThreadLocal作为<strong>引⽤</strong>，在⾃⼰的map⾥找对应的key，从⽽实现了线程隔离。</li>
<li>ThreadLocal本⾝不存储值，它只是作为⼀个key来让线程往ThreadLocalMap⾥存取值。</li>
</ul>
<h3 id="ThreadLocal内存泄漏">ThreadLocal内存泄漏</h3>
<p>栈中存了 ThreadLocal Thread的引用，堆中存了其具体实例。ThreadLocalMap中使用的key是ThreadLocal的<strong>弱引用</strong>。</p>
<p>而弱引用只要垃圾回收机制启动就会被回收，另外，ThreadLocalMap生命周期和Thread是一样的，从而可能出现ThreadLocalMap的key没了但是value还在，即出现内存泄漏。</p>
<p>如何解决？每次使用完ThreadLocal之后，及时调用remove方法释放内存空间。</p>
<h3 id="ThreadLocalMap">ThreadLocalMap</h3>
<ol>
<li>结构</li>
</ol>
<p><strong>元素数组</strong>：<code>private Entry[] table;</code>一个 table 数组，存储 Entry 类型的元素，Entry的结构是 ThreadLocal 的<strong>弱引用</strong>作为 key，Object 作为 value。</p>
<p><strong>散列方法</strong>：哈希取余法。<code>int i = key.threadLocalHashCode &amp; (table.length - 1);</code>其哈希增量为黄金分割数，使得哈希分布非常均匀。</p>
<ol start="2">
<li>解决Hash冲突的方式</li>
</ol>
<p>HashMap 使用 <strong>链地址法</strong>。</p>
<p>ThreadLocalMap 使用 <strong>开放定址法</strong>。set 时若无散列到的坐标已被占据就去寻找下一个空着的位置；get时若散列位置的key与实际key不一致，则去后面寻找=实际key的位置。</p>
<ol start="3">
<li>扩容机制</li>
</ol>
<p>何时开启扩容：</p>
<p>执行启发式清理工作后未清理到任何数据 <strong>且</strong> 当前散列数组中Entry数量已经达到列表的扩容阈值（len*2/3），则开始rehash()逻辑：</p>
<p>rehash()：</p>
<p>resize()：</p>
<h3 id="父子线程共享数据">父子线程共享数据</h3>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Wetab</title>
    <url>/post/32e2265d.html</url>
    <content><![CDATA[<blockquote>
<p>Wetab笔记，给你更好的笔记体验</p>
<p>这里是<a href="https://www.wetab.link">Wetab新标签官网</a> (右键点击打开链接)</p>
</blockquote>
<p>以下特性可以为你的笔记带来非常棒的体验：</p>
<ul>
<li>
<p>[x] 📝 <strong>所见即所得的 Markdown</strong> - 以一种优雅的方式编写 markdown</p>
</li>
<li>
<p>[x] 👍 <strong>Emoji</strong> - 支持 emoji 快捷指令和选择器</p>
</li>
<li>
<p>[x] 💾 <strong>剪贴板</strong> - 支持 markdown 格式的复制粘贴</p>
</li>
<li>
<p>[x] ⌨️ <strong>换行模式</strong> - 你可以使用“Enter”和“Shift + Enter”两种方式进行换行</p>
</li>
<li>
<p>[x] ⚡ <strong>斜线指令</strong> - 在空白处输入状态下通过“/”可以完成丰富的输入指令</p>
</li>
<li>
<p>[x] 🧮 <strong>数学支持</strong> - 你可以完成数学公式的描写</p>
</li>
<li>
<p>[x] 📊 <strong>表格支持</strong> - 拥有流畅的 ui 的表格支持</p>
</li>
<li>
<p>[x] 📰 <strong>图表支持</strong> - 基于<a href="https://mermaid-js.github.io/mermaid/#/">mermaid</a>的图表支持</p>
</li>
</ul>
<hr>
<p>你可以添加行内代码例如 <code>inline code</code> 和代码块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips: 使用<code>Mod-Enter</code>来退出块级元素，例如代码块。</p>
</blockquote>
<hr>
<p>你可以输入<code>||</code>和一个空格来创建表格：</p>
<table>
<thead>
<tr>
<th style="text-align:left">表头 1</th>
<th style="text-align:center">表头 2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">内容 1</td>
<td style="text-align:center"><s>内容 1</s></td>
</tr>
<tr>
<td style="text-align:left">内容 2</td>
<td style="text-align:center"><strong>内容</strong> 2</td>
</tr>
</tbody>
</table>
<hr>
<p>数学公式通过 <a href="https://en.wikipedia.org/wiki/TeX">TeX 表达式</a>支持。</p>
<p>这里我们有行内公式： $E = mc^2$，你可以点击并编辑它。</p>
<p>数学公式块也是支持的。</p>
<p>$$<br>
\begin{aligned}<br>
T( (v_1 + v_2) \otimes w) &amp;= T(v_1 \otimes w) + T(v_2 \otimes w) \<br>
T( v \otimes (w_1 + w_2)) &amp;= T(v \otimes w_1) + T(v \otimes w_2) \<br>
T( (\alpha v) \otimes w ) &amp;= T( \alpha ( v \otimes w) ) \<br>
T( v \otimes (\alpha w) ) &amp;= T( \alpha ( v \otimes w) ) \<br>
\end{aligned}<br>
$$</p>
<p>你可以输入<code>$$</code>和一个空格来创建数学公式块。</p>
<hr>
<p>使用 <a href="https://www.webfx.com/tools/emoji-cheat-sheet/">emoji 快捷指令</a> 例如 <code>:+1:</code> 来添加 emoji.</p>
<p>在输入时，你也许注意到了 emoji 过滤器，尝试输入<code>:baby</code>来查看它。</p>
<hr>
<p>你可以输入 <code>```mermaid</code> 来添加图表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    EditorState--&gt;EditorView;</span><br><span class="line">    EditorView--&gt;DOMEvent;</span><br><span class="line">    DOMEvent--&gt;Transaction;</span><br><span class="line">    Transaction--&gt;EditorState;</span><br></pre></td></tr></table></figure>
<hr>
<p>Wetab笔记基于 <a href="https://milkdown.dev/">Milkdown</a> 完成</p>
]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu(wsl)安装Redis并搭建集群</title>
    <url>/post/ac35e331.html</url>
    <content><![CDATA[<h2 id="Ubuntu（wsl）安装Redis并搭建集群">Ubuntu（wsl）安装Redis并搭建集群</h2>
<h3 id="起因">起因</h3>
<p>配置Redis集群，Windows本机已经有了Redis，就想在wsl中装Redis集群。</p>
<h3 id="踩坑历程">踩坑历程</h3>
<ol>
<li>还就那个经典的：</li>
</ol>
<p>启动wsl时报错 <code>占位程序接收到错误数据。 Error code: Wsl/Service/0x800706f7</code>。行吧，不连梯子上不去网站，连上梯子就总有幺蛾子。解决办法：终端管理员权限运行<code>netsh winsock reset</code>，或者使用<code>NoLSP.exe</code>启动wsl。</p>
<ol start="2">
<li>Redis 安装：</li>
</ol>
<p>从<a href="http://download.redis.io/releases/">redis发行网站</a>上下载最新版本的<code>redis-7.2.0.tar.gz</code>，解压，cd到目录下，<code>make</code>构建。</p>
<p>来力：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(.<span class="property">venv</span>) vagrant@<span class="attr">vagrant</span>:<span class="regexp">/vagrant/</span>redis-<span class="number">6.0</span><span class="number">.6</span>$ make</span><br><span class="line">cd src &amp;&amp; make all</span><br><span class="line">make[<span class="number">1</span>]: <span class="title class_">Entering</span> directory <span class="string">&#x27;/vagrant/redis-6.0.6/src&#x27;</span></span><br><span class="line">/bin/<span class="attr">sh</span>: <span class="number">1</span>: pkg-<span class="attr">config</span>: not found</span><br><span class="line">    <span class="variable constant_">CC</span> <span class="title class_">Makefile</span>.<span class="property">dep</span></span><br><span class="line">/bin/<span class="attr">sh</span>: <span class="number">1</span>: pkg-<span class="attr">config</span>: not found</span><br><span class="line">make[<span class="number">1</span>]: <span class="title class_">Warning</span>: <span class="title class_">File</span> <span class="string">&#x27;Makefile.dep&#x27;</span> has modification time <span class="number">1.3</span> s <span class="keyword">in</span> the future</span><br><span class="line">    <span class="variable constant_">CC</span> adlist.<span class="property">o</span></span><br><span class="line">/bin/<span class="attr">sh</span>: <span class="number">1</span>: <span class="attr">cc</span>: not found</span><br><span class="line"><span class="title class_">Makefile</span>:<span class="number">315</span>: recipe <span class="keyword">for</span> target <span class="string">&#x27;adlist.o&#x27;</span> failed</span><br><span class="line">make[<span class="number">1</span>]: *** [adlist.<span class="property">o</span>] <span class="title class_">Error</span> <span class="number">127</span></span><br><span class="line">make[<span class="number">1</span>]: <span class="title class_">Leaving</span> directory <span class="string">&#x27;/vagrant/redis-6.0.6/src&#x27;</span></span><br><span class="line"><span class="title class_">Makefile</span>:<span class="number">6</span>: recipe <span class="keyword">for</span> target <span class="string">&#x27;all&#x27;</span> failed</span><br><span class="line"><span class="attr">make</span>: *** [all] <span class="title class_">Error</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>解决办法：</p>
<ul>
<li>少了<code>pkg-config</code>，安装之，顺便安装了<code>gcc</code>和<code>tcl</code>（没有<code>tcl</code>在 <code>make test</code>时会报错）。</li>
<li>安装<code>gcc</code>和<code>tcl</code>时会出现：<code>/sbin/ldconfig.real: /usr/lib/wsl/lib/libcuda.so.1 is not a symbolic link</code>这个问题，可<a href="https://github.com/microsoft/WSL/issues/5663">参考链接</a>（目前未深究……）。</li>
<li>然后删除解压出来的 redis 文件夹，重新解压再重新 make 。大成功。参考：<a href="https://stackoverflow.com/questions/63611270/redis-make-failing-ubuntu-18-04">ubuntu(wsl)安装redis时make报错</a></li>
</ul>
<p><img src="/post/ac35e331/Redis%E5%AE%89%E8%A3%85.jpg" alt="img"></p>
<ol start="3">
<li>Redis集群设置</li>
</ol>
<p>搭建三个节点，对应端口分别是7000,7001,7002。配置如下：<a href="https://blog.hhui.top/hexblog/2019/09/25/190925-Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%89%8B%E5%86%8C/">Redis集群搭建手册</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p data/7000 data/7001 data/7002 log/7000 log/7001 log/7002 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面的配置，一次操作三遍，分别获得r7000.conf r7001.conf r7002.conf</span></span><br><span class="line">cp redis.conf r7000.conf</span><br><span class="line">vim r7000.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 下面是我们需要修改的地方</span></span></span><br><span class="line">port 7000 # 端口号</span><br><span class="line">pidfile /var/run/redis_7000.pid # pid进程文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志和数据存储路径</span></span><br><span class="line">logfile &quot;/home/yihui/redis/log/7000/redis.log&quot;</span><br><span class="line">dir &quot;/home/yihui/redis/data/7000/&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后台启动</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启集群</span></span><br><span class="line">cluster-enabled yes</span><br></pre></td></tr></table></figure>
<p>启动Redis，设置集群，集群至少需要三主节点，设置主从时最少要六个节点，不是很有必要啊，直接不要从节点了：</p>
<p><img src="/post/ac35e331/Redis%E9%9B%86%E7%BE%A4%E8%AE%BE%E7%BD%AE.jpg" alt="img"></p>
<p>最后用<code>redis-cli</code>测试一下：</p>
<p><img src="/post/ac35e331/Redis%E9%9B%86%E7%BE%A4%E6%B5%8B%E8%AF%95.jpg" alt="img"></p>
<h3 id="番外">番外</h3>
<p>关于<code>hexo</code>中图片显示问题，<a href="https://blog.csdn.net/m0_43401436/article/details/107191688">这里</a>讲得很清楚，csdn 中难得的好文了。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录之哈希表</title>
    <url>/post/89e159ee.html</url>
    <content><![CDATA[<h2 id="哈希表">哈希表</h2>
<h3 id="哈希表-2">哈希表</h3>
<p>什么是哈希表（Hash Table）？</p>
<blockquote>
<p>哈希表是根据关键码的值而直接进行访问的数据结构。</p>
</blockquote>
<p>哈希表能解决什么问题？</p>
<blockquote>
<p>一般可以<strong>用来快速判断一个元素是否出现在集合中。</strong></p>
</blockquote>
<p>哈希表如何产生？例如查询一个名字是否在这所学校中？</p>
<blockquote>
<p>哈希函数进行映射。</p>
</blockquote>
<h3 id="哈希函数">哈希函数</h3>
<p>哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。</p>
<p>哈希函数如下图所示，通过 hashCode 把名字转化为数值，一般 hashcode 是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。</p>
<p><img src="/post/89e159ee/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0.png" alt="哈希函数"></p>
<p>当hashCode得到的数值大于哈希表的大小，即tableSize，对得到的数值进行<strong>取模</strong>操作之后，数值一定就能放入表中。然而，表的大小是有限的，当要映射的数量大于表的大小，必然会出现<strong>不同的数据映射到同一个位置的情况</strong>，此时即出现了<strong>哈希碰撞</strong>。</p>
<p><img src="/post/89e159ee/%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E.png" alt="哈希碰撞"></p>
<p>如何解决哈希碰撞？</p>
<ul>
<li>拉链法——在发生冲突的位置上将冲突的元素排成一个链表。要查找此处的某个元素，先找到下标，再从链表中查找具体值。</li>
<li>线性探测法——当表大于数据量时，发生哈希碰撞，在冲突的位置后面寻找一个空着的位置存放此元素。</li>
</ul>
<h3 id="三种哈希结构">三种哈希结构</h3>
<ul>
<li>数组</li>
<li>set（集合）</li>
<li>map（映射）</li>
</ul>
<h3 id="小结">小结</h3>
<p>总结一下，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p>
<p>哈希法是牺牲空间换取时间的方法，因为使用了额外的空间来存放数据。</p>
<h2 id="有效的字母异位词">有效的字母异位词</h2>
<blockquote>
<p>即判断两个字符串是相同的字母组成。如：abbc, bbac。</p>
<p><a href="https://leetcode.cn/problems/valid-anagram/">力扣题目链接</a></p>
</blockquote>
<ol>
<li>暴力，双层循环枚举，判断字符是否出现的同时还要记录字符出现的次数，时间复杂度O(n^2)。</li>
<li>哈希表</li>
</ol>
<p>上一节中提到三种常见哈希结构：数组、set、map。其中，数组适用于数据范围较小的情况，set适用于数据范围大的情况，map适用于出现key-value对的情况。</p>
<p>本题中的字符串s, t都是小写字符串，小写字母26个，且其ASCII值也是连续的，因此，考虑将字符串中的字符映射到数组中，记录两个字符串中字符出现的次数进行比较。</p>
<p>定义一个数组 record 来记录字符串 s 中字符出现次数；遍历串s，得到其字符出现的次数；遍历串t，对其映射到数组中的数值-1；检查最后的记录数组，如果数组索引上的数值都是0，说明两个串相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 242. 有效的字母异位词 字典解法</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(m+n) 空间复杂度O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            record[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;     <span class="comment">// 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            record[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> count: record) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;               <span class="comment">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;                        <span class="comment">// record数组所有元素都为零0，说明字符串s和t是字母异位词</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两个数组的交集">两个数组的交集</h2>
<blockquote>
<p>给定两个数组，编写一个函数来计算它们的交集。</p>
<p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">力扣链接</a></p>
</blockquote>
<ul>
<li>给一个元素判断是否出现过，那么第一反应就可以是看能否用哈希表。</li>
</ul>
<ol>
<li>用 set 解决（在还没有限制数组元素大小时）（同时，哈希值少，分散和跨度非常大时，使用数组会造成极大的空间浪费。）</li>
</ol>
<p>思路：将 num1 转化成哈希表，将 num2 中元素取出与哈希表进行比较，若出现相同元素，将其存放到结果 哈希表 result 中。数据类型：HashSet。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1 == <span class="literal">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="literal">null</span> || nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; resSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历数组1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            set1.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历数组2的过程中判断哈希表中是否存在该元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set1.contains(i)) &#123;</span><br><span class="line">                resSet.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//方法1：将结果集合转为数组</span></span><br><span class="line">        <span class="keyword">return</span> resSet.stream().mapToInt(x -&gt; x).toArray();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方法2：另外申请一个数组存放setRes中的元素,最后返回数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[resSet.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : resSet)&#123;</span><br><span class="line">            arr[j++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用Hash数组，思路同上，只不过限制了元素大小</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="type">int</span>[] hash1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1002</span>];</span><br><span class="line">        <span class="type">int</span>[] hash2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1002</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1)</span><br><span class="line">            hash1[i]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums2)</span><br><span class="line">            hash2[i]++;</span><br><span class="line">        List&lt;Integer&gt; resList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1002</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(hash1[i] &gt; <span class="number">0</span> &amp;&amp; hash2[i] &gt; <span class="number">0</span>)</span><br><span class="line">                resList.add(i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span>[resList.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : resList)</span><br><span class="line">            res[index++] = i;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快乐数">快乐数</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/happy-number/">力扣链接</a></p>
<p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p>
<p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p>
</blockquote>
<p>思路：<strong>无限循环</strong>什么时候会出现？当求和中出现了<strong>相同的 sum</strong> 的时候。那么。如何判断一个元素是否出现在集合中呢？使用哈希法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; record = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !record.contains(n)) &#123; <span class="comment">// 记录中不包含重复的sum</span></span><br><span class="line">            record.add(n);</span><br><span class="line">            n = getNextNumber(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取数各个位求平方的和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNextNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">            res += temp * temp;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两数之和">两数之和</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/two-sum/">力扣题目链接</a></p>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9</p>
<p>所以返回 [0, 1]</p>
</blockquote>
<p>思路：本题中，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适。</p>
<p>使用数组和set来做哈希法的局限。</p>
<ul>
<li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li>
<li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> target - nums[i];   <span class="comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(temp))&#123;</span><br><span class="line">            res[<span class="number">1</span>] = i;</span><br><span class="line">            res[<span class="number">0</span>] = map.get(temp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);    <span class="comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度O(n) 空间复杂度O(n)</span></span><br></pre></td></tr></table></figure>
<p>本题四个重点：</p>
<ul>
<li>为什么会想到用哈希表——因为要判断元素是否用过</li>
<li>哈希表为什么用map——因为需要一个key-value类型的哈希数据结构</li>
<li>本题map是用来存什么的——存访问过的元素</li>
<li>map中的key和value用来存什么的——key-数据元素，value-数组元素对应的下标。</li>
</ul>
<h2 id="四数相加Ⅱ">四数相加Ⅱ</h2>
<blockquote>
<p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</p>
<p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p>
<p><a href="https://leetcode.cn/problems/4sum-ii/">题目链接</a></p>
</blockquote>
<p>思路：</p>
<p>步骤：</p>
<ul>
<li>首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。</li>
<li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</li>
<li>定义int变量count，用来统计 a+b+c+d = 0 出现的次数。</li>
<li>在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</li>
<li>最后返回统计值 count 就可以了</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="comment">//统计两个数组中的元素之和，同时统计出现的次数，放入map</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : nums2) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> i + j;</span><br><span class="line">                map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : nums4) &#123;</span><br><span class="line">                res += map.getOrDefault(<span class="number">0</span> - i - j, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度: O(n^2)</li>
<li>空间复杂度: O(n^2)，最坏情况下A和B的值各不相同，相加产生的数字个数为 n^2</li>
</ul>
<h2 id="赎金信">赎金信</h2>
<blockquote>
<p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p>
<p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p>
<p>注意：</p>
<p>你可以假设两个字符串均只含有小写字母。</p>
<p>canConstruct(“a”, “b”) -&gt; false</p>
<p>canConstruct(“aa”, “ab”) -&gt; false</p>
<p>canConstruct(“aa”, “aab”) -&gt; true</p>
<p><a href="https://leetcode.cn/problems/ransom-note/">链接</a></p>
</blockquote>
<p><strong>思路</strong>：</p>
<p>这道题目和242.有效的字母异位词 (opens new window)很像，242.有效的字母异位词 (opens new window)相当于求 字符串a 和 字符串b 是否可以相互组成 ，而这道题目是求 字符串a能否组成字符串b，而不用管字符串b 能不能组成字符串a。</p>
<p>本题判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成，但是这里需要注意两点。</p>
<ul>
<li>第一点“为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思”  这里说明杂志里面的字母不可重复使用。</li>
<li>第二点 “你可以假设两个字符串均只含有小写字母。” 说明只有小写字母，这一点很重要</li>
</ul>
<p><strong>暴力</strong>：</p>
<p><strong>哈希</strong>：</p>
<p>因为题目说只有小写字母，那可以采用<strong>空间换取时间的哈希策略</strong>，用一个长度为26的数组来记录magazine里字母出现的次数。</p>
<p>然后再用 ransomNote 去验证这个数组是否包含了 ransomNote 所需要的所有字母。</p>
<p>依然是数组在哈希法中的应用。</p>
<p>一些同学可能想，用数组干啥，都用map完事了，其实在本题的情况下，使用map的空间消耗要比数组大一些的，因为<strong>map要维护红黑树或者哈希表，而且还要做哈希函数</strong>，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="comment">// shortcut</span></span><br><span class="line">        <span class="keyword">if</span> (ransomNote.length() &gt; magazine.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义一个哈希映射数组</span></span><br><span class="line">        <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : magazine.toCharArray())&#123;</span><br><span class="line">            record[c - <span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : ransomNote.toCharArray())&#123;</span><br><span class="line">            record[c - <span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果数组中存在负数，说明ransomNote字符串总存在magazine中没有的字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : record)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三数之和">三数之和</h2>
<blockquote>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p>注意： 答案中不可以包含重复的三元组。</p>
<p>示例：</p>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p>
<p>[<a href="https://leetcode.cn/problems/3sum/">链接</a></p>
</blockquote>
<p><strong>思路</strong>：</p>
<p>首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。</p>
<p>依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i]，b = nums[left]，c = nums[right]。</p>
<p>接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</p>
<p>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。</p>
<p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">	<span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">	    <span class="comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123; </span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;  <span class="comment">// 去重a</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">		    <span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    </span><br><span class="line">                    right--; </span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四数之和">四数之和</h2>
<blockquote>
<p>题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p>注意：</p>
<p>答案中不可以包含重复的四元组。</p>
<p>示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</p>
<p>[<a href="https://leetcode.cn/problems/4sum/">链接</a></p>
</blockquote>
<p><strong>思路</strong>：</p>
<p>四数之和，和 三数之和 (opens new window) 是一个思路，都是使用双指针法,，基本解法就是在三数之和 的基础上再套一层for循环。</p>
<p>但是，有一些细节需要注意，例如： 不要判断<code>nums[k] &gt; target</code> 就返回了，三数之和 可以通过 nums[i] &gt; 0 就返回了，因为 0 已经是确定的数了，四数之和这道题目 target是任意值。比如：数组是[-4, -3, -2, -1]，target是-10，不能因为-4 &gt; -10而跳过。但是我们依旧可以去做剪枝，逻辑变成nums[i] &gt; target &amp;&amp; (nums[i] &gt;=0 || target &gt;= 0)就可以了。</p>
<p>三数之和 (opens new window)的双指针解法是一层for循环num[i]为确定值，然后循环内有left和right下标作为双指针，找到nums[i] + nums[left] + nums[right] == 0。</p>
<p>四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] == target的情况，三数之和的时间复杂度是O(n^2)，四数之和的时间复杂度是O(n^3) 。</p>
<p>那么一样的道理，五数之和、六数之和等等都采用这种解法。</p>
<p>对于三数之和 (opens new window)双指针法就是将原本暴力O(n^3)的解法，降为O(n^2)的解法，四数之和的双指针解法就是将原本暴力O(n^4)的解法，降为O(n^3)的解法。</p>
<p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">		</span><br><span class="line">            <span class="comment">// nums[i] &gt; target 直接返回, 剪枝操作</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">		</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;    <span class="comment">// 对nums[i]去重</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) &#123;  <span class="comment">// 对nums[j]去重</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">		    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target int会溢出</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>) nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                        <span class="comment">// 对nums[left]和nums[right]去重</span></span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结-2">小结</h2>
]]></content>
      <categories>
        <category>Coding</category>
        <category>代码随想录</category>
      </categories>
      <tags>
        <tag>刷题笔记</tag>
        <tag>代码随想录</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录之字符串</title>
    <url>/post/f06f8293.html</url>
    <content><![CDATA[<h1>代码随想录之字符串</h1>
<blockquote>
<p><strong>打基础的时候，不要太依赖库函数！</strong></p>
</blockquote>
<h2 id="反转字符串">反转字符串</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/reverse-string/">力扣题目链接(opens new window)</a></p>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<p>示例 1：<br>
输入：[“h”,“e”,“l”,“l”,“o”]<br>
输出：[“o”,“l”,“l”,“e”,“h”]</p>
<p>示例 2：<br>
输入：[“H”,“a”,“n”,“n”,“a”,“h”]<br>
输出：[“h”,“a”,“n”,“n”,“a”,“H”]</p>
</blockquote>
<p><strong>思路</strong>：</p>
<p>双指针，分别从字符串的开始位置<code>i</code>和结束位置<code>j</code>同时开始向中间移动，并交换元素。循环终止条件是指针位置相同。</p>
<p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            s[l] ^= s[r];  <span class="comment">//构造 a ^ b 的结果，并放在 a 中</span></span><br><span class="line">            s[r] ^= s[l];  <span class="comment">//将 a ^ b 这一结果再 ^ b ，存入b中，此时 b = a, a = a ^ b</span></span><br><span class="line">            s[l] ^= s[r];  <span class="comment">//a ^ b 的结果再 ^ a ，存入 a 中，此时 b = a, a = b 完成交换</span></span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方法用temp来交换数值更多人容易理解些</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s[l];</span><br><span class="line">            s[l] = s[r];</span><br><span class="line">            s[r] = temp;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="反转字符串Ⅱ">反转字符串Ⅱ</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/reverse-string-ii/">力扣题目链接(opens new window)</a></p>
<p>给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。</p>
<p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p>
<p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>
<p>示例:</p>
<p>输入: s = “abcdefg”, k = 2<br>
输出: “bacdfeg”</p>
</blockquote>
<p><strong>思路</strong>：</p>
<p>模拟，实现题目中的反转规则。</p>
<p>在遍历字符串的过程中，只要让 i += (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。</p>
<p>因为要找的也就是每2 * k 区间的起点，这样写，程序会高效很多。</p>
<p><strong>所以当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。</strong></p>
<p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解法一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; length) &#123;</span><br><span class="line">            <span class="comment">// 找到k处和2k处</span></span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            <span class="comment">// 与length进行判断，如果大于length了，那就将其置为length</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">firstK</span> <span class="operator">=</span> (start + k &gt; length) ? length : start + k;</span><br><span class="line">            <span class="type">int</span> <span class="variable">secondK</span> <span class="operator">=</span> (start + (<span class="number">2</span> * k) &gt; length) ? length : start + (<span class="number">2</span> * k);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//无论start所处位置，至少会反转一次</span></span><br><span class="line">            temp.append(s.substring(start, firstK));</span><br><span class="line">            res.append(temp.reverse());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果firstK到secondK之间有元素，这些元素直接放入res里即可。</span></span><br><span class="line">            <span class="keyword">if</span> (firstK &lt; secondK) &#123; <span class="comment">//此时剩余长度一定大于k。</span></span><br><span class="line">                res.append(s.substring(firstK, secondK));</span><br><span class="line">            &#125;</span><br><span class="line">            start += (<span class="number">2</span> * k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解法二（似乎更容易理解点）</span></span><br><span class="line"><span class="comment">//题目的意思其实概括为 每隔2k个反转前k个，尾数不够k个时候全部反转</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ch.length; i += <span class="number">2</span> * k)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">//这里是判断尾数够不够k个来取决end指针的位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(ch.length - <span class="number">1</span>, start + k - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//用异或运算反转 </span></span><br><span class="line">            <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">                ch[start] ^= ch[end];</span><br><span class="line">                ch[end] ^= ch[start];</span><br><span class="line">                ch[start] ^= ch[end];</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法二还可以用temp来交换数值，会的人更多些</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; ch.length;i += <span class="number">2</span> * k)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">// 判断尾数够不够k个来取决end指针的位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(ch.length - <span class="number">1</span>,start + k - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> ch[start];</span><br><span class="line">                ch[start] = ch[end];</span><br><span class="line">                ch[end] = temp;</span><br><span class="line"></span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; ch.length; i += <span class="number">2</span> * k) &#123;</span><br><span class="line">            <span class="comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span></span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= ch.length) &#123;</span><br><span class="line">                reverse(ch, i, i + k -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转</span></span><br><span class="line">            reverse(ch, i, ch.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义翻转函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] ch, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; j; i++, j--) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span>  <span class="operator">=</span> ch[i];</span><br><span class="line">        ch[i] = ch[j];</span><br><span class="line">        ch[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="替换空格">替换空格</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指offer 05.替换空格</a></p>
<p>请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。</p>
<p>示例 1：</p>
<p>输入：s = “We are happy.”</p>
<p>输出：“We%20are%20happy.”</p>
</blockquote>
<p><strong>思路</strong>：</p>
<ol>
<li>直接复制到新数组，在逐个复制的过程中，检测到空格就替换成<code>%20</code>，复制完毕转回 String。</li>
<li>双指针：先确定空格数量，扩充替换空格之后的字符串空间，定义两个指针，分别指向原始字符串的末尾位置和扩展字符串的末尾位置，<strong>从右往左</strong>开始遍历，逐个替换。</li>
</ol>
<ul>
<li>时间复杂度 O(n)</li>
<li>空间复杂度 O(1)</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用一个新的对象，复制 str，复制的过程对其判断，是空格则替换，否则直接复制，类似于数组复制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//选用 StringBuilder 单线程使用，比较快，选不选都行</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">//使用 sb 逐个复制 s ，碰到空格则替换，否则直接复制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//s.charAt(i) 为 char 类型，为了比较需要将其转为和 &quot; &quot; 相同的字符串类型</span></span><br><span class="line">            <span class="comment">//if (&quot; &quot;.equals(String.valueOf(s.charAt(i))))&#123;&#125;</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：双指针法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">null</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扩充空间，空格数量2倍</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            str.append(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若是没有空格直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(str.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有空格情况 定义两个指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;<span class="comment">//左指针：指向原始字符串最后一个位置</span></span><br><span class="line">    s += str.toString();</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;<span class="comment">//右指针：指向扩展字符串的最后一个位置</span></span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">while</span>(left&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(chars[left] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            chars[right--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            chars[right--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            chars[right] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            chars[right] = chars[left];</span><br><span class="line">        &#125;</span><br><span class="line">        left--;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="翻转字符串里的单词">翻转字符串里的单词</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">LeetCode:151.翻转字符串里的单词</a></p>
<p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<p>示例 1：</p>
<p>输入: “the sky is blue”</p>
<p>输出: “blue is sky the”</p>
<p>示例 2：</p>
<p>输入: &quot;  hello world!  &quot;</p>
<p>输出: “world! hello”</p>
<p>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p>
<p>示例 3：</p>
<p>输入: “a good   example”</p>
<p>输出: “example good a”</p>
<p>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个</p>
</blockquote>
<p><strong>思路</strong>：</p>
<p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不使用Java内置方法实现</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 1.去除首尾以及中间多余空格</span></span><br><span class="line"><span class="comment">     * 2.反转整个字符串</span></span><br><span class="line"><span class="comment">     * 3.反转各个单词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;ReverseWords.reverseWords2() called with: s = [&quot; + s + &quot;]&quot;);</span></span><br><span class="line">        <span class="comment">// 1.去除首尾以及中间多余空格</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> removeSpace(s);</span><br><span class="line">        <span class="comment">// 2.反转整个字符串</span></span><br><span class="line">        reverseString(sb, <span class="number">0</span>, sb.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3.反转各个单词</span></span><br><span class="line">        reverseEachWord(sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringBuilder <span class="title function_">removeSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;ReverseWords.removeSpace() called with: s = [&quot; + s + &quot;]&quot;);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s.charAt(start) == <span class="string">&#x27; &#x27;</span>) start++;</span><br><span class="line">        <span class="keyword">while</span> (s.charAt(end) == <span class="string">&#x27; &#x27;</span>) end--;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(start);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span> || sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;ReverseWords.removeSpace returned: sb = [&quot; + sb + &quot;]&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转字符串指定区间[start, end]的字符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(StringBuilder sb, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;ReverseWords.reverseString() called with: sb = [&quot; + sb + &quot;], start = [&quot; + start + &quot;], end = [&quot; + end + &quot;]&quot;);</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> sb.charAt(start);</span><br><span class="line">            sb.setCharAt(start, sb.charAt(end));</span><br><span class="line">            sb.setCharAt(end, temp);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;ReverseWords.reverseString returned: sb = [&quot; + sb + &quot;]&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverseEachWord</span><span class="params">(StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sb.length();</span><br><span class="line">        <span class="keyword">while</span> (start &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            reverseString(sb, start, end - <span class="number">1</span>);</span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            end = start + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解法二：创建新字符数组填充。时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//源字符数组</span></span><br><span class="line">        <span class="type">char</span>[] initialArr = s.toCharArray();</span><br><span class="line">        <span class="comment">//新字符数组</span></span><br><span class="line">        <span class="type">char</span>[] newArr = <span class="keyword">new</span> <span class="title class_">char</span>[initialArr.length+<span class="number">1</span>];<span class="comment">//下面循环添加&quot;单词 &quot;，最终末尾的空格不会返回</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newArrPos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//i来进行整体对源字符数组从后往前遍历</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> initialArr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; initialArr[i] == <span class="string">&#x27; &#x27;</span>)&#123;i--;&#125;  <span class="comment">//跳过空格</span></span><br><span class="line">            <span class="comment">//此时i位置是边界或!=空格，先记录当前索引，之后的while用来确定单词的首字母的位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; initialArr[i] != <span class="string">&#x27; &#x27;</span>)&#123;i--;&#125; </span><br><span class="line">            <span class="comment">//指定区间单词取出(由于i为首字母的前一位，所以这里+1,)，取出的每组末尾都带有一个空格</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt;= right; j++) &#123;</span><br><span class="line">                newArr[newArrPos++] = initialArr[j];</span><br><span class="line">                <span class="keyword">if</span>(j == right)&#123;</span><br><span class="line">                    newArr[newArrPos++] = <span class="string">&#x27; &#x27;</span>;<span class="comment">//空格</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若是原始字符串没有单词，直接返回空字符串；若是有单词，返回0-末尾空格索引前范围的字符数组(转成String返回)</span></span><br><span class="line">        <span class="keyword">if</span>(newArrPos == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(newArr,<span class="number">0</span>,newArrPos-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解法三：双反转+移位，String 的 toCharArray() 方法底层会 new 一个和原字符串相同大小的 char 数组，空间复杂度：O(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 思路：</span></span><br><span class="line"><span class="comment">     *	①反转字符串  &quot;the sky is blue &quot; =&gt; &quot; eulb si yks eht&quot;</span></span><br><span class="line"><span class="comment">     *	②遍历 &quot; eulb si yks eht&quot;，每次先对某个单词进行反转再移位</span></span><br><span class="line"><span class="comment">     *	   这里以第一个单词进行为演示：&quot; eulb si yks eht&quot; ==反转=&gt; &quot; blue si yks eht&quot; ==移位=&gt; &quot;blue si yks eht&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//步骤1：字符串整体反转（此时其中的单词也都反转了）</span></span><br><span class="line">        <span class="type">char</span>[] initialArr = s.toCharArray();</span><br><span class="line">        reverse(initialArr, <span class="number">0</span>, s.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; initialArr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (initialArr[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tempCur</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; initialArr.length &amp;&amp; initialArr[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> tempCur; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == tempCur) &#123; <span class="comment">//步骤二：二次反转</span></span><br><span class="line">                    reverse(initialArr, tempCur, i - <span class="number">1</span>);<span class="comment">//对指定范围字符串进行反转，不反转从后往前遍历一个个填充有问题</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//步骤三：移动操作</span></span><br><span class="line">                initialArr[k++] = initialArr[j];</span><br><span class="line">                <span class="keyword">if</span> (j == i - <span class="number">1</span>) &#123; <span class="comment">//遍历结束</span></span><br><span class="line">                    <span class="comment">//避免越界情况，例如=&gt; &quot;asdasd df f&quot;，不加判断最后就会数组越界</span></span><br><span class="line">                    <span class="keyword">if</span> (k &lt; initialArr.length) &#123;</span><br><span class="line">                        initialArr[k++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//参数三：以防出现如&quot;asdasd df f&quot;=&gt;&quot;f df asdasd&quot;正好凑满不需要省略空格情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(initialArr, <span class="number">0</span>, (k == initialArr.length) &amp;&amp; (initialArr[k - <span class="number">1</span>] != <span class="string">&#x27; &#x27;</span>) ? k : k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] chars, <span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            chars[i] ^= chars[j];</span><br><span class="line">            chars[j] ^= chars[i];</span><br><span class="line">            chars[i] ^= chars[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 解法四：时间复杂度 O(n)</span></span><br><span class="line"><span class="comment"> * 参考卡哥 c++ 代码的三步骤：先移除多余空格，再将整个字符串反转，最后把单词逐个反转</span></span><br><span class="line"><span class="comment"> * 有别于解法一 ：没有用 StringBuilder  实现，而是对 String 的 char[] 数组操作来实现以上三个步骤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//用 char[] 来实现 String 的 removeExtraSpaces，reverse 操作</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="comment">//1.去除首尾以及中间多余空格</span></span><br><span class="line">        chars = removeExtraSpaces(chars);</span><br><span class="line">        <span class="comment">//2.整个字符串反转</span></span><br><span class="line">        reverse(chars, <span class="number">0</span>, chars.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//3.单词反转</span></span><br><span class="line">        reverseEachWord(chars);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.用 快慢指针 去除首尾以及中间多余空格，可参考数组元素移除的题解</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span>[] removeExtraSpaces(<span class="type">char</span>[] chars) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; fast &lt; chars.length; fast++) &#123;</span><br><span class="line">            <span class="comment">//先用 fast 移除所有空格</span></span><br><span class="line">            <span class="keyword">if</span> (chars[fast] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">//在用 slow 加空格。 除第一个单词外，单词末尾要加空格</span></span><br><span class="line">                <span class="keyword">if</span> (slow != <span class="number">0</span>)</span><br><span class="line">                    chars[slow++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                <span class="comment">//fast 遇到空格或遍历到字符串末尾，就证明遍历完一个单词了</span></span><br><span class="line">                <span class="keyword">while</span> (fast &lt; chars.length &amp;&amp; chars[fast] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                    chars[slow++] = chars[fast++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//相当于 c++ 里的 resize()</span></span><br><span class="line">        <span class="type">char</span>[] newChars = <span class="keyword">new</span> <span class="title class_">char</span>[slow];</span><br><span class="line">        System.arraycopy(chars, <span class="number">0</span>, newChars, <span class="number">0</span>, slow); </span><br><span class="line">        <span class="keyword">return</span> newChars;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双指针实现指定范围内字符串反转，可参考字符串反转题解</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] chars, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (right &gt;= chars.length) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;set a wrong right&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            chars[left] ^= chars[right];</span><br><span class="line">            chars[right] ^= chars[left];</span><br><span class="line">            chars[left] ^= chars[right];</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.单词反转</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseEachWord</span><span class="params">(<span class="type">char</span>[] chars)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//end &lt;= s.length() 这里的 = ，是为了让 end 永远指向单词末尾后一个位置，这样 reverse 的实参更好设置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>; end &lt;= chars.length; end++) &#123;</span><br><span class="line">            <span class="comment">// end 每次到单词末尾后的空格或串尾,开始反转单词</span></span><br><span class="line">            <span class="keyword">if</span> (end == chars.length || chars[end] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                reverse(chars, start, end - <span class="number">1</span>);</span><br><span class="line">                start = end + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="左旋转字符串">左旋转字符串</h2>
<h2 id="实现-strStr">实现 strStr()</h2>
<h2 id="重复的子字符串">重复的子字符串</h2>
<h2 id="小结">小结</h2>
]]></content>
      <categories>
        <category>Coding</category>
        <category>代码随想录</category>
      </categories>
      <tags>
        <tag>刷题笔记</tag>
        <tag>代码随想录</tag>
      </tags>
  </entry>
  <entry>
    <title>携程笔试记录</title>
    <url>/post/6f158289.html</url>
    <content><![CDATA[<h2 id="9-21-携程笔试（第二批）记录">9.21 携程笔试（第二批）记录</h2>
<h3 id="第一题：排列构造">第一题：排列构造</h3>
<p>题目描述：</p>
<p>长度为 a 的队列，构造长度相同的排列 b，要求b<sub>i</sub>≠a<sub>i</sub>，且b的字典序尽可能小。</p>
<p>排列——长为 n 的数组，1到n每个正整数都只出现了一次。</p>
<p>字典序——第一个不相等的元素小的那个排列的字典序更小。</p>
<p>输入输出：第一行输入 n 代表 a 的长度；第二行输入 n 个数代表a<sub>i</sub>。2≤n≤10^5。</p>
<p>示例：</p>
<p>3</p>
<p>1 2 3</p>
<p>输出：3 1 2</p>
<p>题解：</p>
<h3 id="第二题：字符串-s-转变成字符串-t">第二题：字符串 s 转变成字符串 t</h3>
<p>题目描述：字符串 s 转变成字符串 t。取字符 ch1, ch2（ch2可不在串s中），将s中的ch1变成ch2。用此操作将字符串 s 转变成字符串 t。若经过q次操作，可行则输出yes 否则输出no。</p>
<p>输入输出：s t 均为小写字母组成的串，长度相同，≤10^4。输入 q，代表操作次数；接下来两行输入串s和串t。1≤q≤10</p>
<p>示例：</p>
<p>3</p>
<p>ab</p>
<p>ba</p>
<p>abc</p>
<p>aaa</p>
<p>aaaa</p>
<p>abcd</p>
<p>输出：yes yes no（三行，每行一个）</p>
<p>题解：</p>
<h3 id="第三题：字母矩阵">第三题：字母矩阵</h3>
<p>题目描述：一个n行m列的全小写字母矩阵，求所有满足每个字母只出现一次的子矩阵个数。</p>
<p>输入输出：首行输入两个正整数n m；接下来n 行输入每行长度为m的串。1≤n,m≤500。输出，数量number。</p>
<p>示例：</p>
<p>2 3</p>
<p>aad</p>
<p>abc</p>
<p>输出：13</p>
<p>题解：</p>
<h3 id="第四题：位数修改">第四题：位数修改</h3>
<p>题目描述：对一个正整数，修改其k位，使其变成75的倍数，求所有的修改方案数量。（修改后为正整数，无前导零，答案对10^9+7取模。）</p>
<p>输入输出：首行输入整数n，第二行输入位数k。1≤n≤10^1000, 1≤k≤1000</p>
<p>示例：</p>
<p>355</p>
<p>2</p>
<p>输出：9（分别是150,225,300,450,525,675,750,825,975）</p>
<p>题解：</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/post/2f57a694.html</url>
    <content><![CDATA[<br>
<p align="center">
<img src="https://i.imgur.com/bYwl7Vf.png" alt="Learn Regex">
</p><br>
<h2 id="什么是正则表达式-？">什么是正则表达式 ？</h2>
<blockquote>
<p>正则表达式是一种被用于从文本中检索符合某些特定模式的文本。</p>
</blockquote>
<p>正则表达式是从左到右来匹配一个字符串的。“Regular Expression”这个词太长了，我们通常使用它的缩写“regex”或者“regexp”。<br>
正则表达式可以被用来替换字符串中的文本、验证表单、基于模式匹配从一个字符串中提取字符串等等。<br>
<br></p>
<p>想象一下，您正在编写应用程序，并且您希望在用户选择用户名时设置规则。我们希望用户名可以包含字母，数字，下划线和连字符。<br>
为了让它看起来不丑，我们还想限制用户名中的字符数量。这时我们可以使用以下正则表达式来验证用户名：</p>
<p align="center">
<img src="https://i.imgur.com/UrDb9qc.png" alt="Regular expression">
</p>
<p>上面这个正则表达式可以匹配 <code>john_doe</code>，<code>jo-hn_doe</code> 和 <code>john12_as</code>。但是它不能匹配 <code>Jo</code>，因为该字符串里面包含大写字符，并且它太短了。</p>
<h2 id="目录">目录</h2>
<ul>
<li><a href="#1-%E5%9F%BA%E6%9C%AC%E5%8C%B9%E9%85%8D">基本匹配</a></li>
<li><a href="#2-%E5%85%83%E5%AD%97%E7%AC%A6">元字符</a>
<ul>
<li><a href="#21-%E8%8B%B1%E6%96%87%E5%8F%A5%E5%8F%B7">英文句号</a></li>
<li><a href="#22-%E5%AD%97%E7%AC%A6%E9%9B%86">字符集</a>
<ul>
<li><a href="#221-%E5%90%A6%E5%AE%9A%E5%AD%97%E7%AC%A6%E9%9B%86">否定字符集</a></li>
</ul>
</li>
<li><a href="#23-%E9%87%8D%E5%A4%8D">重复</a>
<ul>
<li><a href="#231-%E6%98%9F%E5%8F%B7">星号</a></li>
<li><a href="#232-%E5%8A%A0%E5%8F%B7">加号</a></li>
<li><a href="#233-%E9%97%AE%E5%8F%B7">问号</a></li>
</ul>
</li>
<li><a href="#24-%E8%8A%B1%E6%8B%AC%E5%8F%B7">花括号</a></li>
<li><a href="#25-%E5%AD%97%E7%AC%A6%E7%BB%84">字符组</a></li>
<li><a href="#26-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84">分支结构</a></li>
<li><a href="#27-%E8%BD%AC%E4%B9%89%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6">转义特殊字符</a></li>
<li><a href="#28-%E5%AE%9A%E4%BD%8D%E7%AC%A6">定位符</a>
<ul>
<li><a href="#281-%E6%8F%92%E5%85%A5%E7%AC%A6%E5%8F%B7">插入符号</a></li>
<li><a href="#282-%E7%BE%8E%E5%85%83%E7%AC%A6%E5%8F%B7">美元符号</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-%E7%AE%80%E5%86%99%E5%AD%97%E7%AC%A6%E9%9B%86">简写字符集</a></li>
<li><a href="#4-%E6%96%AD%E8%A8%80">断言</a>
<ul>
<li><a href="#41-%E6%AD%A3%E5%90%91%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80">正向先行断言</a></li>
<li><a href="#42-%E8%B4%9F%E5%90%91%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80">负向先行断言</a></li>
<li><a href="#43-%E6%AD%A3%E5%90%91%E5%90%8E%E8%A1%8C%E6%96%AD%E8%A8%80">正向后行断言</a></li>
<li><a href="#44-%E8%B4%9F%E5%90%91%E5%90%8E%E8%A1%8C%E6%96%AD%E8%A8%80">负向后行断言</a></li>
</ul>
</li>
<li><a href="#5-%E6%A0%87%E8%AE%B0">标记</a>
<ul>
<li><a href="#51-%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99">不区分大小写</a></li>
<li><a href="#52-%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2">全局搜索</a></li>
<li><a href="#53-%E5%A4%9A%E8%A1%8C%E5%8C%B9%E9%85%8D">多行匹配</a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">常用正则表达式</a></li>
</ul>
<h2 id="1-基本匹配">1. 基本匹配</h2>
<p>正则表达式只是我们用于在文本中检索字符串的模式。例如正则表达式 <code>cat</code>，表示：字母 <code>c</code> 后面跟着一个字母 <code>a</code>，再后面跟着一个字母 <code>t</code>。</p>
<pre>
"cat" => The <a href="#learn-regex"><strong>cat</strong></a> sat on the mat
</pre>
<p>正则表达式 <code>123</code> 会匹配字符串“123”。通过将正则表达式中的每个字符逐个与要匹配的字符串中的每个字符进行比较，来完成正则匹配。<br>
正则表达式通常区分大小写，因此正则表达式 <code>Cat</code> 与字符串“cat”不匹配。</p>
<pre>
"Cat" => The cat sat on the <a href="#learn-regex"><strong>Cat</strong></a>
</pre>
<h2 id="2-元字符">2. 元字符</h2>
<p>元字符是正则表达式的基本组成元素。元字符在这里跟它通常表达的意思不一样，而是以某种特殊的含义去解释。有些元字符在写在方括号内时有特殊含义。<br>
元字符如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td>匹配除换行符以外的任意字符。</td>
</tr>
<tr>
<td style="text-align:center">[ ]</td>
<td>字符类，匹配方括号中包含的任意字符。</td>
</tr>
<tr>
<td style="text-align:center">[^ ]</td>
<td>否定字符类。匹配方括号中不包含的任意字符</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td>匹配前面的子表达式零次或多次</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td>匹配前面的子表达式一次或多次</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。</td>
</tr>
<tr>
<td style="text-align:center">{n,m}</td>
<td>花括号，匹配前面字符至少 n 次，但是不超过 m 次。</td>
</tr>
<tr>
<td style="text-align:center">(xyz)</td>
<td>字符组，按照确切的顺序匹配字符 xyz。</td>
</tr>
<tr>
<td style="text-align:center">|</td>
<td>分支结构，匹配符号之前的字符或后面的字符。</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td>转义符，它可以还原元字符原来的含义，允许你匹配保留字符 <code>[ ] ( ) &#123; &#125; . * + ? ^ $ \ |</code></td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td>匹配行的开始</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td>匹配行的结束</td>
</tr>
</tbody>
</table>
<h2 id="2-1-英文句号">2.1 英文句号</h2>
<p>英文句号 <code>.</code> 是元字符的最简单的例子。元字符 <code>.</code> 可以匹配任意单个字符。它不会匹配换行符和新行的字符。例如正则表达式 <code>.ar</code>，表示：任意字符后面跟着一个字母 <code>a</code>，<br>
再后面跟着一个字母 <code>r</code>。</p>
<pre>
".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>
<h2 id="2-2-字符集">2.2 字符集</h2>
<p>字符集也称为字符类。方括号被用于指定字符集。使用字符集内的连字符来指定字符范围。方括号内的字符范围的顺序并不重要。<br>
例如正则表达式 <code>[Tt]he</code>，表示：大写 <code>T</code> 或小写 <code>t</code> ，后跟字母 <code>h</code>，再后跟字母 <code>e</code>。</p>
<pre>
"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>
<p>然而，字符集中的英文句号表示它字面的含义。正则表达式 <code>ar[.]</code>，表示小写字母 <code>a</code>，后面跟着一个字母 <code>r</code>，再后面跟着一个英文句号 <code>.</code> 字符。</p>
<pre>
"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a>
</pre>
<h3 id="2-2-1-否定字符集">2.2.1 否定字符集</h3>
<p>一般来说插入字符 <code>^</code> 表示一个字符串的开始，但是当它在方括号内出现时，它会取消字符集。例如正则表达式 <code>[^c]ar</code>，表示：除了字母 <code>c</code> 以外的任意字符，后面跟着字符 <code>a</code>，<br>
再后面跟着一个字母 <code>r</code>。</p>
<pre>
"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>
<h2 id="2-3-重复">2.3 重复</h2>
<p>以下元字符 <code>+</code>，<code>*</code> 或 <code>?</code> 用于指定子模式可以出现多少次。这些元字符在不同情况下的作用不同。</p>
<h3 id="2-3-1-星号">2.3.1 星号</h3>
<p>星号 <code>*</code> 表示匹配上一个匹配规则零次或多次。正则表达式 <code>a*</code> 表示小写字母 <code>a</code> 可以重复零次或者多次。但是它如果出现在字符集或者字符类之后，它表示整个字符集的重复。<br>
例如正则表达式 <code>[a-z]*</code>，表示：一行中可以包含任意数量的小写字母。</p>
<pre>
"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.
</pre>
<p>星号 <code>*</code> 可以与元符号 <code>.</code> 用在一起，用来匹配任意字符串 <code>.*</code>。星号 <code>*</code> 可以与空格符 <code>\s</code> 一起使用，用来匹配一串空格字符。<br>
例如正则表达式 <code>\s*cat\s*</code>，表示：零个或多个空格，后面跟小写字母 <code>c</code>，再后面跟小写字母 <code>a</code>，再在后面跟小写字母 <code>t</code>，后面再跟零个或多个空格。</p>
<pre>
"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the <a href="#learn-regex"><strong>cat</strong></a>.
</pre>
<h3 id="2-3-2-加号">2.3.2 加号</h3>
<p>加号 <code>+</code> 表示匹配上一个字符一次或多次。例如正则表达式 <code>c.+t</code>，表示：一个小写字母 <code>c</code>，后跟任意数量的字符，后跟小写字母 <code>t</code>。</p>
<pre>
"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.
</pre>
<h3 id="2-3-3-问号">2.3.3 问号</h3>
<p>在正则表达式中，元字符 <code>?</code> 用来表示前一个字符是可选的。该符号匹配前一个字符零次或一次。<br>
例如正则表达式 <code>[T]?he</code>，表示：可选的大写字母 <code>T</code>，后面跟小写字母 <code>h</code>，后跟小写字母 <code>e</code>。</p>
<pre>
"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>
<pre>
"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.
</pre>
<h2 id="2-4-花括号">2.4 花括号</h2>
<p>在正则表达式中花括号（也被称为量词？）用于指定字符或一组字符可以重复的次数。例如正则表达式 <code>[0-9]&#123;2,3&#125;</code>，表示：匹配至少 2 位数字但不超过 3 位（0 到 9 范围内的字符）。</p>
<pre>
"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>
<p>我们可以省略第二个数字。例如正则表达式 <code>[0-9]&#123;2,&#125;</code>，表示：匹配 2 个或更多个数字。如果我们也删除逗号，则正则表达式 <code>[0-9]&#123;2&#125;</code>，表示：匹配正好为 2 位数的数字。</p>
<pre>
"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>
<pre>
"[0-9]{2}" => The number was 9.<a href="#learn-regex"><strong>99</strong></a><a href="#learn-regex"><strong>97</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>
<h2 id="2-5-字符组">2.5 字符组</h2>
<p>字符组是一组写在圆括号内的子模式 <code>(...)</code>。正如我们在正则表达式中讨论的那样，如果我们把一个量词放在一个字符之后，它会重复前一个字符。<br>
但是，如果我们把量词放在一个字符组之后，它会重复整个字符组。<br>
例如正则表达式 <code>(ab)*</code> 表示匹配零个或多个的字符串“ab”。我们还可以在字符组中使用元字符 <code>|</code>。例如正则表达式 <code>(c|g|p)ar</code>，表示：小写字母 <code>c</code>、<code>g</code> 或 <code>p</code> 后面跟字母 <code>a</code>，后跟字母 <code>r</code>。</p>
<pre>
"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>
<h2 id="2-6-分支结构">2.6 分支结构</h2>
<p>在正则表达式中垂直条 <code>|</code> 用来定义分支结构，分支结构就像多个表达式之间的条件。现在你可能认为这个字符集和分支结构的工作方式一样。<br>
但是字符集和分支结构巨大的区别是字符集只在字符级别上有作用，然而分支结构在表达式级别上依然可以使用。<br>
例如正则表达式 <code>(T|t)he|car</code>，表示：匹配大写字母 <code>T</code> 或小写字母 <code>t</code>，后面跟小写字母 <code>h</code>，后跟小写字母 <code>e</code>，或匹配小写字母 <code>c</code>，后跟小写字母 <code>a</code>，后跟小写字母 <code>r</code>。</p>
<pre>
"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>
<h2 id="2-7-转义特殊字符">2.7 转义特殊字符</h2>
<p>正则表达式中使用反斜杠 <code>\</code> 来转义下一个字符。这将允许你使用保留字符来作为匹配字符 <code>&#123; &#125; [ ] / \ + * . $ ^ | ?</code>。在特殊字符前面加 <code>\</code>，就可以使用它来做匹配字符。<br>
例如正则表达式 <code>.</code> 是用来匹配除了换行符以外的任意字符。现在要在输入字符串中匹配 <code>.</code> 字符，正则表达式 <code>(f|c|m)at\.?</code>，表示：小写字母 <code>f</code>、<code>c</code> 或者 <code>m</code> 后跟小写字母 <code>a</code>，后跟小写字母 <code>t</code>，后跟可选的 <code>.</code> 字符。</p>
<pre>
"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>
<h2 id="2-8-定位符">2.8 定位符</h2>
<p>在正则表达式中，为了检查匹配符号是否是起始符号或结尾符号，我们使用定位符。<br>
定位符有两种类型：第一种类型是 <code>^</code> 检查匹配字符是否是起始字符，第二种类型是 <code>$</code>，它检查匹配字符是否是输入字符串的最后一个字符。</p>
<h3 id="2-8-1-插入符号">2.8.1 插入符号</h3>
<p>插入符号 <code>^</code> 符号用于检查匹配字符是否是输入字符串的第一个字符。如果我们使用正则表达式 <code>^a</code>（如果 a 是起始符号）匹配字符串 <code>abc</code>，它会匹配到 <code>a</code>。<br>
但是如果我们使用正则表达式 <code>^b</code>，它是匹配不到任何东西的，因为在字符串 <code>abc</code> 中“b”不是起始字符。<br>
让我们来看看另一个正则表达式 <code>^(T|t)he</code>，这表示：大写字母 <code>T</code> 或小写字母 <code>t</code> 是输入字符串的起始符号，后面跟着小写字母 <code>h</code>，后跟小写字母 <code>e</code>。</p>
<pre>
"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>
<pre>
"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>
<h3 id="2-8-2-美元符号">2.8.2 美元符号</h3>
<p>美元 <code>$</code> 符号用于检查匹配字符是否是输入字符串的最后一个字符。例如正则表达式 <code>(at\.)$</code>，表示：小写字母 <code>a</code>，后跟小写字母 <code>t</code>，后跟一个 <code>.</code> 字符，且这个匹配器必须是字符串的结尾。</p>
<pre>
"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>
<pre>
"(at\.)$" => The fat cat sat on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>
<h2 id="3-简写字符集">3. 简写字符集</h2>
<p>正则表达式为常用的字符集和常用的正则表达式提供了简写。简写字符集如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">简写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td>匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td style="text-align:center">\w</td>
<td>匹配所有字母和数字的字符：<code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td style="text-align:center">\W</td>
<td>匹配非字母和数字的字符：<code>[^\w]</code></td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td>匹配数字：<code>[0-9]</code></td>
</tr>
<tr>
<td style="text-align:center">\D</td>
<td>匹配非数字：<code>[^\d]</code></td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td>匹配空格符：<code>[\t\n\f\r\p&#123;Z&#125;]</code></td>
</tr>
<tr>
<td style="text-align:center">\S</td>
<td>匹配非空格符：<code>[^\s]</code></td>
</tr>
</tbody>
</table>
<h2 id="4-断言">4. 断言</h2>
<p>后行断言和先行断言有时候被称为断言，它们是特殊类型的 <em><strong>非捕获组</strong></em>（用于匹配模式，但不包括在匹配列表中）。当我们在一种特定模式之前或者之后有这种模式时，会优先使用断言。<br>
例如我们想获取输入字符串 <code>$4.44 and $10.88</code> 中带有前缀 <code>$</code> 的所有数字。我们可以使用这个正则表达式 <code>(?&lt;=\$)[0-9\.]*</code>，表示：获取包含 <code>.</code> 字符且前缀为 <code>$</code> 的所有数字。<br>
以下是正则表达式中使用的断言：</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">?=</td>
<td>正向先行断言</td>
</tr>
<tr>
<td style="text-align:center">?!</td>
<td>负向先行断言</td>
</tr>
<tr>
<td style="text-align:center">?&lt;=</td>
<td>正向后行断言</td>
</tr>
<tr>
<td style="text-align:center">?&lt;!</td>
<td>负向后行断言</td>
</tr>
</tbody>
</table>
<h3 id="4-1-正向先行断言">4.1 正向先行断言</h3>
<p>正向先行断言认为第一部分的表达式的后面必须是先行断言表达式。返回的匹配结果仅包含与第一部分表达式匹配的文本。<br>
要在一个括号内定义一个正向先行断言，在括号中问号和等号是这样使用的 <code>(?=...)</code>。先行断言表达式写在括号中的等号后面。<br>
例如正则表达式 <code>(T|t)he(?=\sfat)</code>，表示：匹配大写字母 <code>T</code> 或小写字母 <code>t</code>，后面跟字母 <code>h</code>，后跟字母 <code>e</code>。<br>
在括号中，我们定义了正向先行断言，它会引导正则表达式引擎匹配后面跟着 <code>fat</code> 的 <code>The</code> 或 <code>the</code>。</p>
<pre>
"(T|t)he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>
<h3 id="4-2-负向先行断言">4.2 负向先行断言</h3>
<p>当我们需要指定第一部分表达式的后面不跟随某一内容时，使用负向先行断言。负向先行断言的定义跟我们定义的正向先行断言一样，<br>
唯一的区别在于我们使用否定符号 <code>!</code> 而不是等号 <code>=</code>，例如 <code>(?!...)</code>。<br>
我们来看看下面的正则表达式 <code>(T|t)he(?!\sfat)</code>，表示：从输入字符串中获取全部 <code>The</code> 或者 <code>the</code> 且不匹配 <code>fat</code> 前面加上一个空格字符。</p>
<pre>
"(T|t)he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>
<h3 id="4-3-正向后行断言">4.3 正向后行断言</h3>
<p>正向后行断言用于获取跟随在特定模式之后的所有匹配内容。正向后行断言表示为 <code>(?&lt;=...)</code>。例如正则表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code>，表示：从输入字符串中获取在单词 <code>The</code> 或 <code>the</code> 之后的所有 <code>fat</code> 和 <code>mat</code> 单词。</p>
<pre>
"(?<=(T|t)he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.
</=(T|t)he\s)(fat|mat)"></pre>
<h3 id="4-4-负向后行断言">4.4 负向后行断言</h3>
<p>负向后行断言是用于获取不跟随在特定模式之后的所有匹配的内容。负向后行断言表示为 <code>(?&lt;!...)</code>。例如正则表达式 <code>(?&lt;!(T|t)he\s)(cat)</code>，表示：在输入字符中获取所有不在 <code>The</code> 或 <code>the</code> 之后的所有单词 <code>cat</code>。</p>
<pre>
"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.
</pre>
<h2 id="5-标记">5. 标记</h2>
<p>标记也称为修饰符，因为它会修改正则表达式的输出。这些标志可以以任意顺序或组合使用，并且是正则表达式的一部分。</p>
<table>
<thead>
<tr>
<th style="text-align:center">标记</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">i</td>
<td>不区分大小写：将匹配设置为不区分大小写。</td>
</tr>
<tr>
<td style="text-align:center">g</td>
<td>全局搜索：搜索整个输入字符串中的所有匹配。</td>
</tr>
<tr>
<td style="text-align:center">m</td>
<td>多行匹配：会匹配输入字符串每一行。</td>
</tr>
</tbody>
</table>
<h3 id="5-1-不区分大小写">5.1 不区分大小写</h3>
<p><code>i</code> 修饰符用于执行不区分大小写匹配。例如正则表达式 <code>/The/gi</code>，表示：大写字母 <code>T</code>，后跟小写字母 <code>h</code>，后跟字母 <code>e</code>。<br>
但是在正则匹配结束时 <code>i</code> 标记会告诉正则表达式引擎忽略这种情况。正如你所看到的，我们还使用了 <code>g</code> 标记，因为我们要在整个输入字符串中搜索匹配。</p>
<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>
<pre>
"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>
<h3 id="5-2-全局搜索">5.2 全局搜索</h3>
<p><code>g</code> 修饰符用于执行全局匹配（会查找所有匹配，不会在查找到第一个匹配时就停止）。<br>
例如正则表达式 <code>/.(at)/g</code>，表示：除换行符之外的任意字符，后跟小写字母 <code>a</code>，后跟小写字母 <code>t</code>。<br>
因为我们在正则表达式的末尾使用了 <code>g</code> 标记，它会从整个输入字符串中找到每个匹配项。</p>
<pre>
".(at)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.
</pre>
<pre>
"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>
<h3 id="5-3-多行匹配">5.3 多行匹配</h3>
<p><code>m</code> 修饰符被用来执行多行的匹配。正如我们前面讨论过的 <code>(^, $)</code>，使用定位符来检查匹配字符是输入字符串开始或者结束。但是我们希望每一行都使用定位符，所以我们就使用 <code>m</code> 修饰符。<br>
例如正则表达式 <code>/at(.)?$/gm</code>，表示：小写字母 <code>a</code>，后跟小写字母 <code>t</code>，匹配除了换行符以外任意字符零次或一次。而且因为 <code>m</code> 标记，现在正则表达式引擎匹配字符串中每一行的末尾。</p>
<pre>
"/.at(.)?$/" => The fat
                cat sat
                on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>
<pre>
"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>
                  cat <a href="#learn-regex"><strong>sat</strong></a>
                  on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>
<h2 id="常用正则表达式">常用正则表达式</h2>
<ul>
<li><strong>正整数</strong>：<code>^\d+$</code></li>
<li><strong>负整数</strong>：<code>^-\d+$</code></li>
<li><strong>电话号码</strong>：<code>^+?[\d\s]&#123;3,&#125;$</code></li>
<li><strong>电话代码</strong>：<code>^+?[\d\s]+(?[\d\s]&#123;10,&#125;$</code></li>
<li><strong>整数</strong>：<code>^-?\d+$</code></li>
<li><strong>用户名</strong>：<code>^[\w\d_.]&#123;4,16&#125;$</code></li>
<li><strong>字母数字字符</strong>：<code>^[a-zA-Z0-9]*$</code></li>
<li><strong>带空格的字母数字字符</strong>：<code>^[a-zA-Z0-9 ]*$</code></li>
<li><strong>密码</strong>：<code>^(?=^.&#123;6,&#125;$)((?=.*[A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z]))^.*$</code></li>
<li><strong>电子邮件</strong>：<code>^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]&#123;2,4&#125;)*$</code></li>
<li><strong>IPv4 地址</strong>：<code>^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$</code></li>
<li><strong>小写字母</strong>：<code>^([a-z])*$</code></li>
<li><strong>大写字母</strong>：<code>^([A-Z])*$</code></li>
<li><strong>网址</strong>：<code>^(((http|https|ftp):\/\/)?([[a-zA-Z0-9]\-\.])+(\.)([[a-zA-Z0-9]])&#123;2,4&#125;([[a-zA-Z0-9]\/+=%&amp;_\.~?\-]*))*$</code></li>
<li><strong>VISA 信用卡号码</strong>：<code>^(4[0-9]&#123;12&#125;(?:[0-9]&#123;3&#125;)?)*$</code></li>
<li><strong>日期（MM/DD/YYYY）</strong>：<code>^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?[0-9]&#123;2&#125;$</code></li>
<li><strong>日期（YYYY/MM/DD）</strong>：<code>^(19|20)?[0-9]&#123;2&#125;[- /.](0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])$</code></li>
<li><strong>万事达信用卡号码</strong>：<code>^(5[1-5][0-9]&#123;14&#125;)*$</code></li>
</ul>
<h2 id="Contribution">Contribution</h2>
<ul>
<li>Report issues</li>
<li>Open pull request with improvements</li>
<li>Spread the word</li>
</ul>
<h2 id="License">License</h2>
<p>MIT © <a href="mailto:ziishaned@gmail.com">Zeeshan Ahmed</a></p>
<hr>
<p><strong><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-">⬆ top</a></strong></p>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>点触科技笔试记录</title>
    <url>/post/250e7dfe.html</url>
    <content><![CDATA[<h2 id="一：算法，背包问题">一：算法，背包问题</h2>
<p>描述：在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为Ai（i为n个物品的顺序下标），每个物品只能选择一次且物品大小均为正整数。</p>
<p>题解：</p>
<p>public class Solution {<br>
/**<br>
* @param m: An integer m denotes the size of a backpack<br>
* @param A: Given n items with size A[i]<br>
* @return: The maximum size<br>
*/<br>
public int backPack(int m, int[] A) {<br>
// write your code here<br>
int num=A.length;<br>
int[][] dp=new int[num+1][m+1];<br>
for(int i=0;i&lt;=m;i++){<br>
dp[0][i]=0;<br>
}<br>
for(int j=0;j&lt;=num;j++){<br>
dp[j][0]=0;<br>
}<br>
for(int i=1;i&lt;=num;i++){<br>
for(int j=1;j&lt;=m;j++){<br>
if(A[i-1]&lt;=j){<br>
if(dp[i-1][j]&lt;dp[i-1][j-A[i-1]]+A[i-1]){<br>
dp[i][j]=dp[i-1][j-A[i-1]]+A[i-1];<br>
}else{<br>
dp[i][j]=dp[i-1][j];<br>
}<br>
}else{<br>
dp[i][j]=dp[i-1][j];<br>
}<br>
}<br>
}<br>
return dp[num][m];<br>
}<br>
}</p>
<h2 id="二：场景，排行榜设计">二：场景，排行榜设计</h2>
<p>描述：</p>
<p>题解：</p>
<h2 id="三：设计模式，工厂模式">三：设计模式，工厂模式</h2>
<p>描述：比萨制造过程为<strong>准备、烘烤、切片、装盒</strong>，假设有一个比萨店，比萨店能制造<strong>厦门和深圳</strong>两种风格<br>
的比萨，每种风格比萨又分<strong>芝士、素食、蛤蜊、香肠</strong>四种类型，不同风格同种类型的比萨也不相同，用合适的<strong>设计模式</strong>实现这样的比萨店相关功能类。</p>
<p>题解：</p>
<h2 id="四：JS分解statement函数，从函数中分离出不同的关注点">四：JS分解statement函数，从函数中分离出不同的关注点</h2>
<p>描述：</p>
<p>题解：</p>
<h2 id="五：编程">五：编程</h2>
<p>描述：有n篇英文文章，编程实现计算出每篇文章的主题。</p>
<p>解答：</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>离人</title>
    <url>/post/14e24de8.html</url>
    <content><![CDATA[<h2 id="1">1</h2>
<p>不懂事的老小孩，家里人都不关注的笨蛋，忘了给自家孙子上户口的生产队队长，拿自己儿子名字贷款给队里的工程的老不修，“人穷水都穷”连个孙娃子都收拾不干净的老头——以上，就是多年以后还留在我脑海中关于爷爷的全部印象了。</p>
<p>还记得那个三年级的午后，外婆来学校接我，说带我去看爷爷，我懵懵懂懂地跟着去了，看完了，懵懵懂懂地走了，哦，原来是爷爷帮人插秧的时候晕倒了，没抢救回来，于是，我很自然的接受了这样一个事实——爷爷死了，那个编了一天的竹篾拿去换点钱给小孙子买饮料的老头死了。</p>
<p>因为家庭的原因，我从很小的时候就一直是跟着外公外婆家一起生活的，对于这个爷爷，了解也就十分有限。倒不如说，关于他的很多事，很多印象，全是从外公外婆和爸妈口中听来，最后自行拼接而成的。每逢过年，都是必须要要去上坟的，在这个时候，听一听爸妈讲讲他过去的事，听一听爸妈给他讲他走之后他儿孙的事，再祈愿老人家在天之灵给现世的人保佑，在香蜡钱纸燃烧的火光中、在噼里啪啦的鞭炮声中，代际间的传承就就以这样的形式完成了。</p>
<h2 id="2">2</h2>
<p>年龄和脾气之间肯定是有一定关系的，无他，从我自己的经验来看就是这样，从我身边的人变化来看也是这样。</p>
<p>小学的时候吧，我的邻居家有个年龄很大的老太太，她家养了一条老母狗，很凶，真的很凶，每天我去上学从他家门口经过都心惊肉跳，走的次数多了，最后还是没躲过被咬了一回，因此，我对老太太印象也非常不好。</p>
<p>那一年，老太太家的枇杷树结果了，很多很大，我很馋，馋但是不敢。后来，老太太叫我自己上树去摘就是了，小孩子哪能受得了鼓励，坐在树上就开始一顿吃。外公刚干完活回来，见我坐在邻居家的枇杷树上大吃，很生气地叫我下来，我没理他，没想到竟然扔小石子过来，于是，我大哭着回家了。外婆回来，知道了情况，抄起二指宽的篾条就朝外公身上打去，一边打一遍骂，“哪有你这样教育娃娃的，那是拿石头打的吗，不晓得轻重，你看我今天打不打得你好看”。</p>
<p>暴躁，不知轻重，大概就是那时候外公的脾气了。</p>
<p>上高中了，我运气好，在同学的推荐下得到了市高中的青睐，分数上线就要，免学杂费。当时也没有月假一说，法定假期中时间长点的才能回家，于是，回家的次数就这样变少了。奇怪的是，我跟外公这个老头的关系倒是莫名其妙好了很多，好像几天不见这个人就褪去了往日的暴躁，转身拥抱了相反的平和。家里的打米机不好用了，一看是筛子坏了，行，你小子去街上买一张回来吧；今天要抽水去灌那片花生地，走吧，咱爷俩一块把水管和水泵扛过去；读了几天书手脚也没变慢嘛，还阔以，今天就把这片谷子打完了；“人民渠嘛，还是我切修的，当时毛老汉……”；“嗯，东西拿齐没得，武汉也没得好远嘛，当年我也是切过那边了，你切了好生学习哈，上大学了也不是给你放松的，嗯，屋头我晓得，你走嘛”……</p>
<p>平和，宁静，像一坛老酒，这是那时候外公的脾气。</p>
<h2 id="3">3</h2>
<p>一晃又是几年，好似我从未认真看过外公这个老头一样，他怎么一下子这么瘦弱了，弯腰驼背的了，眼神没有往日的犀利，嘴角却含着似有若无的笑意，像村里那口老井，记录了一切但是又将其深深埋在水底，几无人可触达。</p>
<p>前不久爸打电话给我，告诉我外公确诊了胃癌，叫我给家里打个电话好歹问一下，但是我一直不敢往家里打电话，我在害怕，在逃避，害怕自己辜负他们的期待，害怕看见他们的眼神，害怕听见他们的声音，我在逃避自己的责任，但是我又还能再躲多久呢？</p>
<p>曾经我对皮包骨头这个词的印象只停留在字典里，直到我再见到我的外公，那是怎样的一副光景？曾经力担千斤的肌肉再没有一丝一毫留存在这个老人身上，肋骨勾勒出的胸膛就这样毫无遮掩地展现着，同弯曲的脊梁骨一起狰狞地展示着时间的伟力，展示着“病”这一人世间大苦楚的威力，眉头轻蹙的样子像是在忍受着无时无刻不在的痛楚，我简直不忍再看。面对着这一切，我无话可说，我无能为力，世上难道还有什么东西能再换回这个老人的时光吗？</p>
<p>树欲静而风不止，子欲养而亲不待。初闻不识曲中意，再听已是曲中人。罢，珍惜眼前人吧。</p>
<h2 id="end">end</h2>
<p>“真没想到我们在这样一个地方告别，但是跟人告别的时候，还是要用力一点，因为你多说一句，说不定就是最后一句，多看一眼，弄不好就是最后一眼。”——《后会无期》</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>过滤器Filter</title>
    <url>/post/31fabe4c.html</url>
    <content><![CDATA[<h3 id="Filter">Filter</h3>
<h4 id="filter-流程">filter 流程</h4>
<p><img src="/post/31fabe4c/Filter%E6%B5%81%E7%A8%8B.jpg" alt="Filter流程"></p>
<p>一个 http 请求过来之后：</p>
<ul>
<li>首先进入 filter，执行相关业务逻辑</li>
<li>若判定通行，则进入 Servlet 逻辑，Servlet 执行完毕之后，又返回 Filter，最后在返回给请求方</li>
<li>判定失败，直接返回，不需要将请求发给 Servlet</li>
</ul>
<h4 id="应用场景">应用场景</h4>
<ul>
<li>在 filter 层，获取用户的身份</li>
<li>可以考虑在 filter 层做一些常规的校验 (如参数校验，referer 校验、权限控制等)</li>
<li>可以在 filter 层做运维、安全防护相关的工作(如全链路打点，可以在 flter 层分配一个 traceld;也可以在这一层做限流等)</li>
</ul>
<h4 id="使用">使用</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;, filterName = &quot;reqRecordFilter&quot;, asyncSupported = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReqRecordFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">REQ_LOG</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;req&quot;</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回给前端的traceId，用于日志追踪</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GLOBAL_TRACE_ID_HEADER</span> <span class="operator">=</span> <span class="string">&quot;g-trace-id&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GlobalInitService globalInitService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StatisticsSettingService statisticsSettingService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            request = <span class="built_in">this</span>.initReqInfo((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);</span><br><span class="line">            CrossUtil.buildCors(request, (HttpServletResponse) servletResponse);</span><br><span class="line">            filterChain.doFilter(request, servletResponse);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            buildRequestLog(ReqInfoContext.getReqInfo(), request, System.currentTimeMillis() - start);</span><br><span class="line">            <span class="comment">// 一个链路请求完毕，清空MDC相关的变量(如GlobalTraceId，用户信息)</span></span><br><span class="line">            MdcUtil.clear();</span><br><span class="line">            ReqInfoContext.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  	# ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>init：初始化时执行</p>
</li>
<li>
<p>destory： 销毁时执行</p>
</li>
<li>
<p>doFilter：filter 规则命中的请求，都会走进来</p>
</li>
<li>
<ul>
<li>三个参数，注意第三个 FilterChain，这里是经典的责任链设计模式</li>
<li>执行 filterChain.doFilter(servletRequest，servletResponse) 表示会继续将请求执行下去若不执行这一句，表示这一次的 http 请求到此为止了，后面的走不下去了</li>
</ul>
</li>
</ul>
<h4 id="注册（过滤器Filter注册到Spring容器）">注册（过滤器Filter注册到Spring容器）</h4>
<ol>
<li>使用 @WebFilter 注解，标注到自己实现的过滤器上</li>
</ol>
<p>WebFilter 常用属性如下，其中 urIPatterns 最为常用，表示这个 flter 适用于哪些 url 请求(默认场景下全部请求都被拦截)</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>fileName</td>
<td>String</td>
<td>指定过滤器的 name 属性，等价于 <filter-name>。</filter-name></td>
</tr>
<tr>
<td>value</td>
<td>String[]</td>
<td>该属性等价于 urlPatterns 属性，但是两者不应同时使用。</td>
</tr>
<tr>
<td>urlPatterns</td>
<td>String[]</td>
<td>指定一组过滤器的URL匹配模式。等价于<url-pattern>标签。</url-pattern></td>
</tr>
<tr>
<td>srvletNames</td>
<td>String[]</td>
<td>指定过滤器将应用于哪些Servlet。取值是 @WebSerlvet 中的name属性的取值，或者是web.xml中的<servlet-name>的取值。</servlet-name></td>
</tr>
<tr>
<td>dispatcherTypes</td>
<td>DispatcherType</td>
<td>指定过滤器的转发模式，具体取值包括：ASYNC/ERROR/FORWARD/INCLUDE/REQUEST.</td>
</tr>
<tr>
<td>initParams</td>
<td>WebinitParam[]</td>
<td>指定一组过滤器初始化参数，等价于<init-param>标签。</init-param></td>
</tr>
<tr>
<td>asyncSupported</td>
<td>boolean</td>
<td>声明过滤器是否支持异步操作模式，等价于<async-supported>标签。</async-supported></td>
</tr>
<tr>
<td>description</td>
<td>String</td>
<td>该过滤器的描述信息，等价于<description>标签。</description></td>
</tr>
<tr>
<td>displayName</td>
<td>String</td>
<td>该过滤器的显示名，通常配合工具使用，等价于 <display-name> 标签</display-name></td>
</tr>
</tbody>
</table>
<p>使用这个注解时，请注意，需要在<strong>启动类/配置类</strong>上添加 <strong>ServletComponentScan</strong> 注解来启用.</p>
<p><strong>注意点1</strong>：@WebFilter 注解结合@Order 来定义 filter 注解，可能并不会生效。</p>
<p><strong>注意点2</strong>：@WebFilter 声明的Filter，优先级为 2147483647 (最低优先级）。</p>
<ol start="2">
<li>FilterRegistrationBean</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public FilterRegistrationBean&lt;Filter&gt; orderFilter() &#123;</span><br><span class="line">		FilterRegistrationBean&lt;Filter&gt; filter = new FilterRegistrationBean&lt;&gt;();</span><br><span class="line">		filter.setName(&quot;regRecordFilter&quot;);</span><br><span class="line">		filter.seturlPatterns(Arrays.asList(&quot;/**&quot;));</span><br><span class="line">		filter.setFilter(new RegRecordFilter());  //指定优先级</span><br><span class="line">		filter.setorder(-1);</span><br><span class="line">		return filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实例">实例</h4>
<p>技术派中，Filter 应用到了以下几个地方:</p>
<ul>
<li>身份识别，并保存身份到 RegInfoContext 上下文中。详情博文: <a href="https://www.yuque.com/itwanger/az7yww/yk1x4v6wt5gz103q">https://www.yuque.com/itwanger/az7yww/yk1x4v6wt5gz103q</a></li>
<li>记录请求记录，详情博文: <a href="https://www.yuque.com/itwanger/az7yww/wb3pz26699c86nuz">https://www.yuque.com/itwanger/az7yww/wb3pz26699c86nuz</a></li>
<li>添加跨域支持，详情博文: <a href="https://www.yuque.com/itwanger/az7yww/pznv1robndgbuyhh">https://www.yuque.com/itwanger/az7yww/pznv1robndgbuyhh</a></li>
</ul>
<h4 id="filter-在技术派中的应用总结">filter 在技术派中的应用总结</h4>
<p><img src="/post/31fabe4c/Filter%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.png" alt="Filter知识点总结"></p>
<h4 id="最后">最后</h4>
<p><a href="https://github.com/itwanger/paicoding">技术派项目地址</a></p>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>重修之Java基础</title>
    <url>/post/37c82b62.html</url>
    <content><![CDATA[<h2 id="重修之Java基础">重修之Java基础</h2>
<blockquote>
<p>参考：<a href="https://javaguide.cn/java/basis/j">JavaGuide</a></p>
</blockquote>
<h3 id="概念性的东西">概念性的东西</h3>
<ol>
<li>JVM &amp; JDK &amp; JRE</li>
</ol>
<p><img src="/post/37c82b62/JVM&amp;JDK&amp;JRE.png" alt="JVM&amp;JDK&amp;JRE"></p>
<p>JVM大致结构模型：</p>
<p><img src="/post/37c82b62/JVMModel.png" alt="JVMModel"></p>
<ol>
<li>字节码，字节码的好处</li>
</ol>
<p>JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，<strong>只面向虚拟机</strong>。</p>
<ol start="2">
<li>Java编译与解释并存？</li>
</ol>
<p>Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<ol start="3">
<li>JIT和AOT编译</li>
</ol>
<p>AOT（Ahead of Time Compilation）：适合云原生、微服务架构支持，缺少Java动态特性如反射、动态代理、动态加载、JNI（Java native Interface）。<br>
JIT（Just In Time）：</p>
<p>![AOT vs JIT](AOT vs JIT.png)</p>
<p>参考：<a href="https://cn.dubbo.apache.org/zh-cn/blog/2023/06/28/%E8%B5%B0%E5%90%91-native-%E5%8C%96springdubbo-aot-%E6%8A%80%E6%9C%AF%E7%A4%BA%E4%BE%8B%E4%B8%8E%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3/">走向 Native 化：Spring&amp;Dubbo AOT 技术示例与原理讲解</a>、<a href="https://mp.weixin.qq.com/s/4haTyXUmh8m-dBQaEzwDJw">基于静态编译构建微服务应用</a></p>
<ol start="4">
<li>Oracle JDK vs OpenJDK</li>
</ol>
<p>区别：</p>
<p>补充——Oracle JDK vs OpenJDK带来的开源协议：</p>
<ul>
<li>BCL 协议（Oracle Binary Code License Agreement）：可以使用 JDK（支持商用），但是不能进行修改。</li>
<li>OTN 协议（Oracle Technology Network License Agreement）：11 及之后新发布的 JDK 用的都是这个协议，可以自己私下用，但是商用需要付费。</li>
</ul>
<ol start="5">
<li>Java和C++的区别</li>
</ol>
<ul>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li>
<li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li>
</ul>
<h3 id="语法">语法</h3>
<ol>
<li>注释（单行、多行、文档）</li>
<li>标识符&amp;关键字</li>
<li>自增&amp;自减</li>
</ol>
<p>符号在前就先加/减，符号在后就后加/减。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>, c = <span class="number">20</span>;</span><br><span class="line">a = b++; <span class="comment">// a: 10, b: 11</span></span><br><span class="line">a = ++c; <span class="comment">// a: 21, c:21</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>移位运算：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;&lt;</code> :左移运算符，向左移若干位，高位丢弃，低位补零。x &lt;&lt; 1,相当于 x 乘以 2(不溢出的情况下)。</li>
<li><code>&gt;&gt;</code> :<strong>带符号右移</strong>，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。x &gt;&gt; 1,相当于 x 除以 2。</li>
<li><code>&gt;&gt;&gt;</code> :<strong>无符号右移</strong>，忽略符号位，空位都以 0 补齐</li>
</ul>
<blockquote>
<p>移位支持 <strong>int 和 long</strong> 类型，其他的移位计算都是先转型再计算。</p>
<p>位数超过了实际位数，先取余再移位。</p>
</blockquote>
<p>左移的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;初始数据：&quot;</span> + i);</span><br><span class="line">System.out.println(<span class="string">&quot;初始数据对应的二进制字符串：&quot;</span> + Integer.toBinaryString(i));</span><br><span class="line">i &lt;&lt;= <span class="number">10</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;左移 10 位后的数据 &quot;</span> + i);</span><br><span class="line">System.out.println(<span class="string">&quot;左移 10 位后的数据对应的二进制字符 &quot;</span> + Integer.toBinaryString(i));</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>continue、break、return</li>
</ol>
<p>continue：<strong>跳过当次</strong>循环（还在循环体内执行）</p>
<p>break：<strong>跳出</strong>循环，执行循环体下面的了。</p>
<p>return：跳出所在方法；有返回值的方法则return一个特定值（对象）。</p>
<h3 id="数据类型">数据类型</h3>
<ol>
<li>基本类型：</li>
</ol>
<p>Java 中有 8 种基本数据类型，分别为：</p>
<ul>
<li>
<p>6 种数字类型：</p>
<ul>
<li>
<p>4 种整数型：byte、short、int、long</p>
</li>
<li>
<p>2 种浮点型：float、double</p>
</li>
</ul>
</li>
<li>
<p>1 种字符类型：char</p>
</li>
<li>
<p>1 种布尔型：boolean。</p>
</li>
</ul>
<p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>位数</th>
<th>字节</th>
<th>默认值</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>8</td>
<td>1</td>
<td>0</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>short</td>
<td>16</td>
<td>2</td>
<td>0</td>
<td>-32768（-2^15） ~ 32767（2^15 - 1）</td>
</tr>
<tr>
<td>int</td>
<td>32</td>
<td>4</td>
<td>0</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr>
<td>long</td>
<td>64</td>
<td>8</td>
<td>0L</td>
<td>-9223372036854775808（-2^63） ~ 9223372036854775807（2^63 -1）</td>
</tr>
<tr>
<td>char</td>
<td>16</td>
<td>2</td>
<td>‘u0000’</td>
<td>0 ~ 65535（2^16 - 1）</td>
</tr>
<tr>
<td>float</td>
<td>32</td>
<td>4</td>
<td>0f</td>
<td>1.4E-45 ~ 3.4028235E38</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>8</td>
<td>0d</td>
<td>4.9E-324 ~ 1.7976931348623157E308</td>
</tr>
<tr>
<td>boolean</td>
<td>1</td>
<td></td>
<td>false</td>
<td>true、false</td>
</tr>
</tbody>
</table>
<p>这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean 。</p>
<blockquote>
<p>long 类型数值后面加上L（否则作为整型解析）。</p>
<p>char 单引号，String 双引号。</p>
</blockquote>
<ol start="2">
<li>基本类型和包装类型:</li>
</ol>
<p><img src="/post/37c82b62/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8BVS%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B.jpeg" alt="基本类型VS包装类型"></p>
<blockquote>
<p><strong>为什么说是几乎所有对象实例都存在于堆中呢？</strong></p>
<p>这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存。</p>
</blockquote>
<ol start="3">
<li>包装类型的缓存机制</li>
</ol>
<blockquote>
<p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p>
</blockquote>
<p><code>Byte, Short, Integer, Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在  <strong>[0,127]</strong> 范围的缓存数据，Boolean 直接返回 True or False。</p>
<p><code>Integer</code>缓存源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Character</code>缓存源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">      <span class="keyword">return</span> CharacterCache.cache[(<span class="type">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CharacterCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CharacterCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> <span class="title class_">Character</span>[<span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Character</span>((<span class="type">char</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Boolean</code>缓存源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种浮点类型的包装类<code>Float</code>、<code>Double</code>没有实现缓存。</p>
<p>关于比较问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">System.out.pringln(i1 == i2);   <span class="comment">// 输出false。</span></span><br></pre></td></tr></table></figure>
<p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是缓存中的对象。而<code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p>
<p>所以，<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较。</strong></p>
<ol start="4">
<li>自动装箱与拆箱</li>
</ol>
<p>装箱：基本类型用对应的引用类型包装起来。</p>
<p>拆箱：将包装类型转换为基本数据类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br><span class="line">   L1</span><br><span class="line"></span><br><span class="line">    LINENUMBER <span class="number">8</span> L1</span><br><span class="line"></span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    BIPUSH <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">    PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">   L2</span><br><span class="line"></span><br><span class="line">    LINENUMBER <span class="number">9</span> L2</span><br><span class="line"></span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    GETFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">    INVOKEVIRTUAL java/lang/Integer.intValue ()I</span><br><span class="line"></span><br><span class="line">    PUTFIELD AutoBoxTest.n : I</span><br><span class="line"></span><br><span class="line">    RETURN</span><br></pre></td></tr></table></figure>
<p>从字节码中，我们发现装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p>
<p>因此，</p>
<ul>
<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>
<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code></li>
</ul>
<p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 应该使用 long 而不是 Long</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        sum += i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>浮点数运算和精度丢失、解决精度丢失</li>
</ol>
<p>二进制的计算机在表示一个数字时，宽度有限，无限循环小数在表示时只能被截断，导致了精度丢失。<a href="http://kaito-kidd.com/2018/08/08/computer-system-float-point/">计算机系统基础（四）浮点数</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2.0f</span> - <span class="number">1.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1.8f</span> - <span class="number">1.7f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999905</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>使用<code>BigDecimal</code>实现浮点数运算不会造成精度丢失。<a href="https://javaguide.cn/java/basis/bigdecimal.html">BigDecimal 详解</a></p>
<ol start="6">
<li>超过Long整形的大数表示</li>
</ol>
<p><code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</p>
<p>相对于常规整数类型的运算来说，BigInteger 运算的效率会相对较低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + <span class="number">1</span>); <span class="comment">// -9223372036854775808</span></span><br><span class="line">System.out.println(l + <span class="number">1</span> == Long.MIN_VALUE); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="变量">变量</h3>
<ol>
<li>成员变量与局部变量</li>
</ol>
<p><img src="/post/37c82b62/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8Fvs%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F.jpeg" alt="成员变量vs局部变量"></p>
<p>默认值：</p>
<ul>
<li>避免访问随机初始值造成意外</li>
<li>成员变量运行时可借助反射等方法手动赋值，局部变量不行。</li>
<li>编译器容易检测局部变量初始值有无，对于可能运行时赋值的成员变量则不好处理，因此赋默认值便于编译。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法中的局部变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        System.out.println(num1);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的方法中的局部变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(<span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> num2 + <span class="number">10</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法中的局部变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VariableExample</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// 对成员变量进行赋值</span></span><br><span class="line">        <span class="built_in">this</span>.age = age; <span class="comment">// 对成员变量进行赋值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello, &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;!&quot;</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        System.out.println(num3);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>静态变量</li>
</ol>
<ul>
<li>static 修饰。</li>
<li>只分配一次内存，被类的所有实例共享。</li>
<li>通过类名访问。</li>
<li>通常情况下，静态变量会被 final 关键字修饰成为常量。</li>
</ul>
<ol start="3">
<li>字符型常量和字符串常量</li>
</ol>
<ul>
<li><strong>形式</strong> : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</li>
<li><strong>含义</strong> : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。</li>
<li><strong>占内存大小</strong>：字符常量只占 2 个字节; 字符串常量占若干个字节。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExample</span> &#123;</span><br><span class="line">    <span class="comment">// 字符型常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span> <span class="variable">LETTER_A</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GREETING_MESSAGE</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;字符型常量占用的字节数为：&quot;</span>+Character.BYTES);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串常量占用的字节数为：&quot;</span>+GREETING_MESSAGE.getBytes().length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法">方法</h3>
<ol>
<li>方法类型和方法返回值</li>
</ol>
<p>返回值：接收方法运行结果，用于进行后续处理。</p>
<p>按参数和返回值类型，可分类：无参数无返回值的方法、有参数无返回值的方法、有返回值无参数的方法、有返回值有参数的方法。</p>
<ol start="2">
<li>静态方法为什么不能调用非静态成员？</li>
</ol>
<ul>
<li>静态方法属于类，类加载时分配内存（只此一次），类名直接访问。非静态成员属于对象实例，只有实例化之后才存在，因此需要通过类的实例对象去访问。</li>
<li>静态方法先于非静态成员存在（类加载），调用不存在的非静态成员是非法操作。</li>
</ul>
<ol start="3">
<li>静态方法&amp;实例方法</li>
</ol>
<ul>
<li>
<p>调用方式：</p>
</li>
<li>
<p><code>类名.方法名</code> 或者 <code>对象.方法名</code>。（即<strong>静态方法调用无需创建对象</strong>。）</p>
</li>
<li>
<p><code>对象.方法名</code>。</p>
</li>
<li>
<p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p>
</li>
</ul>
<ol start="4">
<li>重写&amp;重载</li>
</ol>
<blockquote>
<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>
<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，就要覆盖父类方法。</p>
</blockquote>
<p><strong>重载</strong>：发生在同一个类（or父类和子类之间）中，<strong>多个同名方法根据不同的传参来执行不同的逻辑处理</strong>。方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<p><strong>重写</strong>：<strong>子类对父类方法的重新改造，为了适应子类内部的处理逻辑</strong>。</p>
<blockquote>
<p>重写遵循原则：</p>
<ul>
<li>两同”即方法名相同、形参列表相同；</li>
<li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li>
<li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li>
</ul>
</blockquote>
<p>重写的<strong>返回值类型</strong>：如果方法的返回类型是 <strong>void 和基本数据类型</strong>，则返回值重写时<strong>不可修改</strong>。但是如果方法的返回值是<strong>引用类型</strong>，重写时是<strong>可</strong>以返回该<strong>引用类型的子类的</strong>。</p>
<ol start="5">
<li>可变长参数</li>
</ol>
<ul>
<li>调用方法时传入不定长度的参数。</li>
<li>只可作为函数的最后一个参数，其前面可以有多个参数。</li>
<li><strong>遇到方法重载，优先匹配固定参数的方法。</strong></li>
</ul>
<h3 id="面向对象">面向对象</h3>
<ol>
<li>面向对象（三大特征） vs 面向过程</li>
</ol>
<p>解决问题的方式：过程拆解成方法，用方法去解决问题；抽象出对象，对象执行方法解决问题。</p>
<p>面向对象的三大特征：</p>
<ul>
<li>
<p>继承：</p>
<ul>
<li>
<p>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</p>
</li>
<li>
<p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。子</p>
</li>
<li>
<p>类可以用自己的方式实现父类的方法。</p>
</li>
</ul>
</li>
<li>
<p>封装：把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p>
</li>
<li>
<p>多态：表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>
<ul>
<li>
<p>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</p>
</li>
<li>
<p>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</p>
</li>
<li>
<p>多态不能调用“只在子类存在但在父类不存在”的方法；</p>
</li>
<li>
<p>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</p>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>对象实体、对象引用（强 软 弱 虚）</li>
</ol>
<p><code>new</code>创建对象实例（内存中），对象引用指向对象实例（栈内存中）。</p>
<ul>
<li>一个对象引用可以指向 0 个或 1 个对象；</li>
<li>一个对象可以有 n 个引用指向它。</li>
</ul>
<p>对象相等和引用相等：</p>
<ul>
<li>对象的相等一般比较的是内存中<strong>存放的内容</strong>是否相等。</li>
<li>引用相等一般比较的是他们<strong>指向的内存地址</strong>是否相等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">// 使用 == 比较字符串的引用相等</span></span><br><span class="line">System.out.println(str1 == str2);  <span class="comment">// false</span></span><br><span class="line">System.out.println(str1 == str3);  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 使用 equals 方法比较字符串的相等</span></span><br><span class="line">System.out.println(str1.equals(str2));  <span class="comment">// true</span></span><br><span class="line">System.out.println(str1.equals(str3));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>引用类型：</p>
<ul>
<li>强：<code>Object obj = new Object();</code>强引用保持对象的完整生命周期，只有当引用被明确地设置为 null 或超出范围时，对象才会被垃圾回收器回收。</li>
<li>软：<code>SoftReference</code>类表示，JVM内存不足，软引用指向的对象可能被自动回收。</li>
<li>弱：<code>WeakReference</code>类。如果只有弱引用指向对象，那么对象在下一次垃圾回收时会被立即回收。</li>
<li>虚：<code>PhantomReference</code> 类来表示。虚引用主要用于跟踪对象被垃圾回收器回收的时机，并让程序知道对象已经被回收。虚引用无法直接访问对象，也无法阻止对象被垃圾回收。</li>
</ul>
<ol start="3">
<li>类的构造方法</li>
</ol>
<ul>
<li>与类同名、没有返回值但不能用 void 声明构造函数、生成类对象自动执行。</li>
<li><strong>不能被重写</strong>，可以被<strong>重载</strong>。</li>
</ul>
<ol start="4">
<li>接口 &amp; 抽象类</li>
</ol>
<ul>
<li>
<p>同：不能被实例化、可包含抽象方法、可包含默认实现方法。</p>
</li>
<li>
<p>异：</p>
<ul>
<li>
<p>接口对类的行为进行约束，实现了某个接口就具有了对应的行为。抽象类主要是为了代码复用，强调所属关系。</p>
</li>
<li>
<p>一个雷只能继承一个类，可以实现多个接口。</p>
</li>
<li>
<p>接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</p>
</li>
</ul>
</li>
</ul>
<ol start="5">
<li>深拷贝 &amp; 浅拷贝</li>
</ol>
<ul>
<li>浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>
<li>深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li>
<li>引用拷贝：两个不同的引用指向同一个对象。</li>
</ul>
<p>浅拷贝：</p>
<p>从输出结构就可以看出， person1 的克隆对象和 person1 使用的仍然是同一个 Address 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>
<p>深拷贝：</p>
<p>从输出结构就可以看出，显然 person1 的克隆对象和 person1 包含的 Address 对象已经是不同的了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>
<p><img src="/post/37c82b62/%E4%B8%89%E7%A7%8D%E6%8B%B7%E8%B4%9D%E5%AF%B9%E6%AF%94.png" alt="三种拷贝对比"></p>
<h3 id="Object">Object</h3>
<ol>
<li>Object 类常见方法</li>
</ol>
<p>Object 是所有类的父类，常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>== 和 equals()</li>
</ol>
<p><code>== </code>对于基本类型和引用类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，== 比较的是值。</li>
<li>对于引用数据类型来说，== 比较的是对象的内存地址。</li>
</ul>
<blockquote>
<p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</blockquote>
<p>equals() 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类，因此所有的类都有equals()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object 类 equals() 方法：<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>equals() 方法存在两种使用情况：</p>
<ul>
<li><strong>类没有重写 equals()方法</strong>：通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 Object类equals()方法。</li>
<li><strong>类重写了 equals()方法</strong>：一般我们都重写 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<p>String 中的 equals 方法是被重写过的，因为 Object 的 equals 方法是比较的对象的内存地址，而 <strong>String 的 equals 方法比较的是对象的值</strong>。当创建 String 类型的对象时，虚拟机会在<strong>常量池</strong>中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>hashCode()</li>
</ol>
<p>hashCode() 的作用是获取哈希码（int 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。散列表（用到了散列码）存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”</strong>。</p>
<p>为何需要<code>hashCode()</code>?</p>
<p>hashCode() 和 equals()都是用于比较两个对象是否相等。在一些容器中（HashMap、HashSet），当同样的hashCode 有多个对象，它会继续使用 equals 来判断是否真的相同，即 hashCode 缩小了查找成本。hashCode 和 equals 缺一不可，因为 hashCode 相等的不代表两个对象相等（如上一句所示）。</p>
<ul>
<li>如果两个对象的hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。</li>
<li>如果两个对象的hashCode 值相等并且equals()方法也返回 true，我们才认为这两个对象相等。</li>
<li>如果两个对象的hashCode 值不相等，我们就可以直接认为这两个对象不相等。</li>
</ul>
<ol start="4">
<li>重写 equals 必须重写 hashCode()</li>
</ol>
<p>因为两个相等的对象的 hashCode 值必须是相等。也就是说如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。</p>
<p>如果重写 equals() 时没有重写 hashCode() 方法的话就可能会导致 equals 方法判断是相等的两个对象，hashCode 值却不相等。</p>
<p>思考：重写 equals() 时没有重写 hashCode() 方法的话，使用 HashMap 可能会出现什么问题。</p>
<p>总结：</p>
<ul>
<li>equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。</li>
<li>两个对象有相同的 hashCode 值，他们也不一定是相等的（哈希碰撞）。</li>
</ul>
<h3 id="String">String</h3>
<ol>
<li><code>String</code>`StringBuffer<code>\</code>StringBuilder`</li>
</ol>
<ul>
<li>可变性——String 是不可变的。StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，不过没有使用 final 和 private 关键字修饰，最关键的是这个 AbstractStringBuilder 类还提供了很多修改字符串的方法比如 append 方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>线程安全性——String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</li>
<li>性能——每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li>
</ul>
<blockquote>
<p>操作少量的数据: 适用 String</p>
<p>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder</p>
<p>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</p>
</blockquote>
<ol start="2">
<li>String 不可变</li>
</ol>
<blockquote>
<ol>
<li>保存字符串的数组被 final 修饰且为私有的，并且 String 类没有提供/暴露修改这个字符串的方法。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>String 类被 final 修饰导致其不能被继承，从而避免子类破坏 String 不可变性。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java9 之后，String、StringBuilder、StringBuffer 的实现改用 byte 数组存放字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">// @Stable 注解表示变量最多被修改一次，称为“稳定的”。</span></span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原因：<a href="https://openjdk.java.net/jeps/254">官方介绍</a></p>
<p><img src="/post/37c82b62/Java9%E6%94%B9%E7%94%A8byte%E5%AD%98%E5%82%A8String.png" alt="Java9改用byte存储String"></p>
<ol start="3">
<li>字符串拼接：“+” vs StringBuilder</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;he&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;llo&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2 + str3;</span><br></pre></td></tr></table></figure>
<p>字节码：</p>
<p><img src="/post/37c82b62/+%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt="+拼接字符串"></p>
<p>Java字符串对象的<code>+</code>拼接方式，实际上是通过<code>StringBuilder</code>的<code>append()</code>方法实现的，拼接完成之后调用<code>toString()</code>得到一个 String 对象。</p>
<p>——因此，在编译器不会创建一个<code>StringBuilder</code>以复用的情况下，在循环中使用<code>+</code>会导致创建大量<code>StringBuilder</code>对象，影响性能。</p>
<p>——在JDK9中，<code>+</code>改为<code>makeConcatWithConstants()</code>来实现，避免 StringBuilder 临时对象的产生（参见：<a href="https://openjdk.org/jeps/280">JEP 280</a>），即可以使用<code>+</code>拼接对象了，而非一直<code>StringBuilder</code>。</p>
<ol start="4">
<li><code>String.equals()</code> 和 <code>Object.equals()</code></li>
</ol>
<ul>
<li>String 中的 equals 方法是被重写过的，比较的是 String 字符串的值是否相等。</li>
<li>Object 的 equals 方法是比较的对象的内存地址。</li>
</ul>
<ol start="5">
<li>字符串常量池</li>
</ol>
<p>字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(aa==bb);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li><code>String s1 = new String(&quot;abc&quot;) </code>创建的对象</li>
</ol>
<p>这行代码创建了一个或两个对象。</p>
<ul>
<li>
<ol>
<li>如果字符串常量池中不存在字符串对象“abc”的引用，那么它将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);  <span class="comment">// JDK 1.8</span></span><br></pre></td></tr></table></figure>
<p>对应的字节码：</p>
<p>![new String 语句创建的对象1](new String 语句创建的对象1.png)</p>
<p>ldc 命令用于判断字符串常量池中是否保存了对应的字符串对象的引用，如果保存了的话直接返回，如果没有保存的话，会在堆中创建对应的字符串对象并将该字符串对象的引用保存到字符串常量池中。</p>
<ul>
<li>
<ol start="2">
<li>如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串常量池中已存在字符串对象“abc”的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">// 下面这段代码只会在堆中创建 1 个字符串对象“abc”</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>字节码：</p>
<p>![new String 语句创建的对象2](new String 语句创建的对象2.png)</p>
<ol start="7">
<li><code>String.itern</code></li>
</ol>
<p>String.intern() 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li>
<li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”Java“</span></span><br><span class="line"><span class="comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="comment">// 会在堆中在单独创建一个字符串对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s3.intern();</span><br><span class="line"><span class="comment">// s1 和 s2 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// s3 和 s4 指向的是堆中不同的对象</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// s1 和 s4 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<ol start="8">
<li>String类型变量和常量做“+”运算（<strong>Todo</strong>）</li>
</ol>
<p>字符串拼接。（字符串拼接在编译器中的优化措施，待看。）</p>
<h3 id="异常">异常</h3>
<p><img src="/post/37c82b62/%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB.png" alt="异常分类"></p>
<ol>
<li>Exception 和 Error 区别</li>
</ol>
<ul>
<li>Exception：程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li>
<li>Error：Error 属于程序无法处理的错误 ，不建议通过catch捕获 。例如 Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<ol start="2">
<li>Checked Exception 和 Unchecked Exception</li>
</ol>
<ul>
<li>Checked Exception：在编译时若没有经过 catch 捕获或者 throws 处理，无法编译通过。</li>
<li>Unchecked Exception：不处理也可编译通过。</li>
</ul>
<p>RuntimeException 及其子类都统称为非受检查异常，常见的有：</p>
<ul>
<li>NullPointerException(空指针错误)</li>
<li>IllegalArgumentException(参数错误比如方法入参类型错误)</li>
<li>NumberFormatException（字符串转换为数字格式错误，IllegalArgumentException的子类）</li>
<li>ArrayIndexOutOfBoundsException（数组越界错误）</li>
<li>ClassCastException（类型转换错误）</li>
<li>ArithmeticException（算术错误）</li>
<li>SecurityException （安全错误比如权限不够）</li>
<li>UnsupportedOperationException(不支持的操作错误比如重复创建同一用户)</li>
</ul>
<ol start="3">
<li>Throwable 类常用方法</li>
</ol>
<ul>
<li>String getMessage(): 返回异常发生时的简要描述</li>
<li>String toString(): 返回异常发生时的详细信息</li>
<li>String getLocalizedMessage(): 返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage()返回的结果相同</li>
<li>void printStackTrace(): 在控制台上打印 Throwable 对象封装的异常信息</li>
</ul>
<ol start="4">
<li>try-catch-finally</li>
</ol>
<ul>
<li>try块：用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li>
<li>catch块：用于处理 try 捕获到的异常。</li>
<li>finally 块：无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：<strong>不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p>
</blockquote>
<p>finally 块代码不会被执行的情况：</p>
<ul>
<li>finally 之前虚拟机被终止运行</li>
<li>程序所在线程死亡</li>
<li>关闭CPU</li>
</ul>
<p>补充：从字节码角度分析try catch finally这个语法糖背后的实现原理。（Todo）</p>
<ol start="5">
<li><strong>try-with-resource</strong></li>
</ol>
<p>适用范围（资源的定义）： 任何实现 java.lang.AutoCloseable或者 java.io.Closeable 的对象。</p>
<p>关闭资源和 finally 块的执行顺序： 在 try-with-resources 语句中，任何 catch 或 finally 块在声明的资源关闭后运行。</p>
<p>Java 中类似于 InputStream、OutputStream、Scanner、PrintWriter 等的资源都需要我们调用close()方法来手动关闭，一般情况下我们都是通过try-catch-finally语句来实现这个需求，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="literal">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>注意点：</li>
</ol>
<ul>
<li>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li>
<li>抛出的异常信息一定要有意义。</li>
<li>建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出NumberFormatException而不是其父类IllegalArgumentException。</li>
<li>使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。</li>
</ul>
<h3 id="泛型">泛型</h3>
<ol>
<li>是什么、作用</li>
</ol>
<p>泛型（Generics）是Java中引入的一种<strong>类型参数化的机制</strong>。它允许在定义类、接口和方法时使用一个或多个类型参数，以增强代码的可重用性、类型安全性和代码的清晰度。</p>
<ol start="2">
<li>使用方式</li>
</ol>
<p>泛型类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化：</span></span><br><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure>
<p>泛型接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口：不指定类型、指定类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span></span><br><span class="line">   &#123;</span><br><span class="line">         <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">            System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="comment">// 创建不同类型数组：Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>使用场景（举例来说）</li>
</ol>
<ul>
<li>自定义接口通用返回结果 CommonResult<T> 通过参数 T 可根据具体的返回类型动态指定结果的数据类型</T></li>
<li>定义 Excel 处理类 ExcelUtil<T> 用于动态指定 Excel 导出的数据类型</T></li>
<li>构建集合工具类（参考 Collections 中的 sort, binarySearch 方法）</li>
</ul>
<h3 id="反射">反射</h3>
<ol>
<li>是什么、怎么用</li>
</ol>
<p>反射被称为框架的灵魂，因为它赋予了我们在<strong>运行时分析类以及执行类中方法的能力</strong>。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p>
<p>缺点：安全性问题——可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。性能稍差点（<a href="https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow">Java Reflection: Why is it so slow? </a>）。</p>
<p><strong>应用</strong>：</p>
<ul>
<li>框架中大量使用动态代理，而<strong>动态代理的实现依赖于反射</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注解</strong>的实现也用到了反射。（基于反射分析类，获取 类/属性/方法/方法的参数 上的注解。）</li>
</ul>
<h3 id="注解">注解</h3>
<ol>
<li>是什么</li>
</ol>
<p>Annotation （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p>
<p>注解本质是一个继承了Annotation 的特殊接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>注解的解析方式</li>
</ol>
<ul>
<li><strong>编译期直接扫描</strong>：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用@Override 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>
<li><strong>运行期通过反射处理</strong>：像框架中自带的注解(比如 Spring 框架的 @Value、@Component)都是通过反射来进行处理的。</li>
</ul>
<h3 id="SPI">SPI</h3>
<ol>
<li>SPI是什么</li>
</ol>
<p>SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。</p>
<p>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</p>
<p>很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。</p>
<ol start="2">
<li>SPI &amp; API</li>
</ol>
<p>一般模块之间都是通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。</p>
<p>当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。</p>
<p>当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。</p>
<h3 id="IO">IO</h3>
<p><img src="/post/37c82b62/JavaIO.png" alt="JavaIO"></p>
<ol>
<li>IO 流</li>
</ol>
<p>IO 流在 Java 中分为<strong>输入流和输出流</strong>，而根据数据的处理方式又分为<strong>字节流和字符流</strong>。</p>
<p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<ol start="2">
<li>为何分字节流和字符流？</li>
</ol>
<blockquote>
<p>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</p>
</blockquote>
<p>个人认为主要有两点原因：</p>
<ul>
<li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时；</li>
<li>如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题。</li>
</ul>
<ol start="3">
<li>IO中使用的设计模式</li>
</ol>
<p><a href="https://javaguide.cn/java/io/io-design-patterns.html">Java IO 设计模式总结</a></p>
<ol start="4">
<li>BIO、NIO、AIO</li>
</ol>
<p><a href="https://javaguide.cn/java/io/io-model.html">Java IO 模型详解 </a><br>
<a href="https://javabetter.cn/nio/BIONIOAIO.html">一文彻底解释清楚Java 中的NIO、BIO和AIO</a></p>
<h3 id="序列化、反序列化">序列化、反序列化</h3>
<ol>
<li>序列化和反序列化</li>
</ol>
<p>是什么：</p>
<ul>
<li>序列化：将数据结构或对象转换成二进制字节流的过程</li>
<li>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>
</ul>
<p>应用场景：</p>
<ul>
<li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li>
<li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li>
<li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li>
<li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li>
</ul>
<blockquote>
<p>即：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p>
</blockquote>
<ol start="2">
<li>不想进行序列化的字段的处理方式</li>
</ol>
<p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p>
<p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。</p>
<p>关于 transient 还有几点注意：</p>
<ul>
<li>transient 只能修饰变量，不能修饰类和方法</li>
<li>。transient 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 int 类型，那么反序列后结果就是 0。</li>
<li>static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。</li>
</ul>
<ol start="3">
<li>序列化协议</li>
</ol>
<p>JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。</p>
<p>比较常用的序列化协议有 <strong>Hessian、Kryo、Protobuf、ProtoStuff</strong>，这些都是基于<strong>二进制</strong>的序列化协议。</p>
<p>像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。</p>
<ol start="4">
<li>JDK自带的序列化？</li>
</ol>
<ul>
<li>不支持跨语言调用 : 如果调用的是其他语言开发的服务的时候就不支持了。</li>
<li>性能差：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>
<li>存在安全问题：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。</li>
</ul>
<h3 id="语法糖">语法糖</h3>
<ol>
<li>是什么、有哪些</li>
</ol>
<p><strong>语法糖（Syntactic sugar）</strong> 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。</p>
<p>举个例子，Java 中的 for-each 就是一个常用的语法糖，其原理其实就是基于普通的 for 循环和迭代器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strs = &#123;<span class="string">&quot;JavaGuide&quot;</span>, <span class="string">&quot;公众号：JavaGuide&quot;</span>, <span class="string">&quot;博客：https://javaguide.cn/&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">  	System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，JVM 其实并不能识别语法糖，Java 语法糖要想被正确执行，需要先通过编译器进行解糖，也就是在程序编译阶段将其转换成 JVM 认识的基本语法。这也侧面说明，<strong>Java 中真正支持语法糖的是 Java 编译器而不是 JVM</strong>。如果你去看com.sun.tools.javac.main.JavaCompiler的源码，你会发现在compile()中有一个步骤就是调用desugar()，这个方法就是负责解语法糖的实现的。</p>
<blockquote>
<p>Java 中最常用的语法糖主要有泛型、自动拆装箱、变长参数、枚举、内部类、增强 for 循环、try-with-resources 语法、lambda 表达式等。</p>
</blockquote>
<h2 id="重点">重点</h2>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
