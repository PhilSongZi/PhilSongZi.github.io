<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Wetab</title>
    <url>/post/32e2265d.html</url>
    <content><![CDATA[<blockquote>
<p>Wetab笔记，给你更好的笔记体验</p>
<p>这里是<a href="https://www.wetab.link">Wetab新标签官网</a> (右键点击打开链接)</p>
</blockquote>
<p>以下特性可以为你的笔记带来非常棒的体验：</p>
<ul>
<li>
<p>[x] 📝 <strong>所见即所得的 Markdown</strong> - 以一种优雅的方式编写 markdown</p>
</li>
<li>
<p>[x] 👍 <strong>Emoji</strong> - 支持 emoji 快捷指令和选择器</p>
</li>
<li>
<p>[x] 💾 <strong>剪贴板</strong> - 支持 markdown 格式的复制粘贴</p>
</li>
<li>
<p>[x] ⌨️ <strong>换行模式</strong> - 你可以使用“Enter”和“Shift + Enter”两种方式进行换行</p>
</li>
<li>
<p>[x] ⚡ <strong>斜线指令</strong> - 在空白处输入状态下通过“/”可以完成丰富的输入指令</p>
</li>
<li>
<p>[x] 🧮 <strong>数学支持</strong> - 你可以完成数学公式的描写</p>
</li>
<li>
<p>[x] 📊 <strong>表格支持</strong> - 拥有流畅的 ui 的表格支持</p>
</li>
<li>
<p>[x] 📰 <strong>图表支持</strong> - 基于<a href="https://mermaid-js.github.io/mermaid/#/">mermaid</a>的图表支持</p>
</li>
</ul>
<hr>
<p>你可以添加行内代码例如 <code>inline code</code> 和代码块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips: 使用<code>Mod-Enter</code>来退出块级元素，例如代码块。</p>
</blockquote>
<hr>
<p>你可以输入<code>||</code>和一个空格来创建表格：</p>
<table>
<thead>
<tr>
<th style="text-align:left">表头 1</th>
<th style="text-align:center">表头 2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">内容 1</td>
<td style="text-align:center"><s>内容 1</s></td>
</tr>
<tr>
<td style="text-align:left">内容 2</td>
<td style="text-align:center"><strong>内容</strong> 2</td>
</tr>
</tbody>
</table>
<hr>
<p>数学公式通过 <a href="https://en.wikipedia.org/wiki/TeX">TeX 表达式</a>支持。</p>
<p>这里我们有行内公式： $E = mc^2$，你可以点击并编辑它。</p>
<p>数学公式块也是支持的。</p>
<p>$$<br>
\begin{aligned}<br>
T( (v_1 + v_2) \otimes w) &amp;= T(v_1 \otimes w) + T(v_2 \otimes w) \<br>
T( v \otimes (w_1 + w_2)) &amp;= T(v \otimes w_1) + T(v \otimes w_2) \<br>
T( (\alpha v) \otimes w ) &amp;= T( \alpha ( v \otimes w) ) \<br>
T( v \otimes (\alpha w) ) &amp;= T( \alpha ( v \otimes w) ) \<br>
\end{aligned}<br>
$$</p>
<p>你可以输入<code>$$</code>和一个空格来创建数学公式块。</p>
<hr>
<p>使用 <a href="https://www.webfx.com/tools/emoji-cheat-sheet/">emoji 快捷指令</a> 例如 <code>:+1:</code> 来添加 emoji.</p>
<p>在输入时，你也许注意到了 emoji 过滤器，尝试输入<code>:baby</code>来查看它。</p>
<hr>
<p>你可以输入 <code>```mermaid</code> 来添加图表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    EditorState--&gt;EditorView;</span><br><span class="line">    EditorView--&gt;DOMEvent;</span><br><span class="line">    DOMEvent--&gt;Transaction;</span><br><span class="line">    Transaction--&gt;EditorState;</span><br></pre></td></tr></table></figure>
<hr>
<p>Wetab笔记基于 <a href="https://milkdown.dev/">Milkdown</a> 完成</p>
]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>MYDB记录</title>
    <url>/post/7e29e8fb.html</url>
    <content><![CDATA[<h2 id="1-clone-本地运行">1. clone&amp;本地运行</h2>
<h3 id="1-1-环境">1.1. 环境</h3>
<ul>
<li>jdk：17.07</li>
<li>maven：3.9.2</li>
<li>os：windows 11</li>
</ul>
<h3 id="1-2-运行前设置">1.2. 运行前设置</h3>
<ul>
<li>手动创建数据库文件夹 tmp/mydb。（在项目目录下。）</li>
</ul>
<h3 id="1-3-问题">1.3. 问题</h3>
<ol>
<li>java.lang.ClassNotFoundException: “top.guoziyang.mydb.backend.Launcher”</li>
</ol>
<p>解决：IDEA中设置运行时参数。<a href="https://github.com/CN-GuoZiyang/MYDB/issues/3">参考</a></p>
<p><img src="/post/7e29e8fb/IDEA%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE.png" alt="IDEA参数设置"></p>
<h3 id="1-4-效果">1.4 效果</h3>
<p><img src="/post/7e29e8fb/MYDB%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C.png" alt="MYDB运行效果"></p>
<h2 id="2-文档先行：整体架构">2. 文档先行：整体架构</h2>
<h3 id="整体架构">整体架构</h3>
<h4 id="前端（客户端）">前端（客户端）</h4>
<p>读取用户输入，发送到后端执行，输出返回结果。等待下一次输入。</p>
<h4 id="SQL解析器（后面补充）">SQL解析器（后面补充）</h4>
<p>解析SQL，包装成对应的对象。</p>
<h4 id="后端">后端</h4>
<p>解析SQL，若合法，尝试执行并返回结果。</p>
<p>模块划分：各个模块通过接口向其依赖的模块提供方法</p>
<ol>
<li>Transaction Manager（TM）</li>
<li>Data Manager（DM）</li>
<li>Version Manager（VM）</li>
<li>Index Manager（IM）</li>
<li>Table Manager（TBM）</li>
</ol>
<p>五个模块的依赖图如下，拓补排序得出实现顺序为：TM -&gt; DM -&gt; VM -&gt; IM -&gt; TBM</p>
<p><img src="/post/7e29e8fb/%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96%E5%9B%BE.png" alt="模块依赖图"></p>
<p>各个模块的职责：</p>
<ol>
<li>TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。</li>
<li>DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：1) 分页管理 DB 文件，并进行缓存；2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。</li>
<li>VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。</li>
<li>IM 实现了基于 B+ 树的索引，目前 where 只支持已索引字段。</li>
<li>TBM 实现了对字段和表的管理。同时，解析 SQL 语句，并根据语句操作表。</li>
</ol>
<h2 id="3-Transaction-Manager（TM）">3. Transaction Manager（TM）</h2>
<p>TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。</p>
<h3 id="XID-文件">XID  文件</h3>
<p>XID 文件规则：</p>
<p>每个事物都有一个 xid，这个 ID 是一个事务的<strong>唯一标识</strong>。事务的 xid 从 <strong>1</strong> 开始编号，自增，不可重复。规定 xid 为 0 的事务是超级事务（super transaction），想在没有申请事务的情况下进行一些操作时，可将操作的 xid 设置为 0，超级事务的状态一直是 committed。</p>
<p>MYDB 中事务的状态：</p>
<ol>
<li>active，进行中</li>
<li>committed，已提交</li>
<li>aborted，已撤销（回滚）</li>
</ol>
<p>XID 文件内容的结构：</p>
<ol>
<li>给每个事务分配<strong>一个字节</strong>的空间来保存其<strong>状态</strong>。</li>
<li>XID 文件头部保存一个 <strong>8 字节数字</strong>，记录此 XID 文件管理<strong>事务的个数</strong>。</li>
<li>事务 xid 在文件中的状态存储位置在 <strong>(xid-1)+8 字节处</strong>。（xid-1 是因为 xid 为 0 的状态不需要记录。）</li>
</ol>
<h3 id="TransactionManager">TransactionManager</h3>
<p>提供的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">begin</span><span class="params">()</span>;                       <span class="comment">// 开启一个新事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span>;              <span class="comment">// 提交一个事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">long</span> xid)</span>;               <span class="comment">// 取消一个事务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">(<span class="type">long</span> xid)</span>;         <span class="comment">// 查询一个事务的状态是否是正在进行的状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCommitted</span><span class="params">(<span class="type">long</span> xid)</span>;      <span class="comment">// 查询一个事务的状态是否是已提交</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAborted</span><span class="params">(<span class="type">long</span> xid)</span>;        <span class="comment">// 查询一个事务的状态是否是已取消</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;                       <span class="comment">// 关闭TM</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据定义的 XID 文件结构，得到需要定义的一些常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XID文件头长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LEN_XID_HEADER_LENGTH</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 每个事务的占用长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">XID_FIELD_SIZE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 事务的三种状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_ACTIVE</span>   <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_COMMITTED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_ABORTED</span>  <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 超级事务，永远为commited状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SUPER_XID</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// XID 文件后缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">XID_SUFFIX</span> <span class="operator">=</span> <span class="string">&quot;.xid&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>在构造函数创建了一个 TransactionManager 之后，首先要对 XID 文件进行校验，以保证这是一个合法的 XID 文件。校验的方式是通过文件头的 8 字节数字反推文件的理论长度，与文件的实际长度做对比。如果不同则认为 XID 文件不合法。当校验不通过时，调用自定义方法强制停机。</p>
<p><code>begin()</code>方法：开启一个事务——</p>
<ul>
<li>首先设置 xidCounter+1 事务的状态为 committed，</li>
<li>然后 xidCounter 自增</li>
<li>同时，事务数量增加了一个，别忘记更新文件头。</li>
</ul>
<p><strong>注意点</strong>：所有文件操作在执行后都需要立刻刷入文件中，防止崩溃后文件丢失数据。</p>
<p>从查询事务状态的方法中抽象出一种公共的方法，使得实现事务状态查询时只需根据条件调用此方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测XID事务是否处于status状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkXID</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span> status)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> getXidPosition(xid);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="keyword">new</span> <span class="title class_">byte</span>[XID_FIELD_SIZE]);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.position(offset);</span><br><span class="line">        fc.read(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf.array()[<span class="number">0</span>] == status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在接口 TransactionManager 中，使用<strong>单例模式</strong> 创建 TM，其有两种方式，分别是：先新建 XID 文件再创建 TM实例（create 方法），或者从一个已有的 XID 文件中创建 TM 实例（open 方法）。要注意的是，从零创建 XID 文件时需要写一个<strong>空的 XID 文件头</strong>，即设置 xidCounter 为 0，否则后续在校验时会不合法</p>
<h2 id="4-Data-Manager（DM）">4. Data Manager（DM）</h2>
<p>DataManager（DM）功能归纳：</p>
<ul>
<li>上层模块和文件系统中的一个抽象层。向上，提供数据包装；向下，直接读写文件。</li>
<li>提供日志功能。</li>
</ul>
<h3 id="1、引用计数缓存框架">1、引用计数缓存框架</h3>
<p>分页管理和数据项（DataItem）管理涉及缓存，故抽象出一个通用缓存框架。</p>
<h4 id="引用计数法">引用计数法</h4>
<p>引用计数法（Reference counting）是一种内存管理技术，它通过计算每个对象被引用的次数来判断是否需要回收该对象。当对象被创建时，引用计数为1，每当有一个新的引用指向该对象时，计数加1，当引用失效时，计数减1。当计数为0时，该对象就可以被回收。</p>
<p>在MYDB的实践中，需要的效果是，只有上层模块主动释放引用，缓存在确保没有模块在使用这个资源了，才会去驱逐资源。</p>
<p>于是，选择引用计数法。增加了一个方法 release(key)，用于在上册模块不使用某个资源时，释放对资源的引用。当引用归零时，缓存就会驱逐这个资源。</p>
<p>同样，在缓存满了之后，引用计数法无法自动释放缓存，此时应该直接报错（和 JVM 似的，直接 OOM）。</p>
<h4 id="LRU">LRU</h4>
<p>LRU（least recently used）是一种缓存淘汰算法。它的特点是根据数据最近被访问的时间来决定哪些数据应该被保留，哪些数据应该被淘汰。当缓存达到一定容量时，会淘汰掉最近最少使用的数据。</p>
<p>如果使用 LRU 缓存，那么只需要设计一个 get(key) 接口即可，释放缓存可以在缓存满了之后自动完成。</p>
<p>however，当某时刻缓存满了，缓存驱逐一个资源，此时上层模块想将某个资源强制刷回3数据源，这个资源恰恰是刚被驱逐的资源。此时的上层模块会发现，资源在缓存中消失了，那么，是否有必要做回源操作？</p>
<ul>
<li>不回源。由于没法确定缓存被驱逐的时间，更没法确定被驱逐之后数据项是否被修改，这样是极其不安全的</li>
<li>回源。如果数据项被驱逐时的数据和现在又是相同的，那就是一次无效回源</li>
<li>放回缓存里，等下次被驱逐时回源。看起来解决了问题，但是此时缓存已经满了，这意味着你还需要驱逐一个资源才能放进去。这有可能会导致缓存抖动问题。</li>
</ul>
<h4 id="实现">实现</h4>
<p><code>AbstractCache</code>类作为抽象缓存类，定义两个方法交由子类实现。</p>
<p>实现引用计数，需要维护一个资源引用个数的HashMap，为了多线程访问，需要维护一个记录资源访问情况的HashMap。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当资源不在缓存时的获取行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当资源被驱逐时的写回行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(T obj)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Long, T&gt; cache;                     <span class="comment">// 实际缓存的数据</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Long, Integer&gt; references;          <span class="comment">// 资源的引用个数</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Long, Boolean&gt; getting;             <span class="comment">// 正在被获取的资源</span></span><br></pre></td></tr></table></figure>
<p>获取资源的<code>get()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> T <span class="title function_">get</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.在通过 get() 方法获取资源时，首先进入一个死循环，来无限尝试从缓存里获取。</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">// 1.1.首先就需要检查这个时候是否有其他线程正在从数据源获取这个资源，如果有，就过会再来看看</span></span><br><span class="line">            <span class="keyword">if</span>(getting.containsKey(key)) &#123;</span><br><span class="line">                <span class="comment">// 请求的资源正在被其他线程获取</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.2.如果没有其他线程在获取这个资源，那么就可以尝试从缓存中获取了</span></span><br><span class="line">            <span class="keyword">if</span>(cache.containsKey(key)) &#123;</span><br><span class="line">                <span class="comment">// 资源在缓存中，直接返回</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">                <span class="comment">// 记得给资源的引用计数加一</span></span><br><span class="line">                references.put(key, references.get(key) + <span class="number">1</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.3.尝试获取该资源</span></span><br><span class="line">            <span class="comment">// a.判断缓存是否已满，如果已满，就抛出一个异常</span></span><br><span class="line">            <span class="keyword">if</span>(maxResource &gt; <span class="number">0</span> &amp;&amp; count == maxResource) &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                <span class="keyword">throw</span> Error.CacheFullException;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// b.如果缓存未满，就在 getting 中注册一下，该线程准备从数据源获取资源了</span></span><br><span class="line">            count ++;</span><br><span class="line">            getting.put(key, <span class="literal">true</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从数据源获取资源</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = getForCache(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 如果获取失败，就把 getting 中的注册信息清除掉</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            count --;</span><br><span class="line">            getting.remove(key);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        getting.remove(key);       <span class="comment">// 获取完成要从 getting 中清除注册信息</span></span><br><span class="line">        cache.put(key, obj);</span><br><span class="line">        references.put(key, <span class="number">1</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>释放资源的<code>release</code>方法：当引用计数references 逐渐 -1 减到 0 后，就可以回源并删除缓存中相关的结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.释放资源</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(<span class="type">long</span> key)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 释放一个缓存时，直接从 references 中减 1，如果已经减到 0 了，就可以回源，并且删除缓存中所有相关的结构</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ref</span> <span class="operator">=</span> references.get(key) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(ref == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">                <span class="comment">// 调用抽象方法释放缓存</span></span><br><span class="line">                releaseForCache(obj);</span><br><span class="line">                <span class="comment">// 删除缓存中所有相关的结构</span></span><br><span class="line">                references.remove(key);</span><br><span class="line">                cache.remove(key);</span><br><span class="line">                count --;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                references.put(key, ref);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、共享内存数组">2、共享内存数组</h3>
<p>在Java中，<strong>数组</strong>被视为一个<strong>对象</strong>，其在内存中也是以对象的形式存储的。在 Java 中，当执行类似 subArray 的操作时，只会在底层进行一个复制，<strong>无法同一片内存</strong>。所以，要实现共享内存数组，定义一个<code>SubArray</code>类，规定这个数组的可使用范围：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] raw;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubArray</span><span class="params">(<span class="type">byte</span>[] raw, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.raw = raw;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、数据页的缓存与管理">3、数据页的缓存与管理</h3>
<h4 id="页面缓存">页面缓存</h4>
<p>默认数据页大小定为 8K，首先，需要定义出页面的结构。注意这个页面是存储在内存中的，与已经持久化到磁盘的抽象页面有区别。</p>
<p>定义一个页面如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageImpl</span> <span class="keyword">implements</span> <span class="title class_">Page</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pageNumber;  <span class="comment">// 页号，从1开始</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data;  <span class="comment">// 此页面实际包含的字节数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> dirty;  <span class="comment">// 标识是否是脏页面。缓存驱逐时，脏页面需要被写回磁盘</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 保存了一个 PageCache 的引用，方便在拿到 Page 的引用时可以快速对这个页面的缓存进行释放操作。</span></span><br><span class="line">    <span class="keyword">private</span> PageCache pc;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>页面缓存接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PageCache</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">newPage</span><span class="params">(<span class="type">byte</span>[] initData)</span>;</span><br><span class="line">    Page <span class="title function_">getPage</span><span class="params">(<span class="type">int</span> pgno)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(Page page)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">truncateByBgno</span><span class="params">(<span class="type">int</span> maxPgno)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getPageNumber</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">flushPage</span><span class="params">(Page pg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>页面缓存的具体实现类，需要继承抽象缓存框架，并且实现 <code>getForCache() </code>和 <code>releaseForCache() </code>两个抽象方法。由于数据源就是文件系统，<code>getForCache() </code>直接从文件中读取，并包裹成 Page 即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Page <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> (<span class="type">int</span>)key;</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> PageCacheImpl.pageOffset(pgno);</span><br><span class="line"></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(PAGE_SIZE);</span><br><span class="line">    fileLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.position(offset);</span><br><span class="line">        fc.read(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    fileLock.unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageImpl</span>(pgno, buf.array(), <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">pageOffset</span><span class="params">(<span class="type">int</span> pgno)</span> &#123;</span><br><span class="line">    <span class="comment">// 页号从 1 开始</span></span><br><span class="line">    <span class="keyword">return</span> (pgno-<span class="number">1</span>) * PAGE_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 releaseForCache() 驱逐页面时，也只需要根据页面是否是脏页面，来决定是否需要写回文件系统：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(pg.isDirty()) &#123;</span><br><span class="line">        flush(pg);</span><br><span class="line">        pg.setDirty(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> pg.getPageNumber();</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> pageOffset(pgno);</span><br><span class="line"></span><br><span class="line">    fileLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(pg.getData());</span><br><span class="line">        fc.position(offset);</span><br><span class="line">        fc.write(buf);</span><br><span class="line">        fc.force(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fileLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PageCache 还使用了一个 AtomicInteger，来记录了当前打开的数据库文件有多少页。这个数字在数据库文件被打开时就会被计算，并在新建页面时自增。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">newPage</span><span class="params">(<span class="type">byte</span>[] initData)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> pageNumbers.incrementAndGet();</span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageImpl</span>(pgno, initData, <span class="literal">null</span>);</span><br><span class="line">    flush(pg);  <span class="comment">// 新建的页面需要立刻写回</span></span><br><span class="line">    <span class="keyword">return</span> pgno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据页管理">数据页管理</h4>
<p><strong>第一页</strong>：</p>
<p>数据库文件的第一页，通常用作一些特殊用途，比如存储一些元数据，用来启动检查什么的。MYDB 的第一页，只是用来做启动检查。具体的原理是，在每次数据库启动时，会生成一串随机字节，存储在 100 ~ 107 字节。在数据库正常关闭时，会将这串字节，拷贝到第一页的 108 ~ 115 字节。</p>
<p>这样数据库在每次启动时，就会检查第一页两处的字节是否相同，以此来判断上一次是否正常关闭。如果是异常关闭，就需要执行数据的恢复流程。</p>
<p>启动时设置初始字节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcOpen</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    setVcOpen(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcOpen</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    System.arraycopy(RandomUtil.randomBytes(LEN_VC), <span class="number">0</span>, raw, OF_VC, LEN_VC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭时拷贝字节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcClose</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    setVcClose(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcClose</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    System.arraycopy(raw, OF_VC, raw, OF_VC+LEN_VC, LEN_VC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>校验字节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkVc</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> checkVc(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkVc</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.equals(Arrays.copyOfRange(raw, OF_VC, OF_VC+LEN_VC), Arrays.copyOfRange(raw, OF_VC+LEN_VC, OF_VC+<span class="number">2</span>*LEN_VC));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>普通页</strong>：</p>
<p>一个普通页面以一个 2 字节无符号数起始，表示这一页的空闲位置的偏移。剩下的部分都是实际存储的数据。</p>
<p>所以对普通页的管理，基本都是围绕着对 FSO（Free Space Offset）进行的。</p>
<p>例如向页面插入数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将raw插入pg中，返回插入位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">insert</span><span class="params">(Page pg, <span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">short</span> <span class="variable">offset</span> <span class="operator">=</span> getFSO(pg.getData());</span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length);</span><br><span class="line">    setFSO(pg.getData(), (<span class="type">short</span>)(offset + raw.length));</span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在写入之前获取 FSO，来确定写入的位置，并在写入之后更新 FSO。FSO 的操作如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFSO</span><span class="params">(<span class="type">byte</span>[] raw, <span class="type">short</span> ofData)</span> &#123;</span><br><span class="line">    System.arraycopy(Parser.short2Byte(ofData), <span class="number">0</span>, raw, OF_FREE, OF_DATA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取pg的FSO</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">getFSO</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getFSO(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">getFSO</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Parser.parseShort(Arrays.copyOfRange(raw, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取页面的空闲空间大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getFreeSpace</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PageCache.PAGE_SIZE - (<span class="type">int</span>)getFSO(pg.getData());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩余两个函数 recoverInsert() 和 recoverUpdate() 用于在数据库崩溃后重新打开时，恢复例程直接插入数据以及修改数据使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将raw插入pg中的offset位置，并将pg的offset设置为较大的offset</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recoverInsert</span><span class="params">(Page pg, <span class="type">byte</span>[] raw, <span class="type">short</span> offset)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length);</span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> <span class="variable">rawFSO</span> <span class="operator">=</span> getFSO(pg.getData());</span><br><span class="line">    <span class="keyword">if</span>(rawFSO &lt; offset + raw.length) &#123;</span><br><span class="line">        setFSO(pg.getData(), (<span class="type">short</span>)(offset+raw.length));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将raw插入pg中的offset位置，不更新update</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recoverUpdate</span><span class="params">(Page pg, <span class="type">byte</span>[] raw, <span class="type">short</span> offset)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-Version-Manager（VM）">5. Version Manager（VM）</h2>
<blockquote>
<p>VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。</p>
</blockquote>
<p>类似于 Data Manager 是 MYDB 的数据管理核心，Version Manager 是 MYDB 的事务和数据版本的管理核心。</p>
<h3 id="2PL与MVCC">2PL与MVCC</h3>
<h4 id="冲突与-2PL">冲突与 2PL</h4>
<p>首先来定义数据库的冲突，暂时不考虑插入操作，只看更新操作（U）和读操作（R），两个操作只要满足下面三个条件，就可以说这两个操作相互冲突：</p>
<ul>
<li>这两个操作是由不同的事务执行的</li>
<li>这两个操作操作的是同一个数据项</li>
<li>这两个操作至少有一个是更新操作</li>
</ul>
<p>那么这样，对同一个数据操作的冲突，其实就只有下面这两种情况：</p>
<ul>
<li>两个不同事务的 U 操作冲突</li>
<li>两个不同事务的 U、R 操作冲突</li>
</ul>
<p>那么冲突或者不冲突，意义何在？作用在于，<strong>交换两个互不冲突的操作的顺序，不会对最终的结果造成影响</strong>，而交换两个冲突操作的顺序，则是会有影响的。</p>
<p>现在我们先抛开冲突不谈，记得在第四章举的例子吗，在并发情况下，两个事务同时操作 x。假设 x 的初值是 0：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T1 begin</span><br><span class="line">T2 begin</span><br><span class="line">R1(x) // T1读到0</span><br><span class="line">R2(x) // T2读到0</span><br><span class="line">U1(0+1) // T1尝试把x+1</span><br><span class="line">U2(0+1) // T2尝试把x+1</span><br><span class="line">T1 commit</span><br><span class="line">T2 commit</span><br></pre></td></tr></table></figure>
<p>最后 x 的结果是 1，这个结果显然与期望的不符。</p>
<p>VM 的一个很重要的职责，就是实现了调度序列的可串行化。MYDB 采用两段锁协议（2PL）来实现。当采用 2PL 时，如果某个事务 i 已经对 x 加锁，且另一个事务 j 也想操作 x，但是这个操作与事务 i 之前的操作相互冲突的话，事务 j 就会被阻塞。譬如，T1 已经因为 U1(x) 锁定了 x，那么 T2 对 x 的读或者写操作都会被阻塞，T2 必须等待 T1 释放掉对 x 的锁。</p>
<p>由此来看，2PL 确实保证了调度序列的可串行话，但是不可避免地导致了事务间的相互阻塞，甚至可能导致死锁。MYDB 为了提高事务处理的效率，降低阻塞概率，实现了 MVCC。</p>
<h4 id="MVCC">MVCC</h4>
<p>在介绍 MVCC 之前，首先明确记录和版本的概念。</p>
<p>DM 层向上层提供了数据项（Data Item）的概念，VM 通过管理所有的数据项，向上层提供了记录（Entry）的概念。上层模块通过 VM 操作数据的最小单位，就是记录。VM 则在其内部，为每个记录，维护了多个版本（Version）。每当上层模块对某个记录进行修改时，VM 就会为这个记录创建一个新的版本。</p>
<p>MYDB 通过 MVCC，降低了事务的阻塞概率。譬如，T1 想要更新记录 X 的值，于是 T1 需要首先获取 X 的锁，接着更新，也就是创建了一个新的 X 的版本，假设为 x3。假设 T1 还没有释放 X 的锁时，T2 想要读取 X 的值，这时候就不会阻塞，MYDB 会返回一个较老版本的 X，例如 x2。这样最后执行的结果，就等价于，T2 先执行，T1 后执行，调度序列依然是可串行化的。如果 X 没有一个更老的版本，那只能等待 T1 释放锁了。所以只是降低了概率。</p>
<p>还记得我们在第四章中，为了保证数据的可恢复，VM 层传递到 DM 的操作序列需要满足以下两个规则：</p>
<p>规定 1：正在进行的事务，不会读取其他任何未提交的事务产生的数据。</p>
<p>规定 2：正在进行的事务，不会修改其他任何未提交的事务修改或产生的数据。</p>
<p>由于 2PL 和 MVCC，我们可以看到，这两个条件都被很轻易地满足了。</p>
<h3 id="记录的实现">记录的实现</h3>
<p>对于一条记录来说，MYDB 使用 Entry 类维护了其结构。虽然理论上，MVCC 实现了多版本，但是在实现中，VM 并没有提供 Update 操作，对于字段的更新操作由后面的表和字段管理（TBM）实现。所以在 VM 的实现中，一条记录只有一个版本。</p>
<p>一条记录存储在一条 Data Item 中，所以 Entry 中保存一个 DataItem 的引用即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_XMIN</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_XMAX</span> <span class="operator">=</span> OF_XMIN+<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_DATA</span> <span class="operator">=</span> OF_XMAX+<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> uid;</span><br><span class="line">    <span class="keyword">private</span> DataItem dataItem;</span><br><span class="line">    <span class="keyword">private</span> VersionManager vm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Entry <span class="title function_">loadEntry</span><span class="params">(VersionManager vm, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DataItem</span> <span class="variable">di</span> <span class="operator">=</span> ((VersionManagerImpl)vm).dm.read(uid);</span><br><span class="line">        <span class="keyword">return</span> newEntry(vm, di, uid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        dataItem.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们规定，一条 Entry 中存储的数据格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[XMIN] [XMAX] [DATA]</span><br></pre></td></tr></table></figure>
<p>XMIN 是创建该条记录（版本）的事务编号，而 XMAX 则是删除该条记录（版本）的事务编号。它们的作用将在下一节中说明。DATA 就是这条记录持有的数据。根据这个结构，在创建记录时调用的 wrapEntryRaw() 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] wrapEntryRaw(<span class="type">long</span> xid, <span class="type">byte</span>[] data) &#123;</span><br><span class="line">    <span class="type">byte</span>[] xmin = Parser.long2Byte(xid);</span><br><span class="line">    <span class="type">byte</span>[] xmax = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">return</span> Bytes.concat(xmin, xmax, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，如果要获取记录中持有的数据，也就需要按照这个结构来解析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以拷贝的形式返回内容</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] data() &#123;</span><br><span class="line">    dataItem.rLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SubArray</span> <span class="variable">sa</span> <span class="operator">=</span> dataItem.data();</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[sa.end - sa.start - OF_DATA];</span><br><span class="line">        System.arraycopy(sa.raw, sa.start+OF_DATA, data, <span class="number">0</span>, data.length);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        dataItem.rUnLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里以拷贝的形式返回数据，如果需要修改的话，需要对 DataItem 执行 before() 方法，这个在设置 XMAX 的值中体现了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setXmax</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    dataItem.before();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SubArray</span> <span class="variable">sa</span> <span class="operator">=</span> dataItem.data();</span><br><span class="line">        System.arraycopy(Parser.long2Byte(xid), <span class="number">0</span>, sa.raw, sa.start+OF_XMAX, <span class="number">8</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        dataItem.after(xid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>before() 和 after() 是在 DataItem 一节中就已经确定的数据项修改规则。</p>
<h3 id="事务的隔离级别">事务的隔离级别</h3>
<h4 id="读提交">读提交</h4>
<p>上面提到，如果一个记录的最新版本被加锁，当另一个事务想要修改或读取这条记录时，MYDB 就会返回一个较旧的版本的数据。这时就可以认为，最新的被加锁的版本，对于另一个事务来说，是不可见的。于是版本可见性的概念就诞生了。</p>
<p>版本的可见性与事务的隔离度是相关的。MYDB 支持的最低的事务隔离程度，是“读提交”（Read Committed），即事务在读取数据时, 只能读取已经提交事务产生的数据。保证最低的读提交的好处，第四章中已经说明（防止级联回滚与 commit 语义冲突）。</p>
<p>MYDB 实现读提交，为每个版本维护了两个变量，就是上面提到的 XMIN 和 XMAX：</p>
<ul>
<li>XMIN：创建该版本的事务编号</li>
<li>XMAX：删除该版本的事务编号</li>
</ul>
<p>XMIN 应当在版本创建时填写，而 XMAX 则在版本被删除，或者有新版本出现时填写。</p>
<p>XMAX 这个变量，也就解释了为什么 DM 层不提供删除操作，当想删除一个版本时，只需要设置其 XMAX，这样，这个版本对每一个 XMAX 之后的事务都是不可见的，也就等价于删除了。</p>
<p>如此，在读提交下，版本对事务的可见性逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(XMIN == Ti and                             // 由Ti创建且</span><br><span class="line">XMAX == NULL                            // 还未被删除</span><br><span class="line">)</span><br><span class="line">or                                          // 或</span><br><span class="line">(XMIN is commited and                       // 由一个已提交的事务创建且</span><br><span class="line">(XMAX == NULL or                        // 尚未删除或</span><br><span class="line">(XMAX != Ti and XMAX is not commited)   // 由一个未提交的事务删除</span><br><span class="line">))</span><br></pre></td></tr></table></figure>
<p>若条件为 true，则版本对 Ti 可见。那么获取 Ti 适合的版本，只需要从最新版本开始，依次向前检查可见性，如果为 true，就可以直接返回。</p>
<p>以下方法判断某个记录对事务 t 是否可见：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">readCommitted</span><span class="params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> t.xid;</span><br><span class="line">    <span class="type">long</span> <span class="variable">xmin</span> <span class="operator">=</span> e.getXmin();</span><br><span class="line">    <span class="type">long</span> <span class="variable">xmax</span> <span class="operator">=</span> e.getXmax();</span><br><span class="line">    <span class="keyword">if</span>(xmin == xid &amp;&amp; xmax == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tm.isCommitted(xmin)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(xmax == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(xmax != xid) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!tm.isCommitted(xmax)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 Transaction 结构只提供了一个 XID。</p>
<h4 id="可重复读">可重复读</h4>
<p>读提交会导致的问题大家也都很清楚，八股也背了不少。那就是不可重复读和幻读。这里我们来解决不可重复读的问题。</p>
<p>不可重复度，会导致一个事务在执行期间对同一个数据项的读取得到不同结果。如下面的结果，加入 X 初始值为 0：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T1 begin</span><br><span class="line">R1(X) // T1 读得 0</span><br><span class="line">T2 begin</span><br><span class="line">U2(X) // 将 X 修改为 1</span><br><span class="line">T2 commit</span><br><span class="line">R1(X) // T1 读的 1</span><br></pre></td></tr></table></figure>
<p>可以看到，T1 两次读 X，读到的结果不一样。如果想要避免这个情况，就需要引入更严格的隔离级别，即可重复读（repeatable read）。</p>
<p>T1 在第二次读取的时候，读到了已经提交的 T2 修改的值，导致了这个问题。于是我们可以规定：</p>
<p>事务只能读取它开始时, 就已经结束的那些事务产生的数据版本</p>
<p>这条规定，增加于，事务需要忽略：</p>
<p>在本事务后开始的事务的数据;</p>
<p>本事务开始时还是 active 状态的事务的数据</p>
<p>对于第一条，只需要比较事务 ID，即可确定。而对于第二条，则需要在事务 Ti 开始时，记录下当前活跃的所有事务 SP(Ti)，如果记录的某个版本，XMIN 在 SP(Ti) 中，也应当对 Ti 不可见。</p>
<p>于是，可重复读的判断逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(XMIN == Ti and                 <span class="comment">// 由Ti创建且</span></span><br><span class="line"> (XMAX == NULL or               <span class="comment">// 尚未被删除</span></span><br><span class="line">))</span><br><span class="line">or                              <span class="comment">// 或</span></span><br><span class="line">(XMIN is commited and           <span class="comment">// 由一个已提交的事务创建且</span></span><br><span class="line"> XMIN &lt; XID and                 <span class="comment">// 这个事务小于Ti且</span></span><br><span class="line"> XMIN is not in <span class="title function_">SP</span><span class="params">(Ti)</span> and      <span class="comment">// 这个事务在Ti开始前提交且</span></span><br><span class="line"> (XMAX == NULL or               <span class="comment">// 尚未被删除或</span></span><br><span class="line">  (XMAX != Ti and               <span class="comment">// 由其他事务删除但是</span></span><br><span class="line">   (XMAX is not commited or     <span class="comment">// 这个事务尚未提交或</span></span><br><span class="line">XMAX &gt; Ti or                    <span class="comment">// 这个事务在Ti开始之后才开始或</span></span><br><span class="line">XMAX is in <span class="title function_">SP</span><span class="params">(Ti)</span>               <span class="comment">// 这个事务在Ti开始前还未提交</span></span><br><span class="line">))))</span><br></pre></td></tr></table></figure>
<p>于是，需要提供一个结构，来抽象一个事务，以保存快照数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> xid;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> level;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;Long, Boolean&gt; snapshot;</span><br><span class="line">    <span class="keyword">public</span> Exception err;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> autoAborted;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Transaction <span class="title function_">newTransaction</span><span class="params">(<span class="type">long</span> xid, <span class="type">int</span> level, Map&lt;Long, Transaction&gt; active)</span> &#123;</span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transaction</span>();</span><br><span class="line">        t.xid = xid;</span><br><span class="line">        t.level = level;</span><br><span class="line">        <span class="keyword">if</span>(level != <span class="number">0</span>) &#123;</span><br><span class="line">            t.snapshot = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(Long x : active.keySet()) &#123;</span><br><span class="line">                t.snapshot.put(x, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInSnapshot</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(xid == TransactionManagerImpl.SUPER_XID) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> snapshot.containsKey(xid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方法中的 active，保存着当前所有 active 的事务。于是，可重复读的隔离级别下，一个版本是否对事务可见的判断如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">repeatableRead</span><span class="params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> t.xid;</span><br><span class="line">    <span class="type">long</span> <span class="variable">xmin</span> <span class="operator">=</span> e.getXmin();</span><br><span class="line">    <span class="type">long</span> <span class="variable">xmax</span> <span class="operator">=</span> e.getXmax();</span><br><span class="line">    <span class="keyword">if</span>(xmin == xid &amp;&amp; xmax == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tm.isCommitted(xmin) &amp;&amp; xmin &lt; xid &amp;&amp; !t.isInSnapshot(xmin)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(xmax == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(xmax != xid) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!tm.isCommitted(xmax)  xmax &gt; xid  t.isInSnapshot(xmax)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="死锁检测">死锁检测</h3>
<h4 id="版本跳跃问题">版本跳跃问题</h4>
<p>说到版本跳跃之前，顺便提一嘴，MVCC 的实现，使得 MYDB 在撤销或是回滚事务很简单：只需要将这个事务标记为 aborted 即可。根据前一章提到的可见性，每个事务都只能看到其他 committed 的事务所产生的数据，一个 aborted 事务产生的数据，就不会对其他事务产生任何影响了，也就相当于，这个事务不曾存在过。</p>
<p>版本跳跃问题，考虑如下的情况，假设 X 最初只有 x0 版本，T1 和 T2 都是可重复读的隔离级别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T1 begin</span><br><span class="line">T2 begin</span><br><span class="line"><span class="title function_">R1</span><span class="params">(X)</span> <span class="comment">// T1读取x0</span></span><br><span class="line">R2(X) <span class="comment">// T2读取x0</span></span><br><span class="line">U1(X) <span class="comment">// T1将X更新到x1</span></span><br><span class="line">T1 commit</span><br><span class="line"><span class="title function_">U2</span><span class="params">(X)</span> <span class="comment">// T2将X更新到x2</span></span><br><span class="line">T2 commit</span><br></pre></td></tr></table></figure>
<p>这种情况实际运行起来是没问题的，但是逻辑上不太正确。T1 将 X 从 x0 更新为了 x1，这是没错的。但是 T2 则是将 X 从 x0 更新成了 x2，跳过了 x1 版本。</p>
<p>读提交是允许版本跳跃的，而可重复读则是不允许版本跳跃的。解决版本跳跃的思路也很简单：如果 Ti 需要修改 X，而 X 已经被 Ti 不可见的事务 Tj 修改了，那么要求 Ti 回滚。</p>
<p>上一节中就总结了，Ti 不可见的 Tj，有两种情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XID(Tj) &gt; XID(Ti)</span><br><span class="line">Tj in <span class="title function_">SP</span><span class="params">(Ti)</span></span><br></pre></td></tr></table></figure>
<p>于是版本跳跃的检查也就很简单了，取出要修改的数据 X 的最新提交版本，并检查该最新版本的创建者对当前事务是否可见：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isVersionSkip</span><span class="params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">xmax</span> <span class="operator">=</span> e.getXmax();</span><br><span class="line">    <span class="keyword">if</span>(t.level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tm.isCommitted(xmax) &amp;&amp; (xmax &gt; t.xid  t.isInSnapshot(xmax));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="死锁检测-2">死锁检测</h4>
<p>上一节提到了 2PL 会阻塞事务，直至持有锁的线程释放锁。可以将这种等待关系抽象成有向边，例如 Tj 在等待 Ti，就可以表示为 Tj --&gt; Ti。这样，无数有向边就可以形成一个图（不一定是连通图）。检测死锁也就简单了，只需要查看这个图中是否有环即可。</p>
<p>MYDB 使用一个 LockTable 对象，在内存中维护这张图。维护结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; x2u;  <span class="comment">// 某个XID已经获得的资源的UID列表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Long&gt; u2x;        <span class="comment">// UID被某个XID持有</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; wait; <span class="comment">// 正在等待UID的XID列表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Lock&gt; waitLock;   <span class="comment">// 正在等待资源的XID的锁</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Long&gt; waitU;      <span class="comment">// XID正在等待的UID</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在每次出现等待的情况时，就尝试向图中增加一条边，并进行死锁检测。如果检测到死锁，就撤销这条边，不允许添加，并撤销该事务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不需要等待则返回null，否则返回锁对象</span></span><br><span class="line"><span class="comment">// 会造成死锁则抛出异常</span></span><br><span class="line"><span class="keyword">public</span> Lock <span class="title function_">add</span><span class="params">(<span class="type">long</span> xid, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isInList(x2u, xid, uid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!u2x.containsKey(uid)) &#123;</span><br><span class="line">            u2x.put(uid, xid);</span><br><span class="line">            putIntoList(x2u, xid, uid);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        waitU.put(xid, uid);</span><br><span class="line">        putIntoList(wait, xid, uid);</span><br><span class="line">        <span class="keyword">if</span>(hasDeadLock()) &#123;</span><br><span class="line">            waitU.remove(xid);</span><br><span class="line">            removeFromList(wait, uid, xid);</span><br><span class="line">            <span class="keyword">throw</span> Error.DeadlockException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        l.lock();</span><br><span class="line">        waitLock.put(xid, l);</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 add，如果需要等待的话，会返回一个上了锁的 Lock 对象。调用方在获取到该对象时，需要尝试获取该对象的锁，由此实现阻塞线程的目的，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">l</span> <span class="operator">=</span> lt.add(xid, uid);</span><br><span class="line"><span class="keyword">if</span>(l != <span class="literal">null</span>) &#123;</span><br><span class="line">    l.lock();   <span class="comment">// 阻塞在这一步</span></span><br><span class="line">    l.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找图中是否有环的算法也非常简单，就是一个深搜，只是需要注意这个图不一定是连通图。思路就是为每个节点设置一个访问戳，都初始化为 -1，随后遍历所有节点，以每个非 -1 的节点作为根进行深搜，并将深搜该连通图中遇到的所有节点都设置为同一个数字，不同的连通图数字不同。这样，如果在遍历某个图时，遇到了之前遍历过的节点，说明出现了环。</p>
<p>实现很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasDeadLock</span><span class="params">()</span> &#123;</span><br><span class="line">    xidStamp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    stamp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> xid : x2u.keySet()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">s</span> <span class="operator">=</span> xidStamp.get(xid);</span><br><span class="line">        <span class="keyword">if</span>(s != <span class="literal">null</span> &amp;&amp; s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stamp ++;</span><br><span class="line">        <span class="keyword">if</span>(dfs(xid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">stp</span> <span class="operator">=</span> xidStamp.get(xid);</span><br><span class="line">    <span class="keyword">if</span>(stp != <span class="literal">null</span> &amp;&amp; stp == stamp) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stp != <span class="literal">null</span> &amp;&amp; stp &lt; stamp) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    xidStamp.put(xid, stamp);</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">uid</span> <span class="operator">=</span> waitU.get(xid);</span><br><span class="line">    <span class="keyword">if</span>(uid == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">x</span> <span class="operator">=</span> u2x.get(uid);</span><br><span class="line">    <span class="keyword">assert</span> x != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个事务 commit 或者 abort 时，就可以释放所有它持有的锁，并将自身从等待图中删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;Long&gt; l = x2u.get(xid);</span><br><span class="line">        <span class="keyword">if</span>(l != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(l.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">Long</span> <span class="variable">uid</span> <span class="operator">=</span> l.remove(<span class="number">0</span>);</span><br><span class="line">                selectNewXID(uid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        waitU.remove(xid);</span><br><span class="line">        x2u.remove(xid);</span><br><span class="line">        waitLock.remove(xid);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>while 循环释放掉了这个线程所有持有的资源的锁，这些资源可以被等待的线程所获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从等待队列中选择一个xid来占用uid</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">selectNewXID</span><span class="params">(<span class="type">long</span> uid)</span> &#123;</span><br><span class="line">    u2x.remove(uid);</span><br><span class="line">    List&lt;Long&gt; l = wait.get(uid);</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">assert</span> l.size() &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> l.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!waitLock.containsKey(xid)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            u2x.put(uid, xid);</span><br><span class="line">            <span class="type">Lock</span> <span class="variable">lo</span> <span class="operator">=</span> waitLock.remove(xid);</span><br><span class="line">            waitU.remove(xid);</span><br><span class="line">            lo.unlock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l.size() == <span class="number">0</span>) wait.remove(uid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 List 开头开始尝试解锁，还是个公平锁。解锁时，将该 Lock 对象 unlock 即可，这样业务线程就获取到了锁，就可以继续执行了。</p>
<h3 id="VM实现">VM实现</h3>
<p>VM 层通过 VersionManager 接口，向上层提供功能，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VersionManager</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] read(<span class="type">long</span> xid, <span class="type">long</span> uid) <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">insert</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="type">long</span> xid, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="title function_">begin</span><span class="params">(<span class="type">int</span> level)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">long</span> xid)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，VM 的实现类还被设计为 Entry 的缓存，需要继承 AbstractCache<Entry>。需要实现的获取到缓存和从缓存释放的方法很简单：</Entry></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Entry <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> Entry.loadEntry(<span class="built_in">this</span>, uid);</span><br><span class="line">    <span class="keyword">if</span>(entry == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Error.NullEntryException;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(Entry entry)</span> &#123;</span><br><span class="line">    entry.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>begin() 开启一个事务，并初始化事务的结构，将其存放在 activeTransaction 中，用于检查和快照使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">begin</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> tm.begin();</span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> Transaction.newTransaction(xid, level, activeTransaction);</span><br><span class="line">        activeTransaction.put(xid, t);</span><br><span class="line">        <span class="keyword">return</span> xid;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>commit() 方法提交一个事务，主要就是 free 掉相关的结构，并且释放持有的锁，并修改 TM 状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);</span><br><span class="line">    lock.unlock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(t.err != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> t.err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(NullPointerException n) &#123;</span><br><span class="line">        System.out.println(xid);</span><br><span class="line">        System.out.println(activeTransaction.keySet());</span><br><span class="line">        Panic.panic(n);</span><br><span class="line">    &#125;</span><br><span class="line">    lock.lock();</span><br><span class="line">    activeTransaction.remove(xid);</span><br><span class="line">    lock.unlock();</span><br><span class="line">    lt.remove(xid);</span><br><span class="line">    tm.commit(xid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>abort 事务的方法则有两种，手动和自动。手动指的是调用 abort() 方法，而自动，则是在事务被检测出出现死锁时，会自动撤销回滚事务；或者出现版本跳跃时，也会自动回滚：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">internAbort</span><span class="params">(<span class="type">long</span> xid, <span class="type">boolean</span> autoAborted)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);</span><br><span class="line">    <span class="keyword">if</span>(!autoAborted) &#123;</span><br><span class="line">        activeTransaction.remove(xid);</span><br><span class="line">    &#125;</span><br><span class="line">    lock.unlock();</span><br><span class="line">    <span class="keyword">if</span>(t.autoAborted) <span class="keyword">return</span>;</span><br><span class="line">    lt.remove(xid);</span><br><span class="line">    tm.abort(xid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>read() 方法读取一个 entry，注意判断下可见性即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] read(<span class="type">long</span> xid, <span class="type">long</span> uid) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);</span><br><span class="line">    lock.unlock();</span><br><span class="line">    <span class="keyword">if</span>(t.err != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> t.err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="built_in">super</span>.get(uid);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(Visibility.isVisible(tm, t, entry)) &#123;</span><br><span class="line">            <span class="keyword">return</span> entry.data();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        entry.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>insert() 则是将数据包裹成 Entry，无脑交给 DM 插入即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">insert</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);</span><br><span class="line">    lock.unlock();</span><br><span class="line">    <span class="keyword">if</span>(t.err != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> t.err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">byte</span>[] raw = Entry.wrapEntryRaw(xid, data);</span><br><span class="line">    <span class="keyword">return</span> dm.insert(xid, raw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>delete() 方法看起来略为复杂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="type">long</span> xid, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);</span><br><span class="line">    lock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t.err != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> t.err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="built_in">super</span>.get(uid);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!Visibility.isVisible(tm, t, entry)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">l</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            l = lt.add(xid, uid);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            t.err = Error.ConcurrentUpdateException;</span><br><span class="line">            internAbort(xid, <span class="literal">true</span>);</span><br><span class="line">            t.autoAborted = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> t.err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l != <span class="literal">null</span>) &#123;</span><br><span class="line">            l.lock();</span><br><span class="line">            l.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(entry.getXmax() == xid) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Visibility.isVersionSkip(tm, t, entry)) &#123;</span><br><span class="line">            t.err = Error.ConcurrentUpdateException;</span><br><span class="line">            internAbort(xid, <span class="literal">true</span>);</span><br><span class="line">            t.autoAborted = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> t.err;</span><br><span class="line">        &#125;</span><br><span class="line">        entry.setXmax(xid);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        entry.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上主要是前置的三件事：一是可见性判断，二是获取资源的锁，三是版本跳跃判断。删除的操作只有一个设置 XMAX。</p>
<h2 id="6-Index-Manager-（IM）">6. Index Manager （IM）</h2>
<p>IM，即 Index Manager，索引管理器，为 MYDB 提供了基于 B+ 树的聚簇索引。目前 MYDB 只支持基于索引查找数据，不支持全表扫描。感兴趣的同学可以自行实现。</p>
<p>在依赖关系图中可以看到，IM 直接基于 DM，而没有基于 VM。索引的数据被直接插入数据库文件中，而不需要经过版本管理。</p>
<p>本节不赘述 B+ 树算法，更多描述实现。</p>
<h3 id="二叉树索引">二叉树索引</h3>
<p>二叉树由一个个 Node 组成，每个 Node 都存储在一条 DataItem 中。结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[LeafFlag][KeyNumber][SiblingUid]</span><br><span class="line">[Son0][Key0][Son1][Key1]...[SonN][KeyN]</span><br></pre></td></tr></table></figure>
<p>其中 LeafFlag 标记了该节点是否是个叶子节点；KeyNumber 为该节点中 key 的个数；SiblingUid 是其兄弟节点存储在 DM 中的 UID。后续是穿插的子节点（SonN）和 KeyN。最后的一个 KeyN 始终为 MAX_VALUE，以此方便查找。</p>
<p>Node 类持有了其 B+ 树结构的引用，DataItem 的引用和 SubArray 的引用，用于方便快速修改数据和释放数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    BPlusTree tree;</span><br><span class="line">    DataItem dataItem;</span><br><span class="line">    SubArray raw;</span><br><span class="line">    <span class="type">long</span> uid;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是生成一个根节点的数据可以写成如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] newRootRaw(<span class="type">long</span> left, <span class="type">long</span> right, <span class="type">long</span> key)  &#123;</span><br><span class="line">    <span class="type">SubArray</span> <span class="variable">raw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubArray</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[NODE_SIZE], <span class="number">0</span>, NODE_SIZE);</span><br><span class="line">    setRawIsLeaf(raw, <span class="literal">false</span>);</span><br><span class="line">    setRawNoKeys(raw, <span class="number">2</span>);</span><br><span class="line">    setRawSibling(raw, <span class="number">0</span>);</span><br><span class="line">    setRawKthSon(raw, left, <span class="number">0</span>);</span><br><span class="line">    setRawKthKey(raw, key, <span class="number">0</span>);</span><br><span class="line">    setRawKthSon(raw, right, <span class="number">1</span>);</span><br><span class="line">    setRawKthKey(raw, Long.MAX_VALUE, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> raw.raw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该根节点的初始两个子节点为 left 和 right, 初始键值为 key。</p>
<p>类似的，生成一个空的根节点数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] newNilRootRaw()  &#123;</span><br><span class="line">    <span class="type">SubArray</span> <span class="variable">raw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubArray</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[NODE_SIZE], <span class="number">0</span>, NODE_SIZE);</span><br><span class="line">    setRawIsLeaf(raw, <span class="literal">true</span>);</span><br><span class="line">    setRawNoKeys(raw, <span class="number">0</span>);</span><br><span class="line">    setRawSibling(raw, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> raw.raw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Node 类有两个方法，用于辅助 B+ 树做插入和搜索操作，分别是 searchNext 方法和 leafSearchRange 方法。</p>
<p>searchNext 寻找对应 key 的 UID, 如果找不到, 则返回兄弟节点的 UID。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SearchNextRes <span class="title function_">searchNext</span><span class="params">(<span class="type">long</span> key)</span> &#123;</span><br><span class="line">    dataItem.rLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SearchNextRes</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchNextRes</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">noKeys</span> <span class="operator">=</span> getRawNoKeys(raw);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; noKeys; i ++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> getRawKthKey(raw, i);</span><br><span class="line">            <span class="keyword">if</span>(key &lt; ik) &#123;</span><br><span class="line">                res.uid = getRawKthSon(raw, i);</span><br><span class="line">                res.siblingUid = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.uid = <span class="number">0</span>;</span><br><span class="line">        res.siblingUid = getRawSibling(raw);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        dataItem.rUnLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>leafSearchRange 方法在当前节点进行范围查找，范围是 [leftKey, rightKey]，这里约定如果 rightKey 大于等于该节点的最大的 key, 则还同时返回兄弟节点的 UID，方便继续搜索下一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> LeafSearchRangeRes <span class="title function_">leafSearchRange</span><span class="params">(<span class="type">long</span> leftKey, <span class="type">long</span> rightKey)</span> &#123;</span><br><span class="line">    dataItem.rLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">noKeys</span> <span class="operator">=</span> getRawNoKeys(raw);</span><br><span class="line">        <span class="type">int</span> <span class="variable">kth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(kth &lt; noKeys) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> getRawKthKey(raw, kth);</span><br><span class="line">            <span class="keyword">if</span>(ik &gt;= leftKey) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            kth ++;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Long&gt; uids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(kth &lt; noKeys) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> getRawKthKey(raw, kth);</span><br><span class="line">            <span class="keyword">if</span>(ik &lt;= rightKey) &#123;</span><br><span class="line">                uids.add(getRawKthSon(raw, kth));</span><br><span class="line">                kth ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">siblingUid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(kth == noKeys) &#123;</span><br><span class="line">            siblingUid = getRawSibling(raw);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LeafSearchRangeRes</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeafSearchRangeRes</span>();</span><br><span class="line">        res.uids = uids;</span><br><span class="line">        res.siblingUid = siblingUid;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        dataItem.rUnLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 B+ 树在插入删除时，会动态调整，根节点不是固定节点，于是设置一个 bootDataItem，该 DataItem 中存储了根节点的 UID。可以注意到，IM 在操作 DM 时，使用的事务都是 SUPER_XID。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BPlusTree</span> &#123;</span><br><span class="line">    DataItem bootDataItem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">rootUid</span><span class="params">()</span> &#123;</span><br><span class="line">        bootLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SubArray</span> <span class="variable">sa</span> <span class="operator">=</span> bootDataItem.data();</span><br><span class="line">            <span class="keyword">return</span> Parser.parseLong(Arrays.copyOfRange(sa.raw, sa.start, sa.start+<span class="number">8</span>));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bootLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateRootUid</span><span class="params">(<span class="type">long</span> left, <span class="type">long</span> right, <span class="type">long</span> rightKey)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        bootLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] rootRaw = Node.newRootRaw(left, right, rightKey);</span><br><span class="line">            <span class="type">long</span> <span class="variable">newRootUid</span> <span class="operator">=</span> dm.insert(TransactionManagerImpl.SUPER_XID, rootRaw);</span><br><span class="line">            bootDataItem.before();</span><br><span class="line">            <span class="type">SubArray</span> <span class="variable">diRaw</span> <span class="operator">=</span> bootDataItem.data();</span><br><span class="line">            System.arraycopy(Parser.long2Byte(newRootUid), <span class="number">0</span>, diRaw.raw, diRaw.start, <span class="number">8</span>);</span><br><span class="line">            bootDataItem.after(TransactionManagerImpl.SUPER_XID);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bootLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IM 对上层模块主要提供两种能力：插入索引和搜索节点。向 B+ 树插入节点和搜索节点的算法和实现，不再赘述。</p>
<p>这里可能会有疑问，IM 为什么不提供删除索引的能力。当上层模块通过 VM 删除某个 Entry，实际的操作是设置其 XMAX。如果不去删除对应索引的话，当后续再次尝试读取该 Entry 时，是可以通过索引寻找到的，但是由于设置了 XMAX，寻找不到合适的版本而返回一个找不到内容的错误。</p>
<h3 id="可能的错误与恢复">可能的错误与恢复</h3>
<p>B+ 树在操作过程中，可能出现两种错误，分别是节点内部错误和节点间关系错误。</p>
<p>当节点内部错误发生时，即当 Ti 在对节点的数据进行更改时，MYDB 发生了崩溃。由于 IM 依赖于 DM，在数据库重启后，Ti 会被撤销（undo），对节点的错误影响会被消除。</p>
<p>如果出现了节点间错误，那么一定是下面这种情况：某次对 u 节点的插入操作创建了新节点 v, 此时 sibling(u)=v，但是 v 却并没有被插入到父节点中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[parent]</span><br><span class="line"></span><br><span class="line">    v</span><br><span class="line">   [u] -&gt; [v]</span><br></pre></td></tr></table></figure>
<p>正确的状态应当如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[ parent ]</span><br><span class="line"></span><br><span class="line"> v      v</span><br><span class="line">[u] -&gt; [v]</span><br></pre></td></tr></table></figure>
<p>这时，如果要对节点进行插入或者搜索操作，如果失败，就会继续迭代它的兄弟节点，最终还是可以找到 v 节点。唯一的缺点仅仅是，无法直接通过父节点找到 v 了，只能间接地通过 u 获取到 v。</p>
<h2 id="7-Table-Manager（TBM）">7. Table Manager（TBM）</h2>
<h3 id="字段与表管理">字段与表管理</h3>
<p>注意，这里的字段与表管理，不是管理各个条目中不同的字段的数值等信息，而是管理表和字段的结构数据，例如表名、表字段信息和字段索引等。</p>
<p>由于 TBM 基于 VM，单个字段信息和表信息都是直接保存在 Entry 中。字段的二进制表示如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[FieldName][TypeName][IndexUid]</span><br></pre></td></tr></table></figure>
<p>这里 FieldName 和 TypeName，以及后面的表明，存储的都是字节形式的字符串。这里规定一个字符串的存储方式，以明确其存储边界。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[StringLength][StringData]</span><br></pre></td></tr></table></figure>
<p>TypeName 为字段的类型，限定为 int32、int64 和 string 类型。如果这个字段有索引，那个 IndexUID 指向了索引二叉树的根，否则该字段为 0。</p>
<p>根据这个结构，通过一个 UID 从 VM 中读取并解析如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title function_">loadField</span><span class="params">(Table tb, <span class="type">long</span> uid)</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] raw = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        raw = ((TableManagerImpl)tb.tbm).vm.read(TransactionManagerImpl.SUPER_XID, uid);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span> raw != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Field</span>(uid, tb).parseSelf(raw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Field <span class="title function_">parseSelf</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">ParseStringRes</span> <span class="variable">res</span> <span class="operator">=</span> Parser.parseString(raw);</span><br><span class="line">    fieldName = res.str;</span><br><span class="line">    position += res.next;</span><br><span class="line">    res = Parser.parseString(Arrays.copyOfRange(raw, position, raw.length));</span><br><span class="line">    fieldType = res.str;</span><br><span class="line">    position += res.next;</span><br><span class="line">    <span class="built_in">this</span>.index = Parser.parseLong(Arrays.copyOfRange(raw, position, position+<span class="number">8</span>));</span><br><span class="line">    <span class="keyword">if</span>(index != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bt = BPlusTree.load(index, ((TableManagerImpl)tb.tbm).dm);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个字段的方法类似，将相关的信息通过 VM 持久化即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">persistSelf</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">byte</span>[] nameRaw = Parser.string2Byte(fieldName);</span><br><span class="line">    <span class="type">byte</span>[] typeRaw = Parser.string2Byte(fieldType);</span><br><span class="line">    <span class="type">byte</span>[] indexRaw = Parser.long2Byte(index);</span><br><span class="line">    <span class="built_in">this</span>.uid = ((TableManagerImpl)tb.tbm).vm.insert(xid, Bytes.concat(nameRaw, typeRaw, indexRaw));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个数据库中存在多张表，TBM 使用链表的形式将其组织起来，每一张表都保存一个指向下一张表的 UID。表的二进制结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[TableName][NextTable]</span><br><span class="line">[Field1Uid][Field2Uid]...[FieldNUid]</span><br></pre></td></tr></table></figure>
<p>这里由于每个 Entry 中的数据，字节数是确定的，于是无需保存字段的个数。根据 UID 从 Entry 中读取表数据的过程和读取字段的过程类似。</p>
<p>对表和字段的操作，有一个很重要的步骤，就是计算 Where 条件的范围，目前 MYDB 的 Where 只支持两个条件的与和或。例如有条件的 Delete，计算 Where，最终就需要获取到条件范围内所有的 UID。MYDB 只支持已索引字段作为 Where 的条件。计算 Where 的范围，具体可以查看 Table 的 parseWhere() 和 calWhere() 方法，以及 Field 类的 calExp() 方法。</p>
<p>由于 TBM 的表管理，使用的是链表串起的 Table 结构，所以就必须保存一个链表的头节点，即第一个表的 UID，这样在 MYDB 启动时，才能快速找到表信息。</p>
<p>MYDB 使用 Booter 类和 bt 文件，来管理 MYDB 的启动信息，虽然现在所需的启动信息，只有一个：头表的 UID。Booter 类对外提供了两个方法：load 和 update，并保证了其原子性。update 在修改 bt 文件内容时，没有直接对 bt 文件进行修改，而是首先将内容写入一个 bt_tmp 文件中，随后将这个文件重命名为 bt 文件。以期通过操作系统重命名文件的原子性，来保证操作的原子性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path + BOOTER_TMP_SUFFIX);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        tmp.createNewFile();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!tmp.canRead()  !tmp.canWrite()) &#123;</span><br><span class="line">        Panic.panic(Error.FileCannotRWException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(tmp)) &#123;</span><br><span class="line">        out.write(data);</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Files.move(tmp.toPath(), <span class="keyword">new</span> <span class="title class_">File</span>(path+BOOTER_SUFFIX).toPath(), StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    file = <span class="keyword">new</span> <span class="title class_">File</span>(path+BOOTER_SUFFIX);</span><br><span class="line">    <span class="keyword">if</span>(!file.canRead()  !file.canWrite()) &#123;</span><br><span class="line">        Panic.panic(Error.FileCannotRWException);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tab了Manager">Tab了Manager</h3>
<p>TBM 层对外提供服务的是 TableManager 接口，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">public interface TableManager &#123;</span><br><span class="line">    BeginRes <span class="keyword">begin</span>(<span class="keyword">Begin</span> <span class="keyword">begin</span>);</span><br><span class="line">    byte[] <span class="keyword">commit</span>(long xid) throws Exception;</span><br><span class="line">    byte[] abort(long xid);</span><br><span class="line"></span><br><span class="line">    byte[] <span class="keyword">show</span>(long xid);</span><br><span class="line">    byte[] <span class="keyword">create</span>(long xid, <span class="keyword">Create</span> <span class="keyword">create</span>) throws Exception;</span><br><span class="line"></span><br><span class="line">    byte[] <span class="keyword">insert</span>(long xid, <span class="keyword">Insert</span> <span class="keyword">insert</span>) throws Exception;</span><br><span class="line">    byte[] read(long xid, <span class="keyword">Select</span> <span class="keyword">select</span>) throws Exception;</span><br><span class="line">    byte[] <span class="keyword">update</span>(long xid, <span class="keyword">Update</span> <span class="keyword">update</span>) throws Exception;</span><br><span class="line">    byte[] <span class="keyword">delete</span>(long xid, <span class="keyword">Delete</span> <span class="keyword">delete</span>) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 TableManager 已经是直接被最外层 Server 调用（MYDB 是 C/S 结构），这些方法直接返回执行的结果，例如错误信息或者结果信息的字节数组（可读）。</p>
<p>各个方法的具体实现很简单，不再赘述，无非是调用 VM 的相关方法。唯一值得注意的一个小点是，在创建新表时，采用的时头插法，所以每次创建表都需要更新 Booter 文件。</p>
<h2 id="8-SQL词法解析器">8. SQL词法解析器</h2>
<p>Parser 实现了对类 SQL 语句的结构化解析，将语句中包含的信息封装为对应语句的类，这些类可见 top.philsongzi.mydb.backend.parser.statement 包。</p>
<p>MYDB 实现的 SQL 语句语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">begin</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">begin</span> [isolation level (read committedrepeatable read)]</span><br><span class="line">        <span class="keyword">begin</span> isolation level read committed</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">commit</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">commit</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span>abort statement<span class="operator">&gt;</span></span><br><span class="line">    abort</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">create</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span>field name<span class="operator">&gt;</span> <span class="operator">&lt;</span>field type<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span>field name<span class="operator">&gt;</span> <span class="operator">&lt;</span>field type<span class="operator">&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="operator">&lt;</span>field name<span class="operator">&gt;</span> <span class="operator">&lt;</span>field type<span class="operator">&gt;</span></span><br><span class="line">    [(index <span class="operator">&lt;</span>field name list<span class="operator">&gt;</span>)]</span><br><span class="line">        <span class="keyword">create</span> <span class="keyword">table</span> students</span><br><span class="line">        id int32,</span><br><span class="line">        name string,</span><br><span class="line">        age int32,</span><br><span class="line">        (index id name)</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">drop</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">table</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span></span><br><span class="line">        <span class="keyword">drop</span> <span class="keyword">table</span> students</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">select</span> (<span class="operator">*</span><span class="operator">&lt;</span>field name list<span class="operator">&gt;</span>) <span class="keyword">from</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span> [<span class="operator">&lt;</span><span class="keyword">where</span> statement<span class="operator">&gt;</span>]</span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">select</span> name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">and</span> id <span class="operator">&lt;</span> <span class="number">4</span></span><br><span class="line">        <span class="keyword">select</span> name, age, id <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">insert</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span> <span class="keyword">values</span> <span class="operator">&lt;</span><span class="keyword">value</span> list<span class="operator">&gt;</span></span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span> <span class="number">5</span> &quot;Zhang Yuanjia&quot; <span class="number">22</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">delete</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">from</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span> <span class="operator">&lt;</span><span class="keyword">where</span> statement<span class="operator">&gt;</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="operator">=</span> &quot;Zhang Yuanjia&quot;</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">update</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">update</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="operator">&lt;</span>field name<span class="operator">&gt;=</span><span class="operator">&lt;</span><span class="keyword">value</span><span class="operator">&gt;</span> [<span class="operator">&lt;</span><span class="keyword">where</span> statement<span class="operator">&gt;</span>]</span><br><span class="line">        <span class="keyword">update</span> student <span class="keyword">set</span> name <span class="operator">=</span> &quot;ZYJ&quot; <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">where</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">where</span> <span class="operator">&lt;</span>field name<span class="operator">&gt;</span> (<span class="operator">&gt;</span><span class="operator">&lt;=</span>) <span class="operator">&lt;</span><span class="keyword">value</span><span class="operator">&gt;</span> [(andor) <span class="operator">&lt;</span>field name<span class="operator">&gt;</span> (<span class="operator">&gt;</span><span class="operator">&lt;=</span>) <span class="operator">&lt;</span><span class="keyword">value</span><span class="operator">&gt;</span>]</span><br><span class="line">        <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">or</span> age <span class="operator">&lt;</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span>field name<span class="operator">&gt;</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span></span><br><span class="line">    [a<span class="operator">-</span>zA<span class="operator">-</span>Z][a<span class="operator">-</span>zA<span class="operator">-</span>Z0<span class="number">-9</span>_]<span class="operator">*</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span>field type<span class="operator">&gt;</span></span><br><span class="line">    int32 int64 string</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">value</span><span class="operator">&gt;</span></span><br><span class="line">    .<span class="operator">*</span></span><br></pre></td></tr></table></figure>
<p>parser 包的 Tokenizer 类，对语句进行逐字节解析，根据空白符或者上述词法规则，将语句切割成多个 token。对外提供了 peek()、pop() 方法方便取出 Token 进行解析。切割的实现不赘述。</p>
<p>Parser 类则直接对外提供了 Parse(byte[] statement) 方法，核心就是一个调用 Tokenizer 类分割 Token，并根据词法规则包装成具体的 Statement 类并返回。解析过程很简单，仅仅是根据第一个 Token 来区分语句类型，并分别处理，不再赘述。</p>
<p>虽然根据编译原理，词法分析应当写一个自动机去做的，但是又不是不能用。</p>
<h2 id="9-Server-和-Client">9. Server 和 Client</h2>
<h3 id="C-S-通信">C/S 通信</h3>
<p>MYDB 使用了一种特殊的二进制格式，用于客户端和服务端通信。当然如果嫌麻烦的话，其实直接用明文也不是不可以。</p>
<p>传输的最基本结构，是 Package：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Package</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] data;</span><br><span class="line">    Exception err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个 Package 在发送前，由 Encoder 编码为字节数组，在对方收到后同样会由 Encoder 解码成 Package 对象。编码和解码的规则如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Flag][data]</span><br></pre></td></tr></table></figure>
<p>若 flag 为 0，表示发送的是数据，那么 data 即为这份数据本身；如果 flag 为 1，表示发送的是错误，data 是 Exception.getMessage() 的错误提示信息。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Encoder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] encode(Package pkg) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pkg.getErr() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Exception</span> <span class="variable">err</span> <span class="operator">=</span> pkg.getErr();</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Intern server error!&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(err.getMessage() != <span class="literal">null</span>) &#123;</span><br><span class="line">                msg = err.getMessage();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Bytes.concat(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>&#125;, msg.getBytes());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Bytes.concat(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>&#125;, pkg.getData());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Package <span class="title function_">decode</span><span class="params">(<span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(data.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> Error.InvalidPkgDataException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(data[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Package</span>(Arrays.copyOfRange(data, <span class="number">1</span>, data.length), <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data[<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Package</span>(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="keyword">new</span> <span class="title class_">String</span>(Arrays.copyOfRange(data, <span class="number">1</span>, data.length))));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> Error.InvalidPkgDataException;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编码之后的信息会通过 Transporter 类，写入输出流发送出去。为了避免特殊字符造成问题，这里会将数据转成十六进制字符串（Hex String），并为信息末尾加上换行符。这样在发送和接收数据时，就可以很简单地使用 BufferedReader 和 Writer 来直接按行读写了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader reader;</span><br><span class="line">    <span class="keyword">private</span> BufferedWriter writer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Transporter</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">        <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        <span class="built_in">this</span>.writer = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(<span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">raw</span> <span class="operator">=</span> hexEncode(data);</span><br><span class="line">        writer.write(raw);</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] receive() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">        <span class="keyword">if</span>(line == <span class="literal">null</span>) &#123;</span><br><span class="line">            close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hexDecode(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        writer.close();</span><br><span class="line">        reader.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">hexEncode</span><span class="params">(<span class="type">byte</span>[] buf)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Hex.encodeHexString(buf, <span class="literal">true</span>)+<span class="string">&quot;n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] hexDecode(String buf) <span class="keyword">throws</span> DecoderException &#123;</span><br><span class="line">        <span class="keyword">return</span> Hex.decodeHex(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Packager 则是 Encoder 和 Transporter 的结合体，直接对外提供 send 和 receive 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Packager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Transporter transpoter;</span><br><span class="line">    <span class="keyword">private</span> Encoder encoder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Packager</span><span class="params">(Transporter transpoter, Encoder encoder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.transpoter = transpoter;</span><br><span class="line">        <span class="built_in">this</span>.encoder = encoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(Package pkg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = encoder.encode(pkg);</span><br><span class="line">        transpoter.send(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Package <span class="title function_">receive</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = transpoter.receive();</span><br><span class="line">        <span class="keyword">return</span> encoder.decode(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        transpoter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Server-和-Client-的实现">Server 和 Client 的实现</h3>
<p>Server 和 Client，偷懒直接使用了 Java 的 socket。</p>
<p>Server 启动一个 ServerSocket 监听端口，当有请求到来时直接把请求丢给一个新线程处理。这部分应该直接背板了。</p>
<p>HandleSocket 类实现了 Runnable 接口，在建立连接后初始化 Packager，随后就循环接收来自客户端的数据并处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Packager</span> <span class="variable">packager</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Transporter</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transporter</span>(socket);</span><br><span class="line">    <span class="type">Encoder</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Encoder</span>();</span><br><span class="line">    packager = <span class="keyword">new</span> <span class="title class_">Packager</span>(t, e);</span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">        e1.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Executor</span> <span class="variable">exe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Executor</span>(tbm);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">Package</span> <span class="variable">pkg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pkg = packager.receive();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">byte</span>[] sql = pkg.getData();</span><br><span class="line">    <span class="type">byte</span>[] result = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Exception</span> <span class="variable">e</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = exe.execute(sql);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">        e = e1;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    pkg = <span class="keyword">new</span> <span class="title class_">Package</span>(result, e);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        packager.send(pkg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">        e1.printStackTrace();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理的核心是 Executor 类，Executor 调用 Parser 获取到对应语句的结构化信息对象，并根据对象的类型，调用 TBM 的不同方法进行处理。具体不再赘述。</p>
<p>top.guoziyang.mydb.backend.Launcher 类，则是服务器的启动入口。这个类解析了命令行参数。很重要的参数就是 -open 或者 -create。Launcher 根据两个参数，来决定是创建数据库文件，还是启动一个已有的数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createDB</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="type">TransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> TransactionManager.create(path);</span><br><span class="line">    <span class="type">DataManager</span> <span class="variable">dm</span> <span class="operator">=</span> DataManager.create(path, DEFALUT_MEM, tm);</span><br><span class="line">    <span class="type">VersionManager</span> <span class="variable">vm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VersionManagerImpl</span>(tm, dm);</span><br><span class="line">    TableManager.create(path, vm, dm);</span><br><span class="line">    tm.close();</span><br><span class="line">    dm.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">openDB</span><span class="params">(String path, <span class="type">long</span> mem)</span> &#123;</span><br><span class="line">    <span class="type">TransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> TransactionManager.open(path);</span><br><span class="line">    <span class="type">DataManager</span> <span class="variable">dm</span> <span class="operator">=</span> DataManager.open(path, mem, tm);</span><br><span class="line">    <span class="type">VersionManager</span> <span class="variable">vm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VersionManagerImpl</span>(tm, dm);</span><br><span class="line">    <span class="type">TableManager</span> <span class="variable">tbm</span> <span class="operator">=</span> TableManager.open(path, vm, dm);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Server</span>(port, tbm).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端连接服务器的过程，也是背板。客户端有一个简单的 Shell，实际上只是读入用户的输入，并调用 Client.execute()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] execute(<span class="type">byte</span>[] stat) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Package</span> <span class="variable">pkg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Package</span>(stat, <span class="literal">null</span>);</span><br><span class="line">    <span class="type">Package</span> <span class="variable">resPkg</span> <span class="operator">=</span> rt.roundTrip(pkg);</span><br><span class="line">    <span class="keyword">if</span>(resPkg.getErr() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> resPkg.getErr();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resPkg.getData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RoundTripper 类实际上实现了单次收发动作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Package <span class="title function_">roundTrip</span><span class="params">(Package pkg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    packager.send(pkg);</span><br><span class="line">    <span class="keyword">return</span> packager.receive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后附上客户端的启动入口，很简单，把 Shell run 起来即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Launcher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">        <span class="type">Encoder</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Encoder</span>();</span><br><span class="line">        <span class="type">Transporter</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transporter</span>(socket);</span><br><span class="line">        <span class="type">Packager</span> <span class="variable">packager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Packager</span>(t, e);</span><br><span class="line"></span><br><span class="line">        <span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Client</span>(packager);</span><br><span class="line">        <span class="type">Shell</span> <span class="variable">shell</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shell</span>(client);</span><br><span class="line">        shell.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-总结（从实现功能出发，由点到面逐渐总结对应的MySQL）">10. 总结（从实现功能出发，由点到面逐渐总结对应的MySQL）</h2>
<h3 id="实现的功能">实现的功能</h3>
<h4 id="数据的可靠性和数据恢复">数据的可靠性和数据恢复</h4>
<h4 id="两段锁协议（2PL）实现可串行化调度">两段锁协议（2PL）实现可串行化调度</h4>
<h4 id="MVCC-2">MVCC</h4>
<h4 id="两种事务隔离级别（读提交和可重复读）">两种事务隔离级别（读提交和可重复读）</h4>
<h4 id="死锁处理">死锁处理</h4>
<h4 id="简单的表和字段管理">简单的表和字段管理</h4>
<h4 id="简单的-SQL-解析">简单的 SQL 解析</h4>
<h4 id="基于-socket-的-server-和-client">基于 socket 的 server 和 client</h4>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>MYDB</tag>
        <tag>轮子</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu(wsl)安装Redis并搭建集群</title>
    <url>/post/ac35e331.html</url>
    <content><![CDATA[<h2 id="Ubuntu（wsl）安装Redis并搭建集群">Ubuntu（wsl）安装Redis并搭建集群</h2>
<h3 id="起因">起因</h3>
<p>配置Redis集群，Windows本机已经有了Redis，就想在wsl中装Redis集群。</p>
<h3 id="踩坑历程">踩坑历程</h3>
<ol>
<li>还就那个经典的：</li>
</ol>
<p>启动wsl时报错 <code>占位程序接收到错误数据。 Error code: Wsl/Service/0x800706f7</code>。行吧，不连梯子上不去网站，连上梯子就总有幺蛾子。解决办法：终端管理员权限运行<code>netsh winsock reset</code>，或者使用<code>NoLSP.exe</code>启动wsl。</p>
<ol start="2">
<li>Redis 安装：</li>
</ol>
<p>从<a href="http://download.redis.io/releases/">redis发行网站</a>上下载最新版本的<code>redis-7.2.0.tar.gz</code>，解压，cd到目录下，<code>make</code>构建。</p>
<p>来力：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(.<span class="property">venv</span>) vagrant@<span class="attr">vagrant</span>:<span class="regexp">/vagrant/</span>redis-<span class="number">6.0</span><span class="number">.6</span>$ make</span><br><span class="line">cd src &amp;&amp; make all</span><br><span class="line">make[<span class="number">1</span>]: <span class="title class_">Entering</span> directory <span class="string">&#x27;/vagrant/redis-6.0.6/src&#x27;</span></span><br><span class="line">/bin/<span class="attr">sh</span>: <span class="number">1</span>: pkg-<span class="attr">config</span>: not found</span><br><span class="line">    <span class="variable constant_">CC</span> <span class="title class_">Makefile</span>.<span class="property">dep</span></span><br><span class="line">/bin/<span class="attr">sh</span>: <span class="number">1</span>: pkg-<span class="attr">config</span>: not found</span><br><span class="line">make[<span class="number">1</span>]: <span class="title class_">Warning</span>: <span class="title class_">File</span> <span class="string">&#x27;Makefile.dep&#x27;</span> has modification time <span class="number">1.3</span> s <span class="keyword">in</span> the future</span><br><span class="line">    <span class="variable constant_">CC</span> adlist.<span class="property">o</span></span><br><span class="line">/bin/<span class="attr">sh</span>: <span class="number">1</span>: <span class="attr">cc</span>: not found</span><br><span class="line"><span class="title class_">Makefile</span>:<span class="number">315</span>: recipe <span class="keyword">for</span> target <span class="string">&#x27;adlist.o&#x27;</span> failed</span><br><span class="line">make[<span class="number">1</span>]: *** [adlist.<span class="property">o</span>] <span class="title class_">Error</span> <span class="number">127</span></span><br><span class="line">make[<span class="number">1</span>]: <span class="title class_">Leaving</span> directory <span class="string">&#x27;/vagrant/redis-6.0.6/src&#x27;</span></span><br><span class="line"><span class="title class_">Makefile</span>:<span class="number">6</span>: recipe <span class="keyword">for</span> target <span class="string">&#x27;all&#x27;</span> failed</span><br><span class="line"><span class="attr">make</span>: *** [all] <span class="title class_">Error</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>解决办法：</p>
<ul>
<li>少了<code>pkg-config</code>，安装之，顺便安装了<code>gcc</code>和<code>tcl</code>（没有<code>tcl</code>在 <code>make test</code>时会报错）。</li>
<li>安装<code>gcc</code>和<code>tcl</code>时会出现：<code>/sbin/ldconfig.real: /usr/lib/wsl/lib/libcuda.so.1 is not a symbolic link</code>这个问题，可<a href="https://github.com/microsoft/WSL/issues/5663">参考链接</a>（目前未深究……）。</li>
<li>然后删除解压出来的 redis 文件夹，重新解压再重新 make 。大成功。参考：<a href="https://stackoverflow.com/questions/63611270/redis-make-failing-ubuntu-18-04">ubuntu(wsl)安装redis时make报错</a></li>
</ul>
<p><img src="/post/ac35e331/Redis%E5%AE%89%E8%A3%85.jpg" alt="img"></p>
<ol start="3">
<li>Redis集群设置</li>
</ol>
<p>搭建三个节点，对应端口分别是7000,7001,7002。配置如下：<a href="https://blog.hhui.top/hexblog/2019/09/25/190925-Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%89%8B%E5%86%8C/">Redis集群搭建手册</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p data/7000 data/7001 data/7002 log/7000 log/7001 log/7002 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面的配置，一次操作三遍，分别获得r7000.conf r7001.conf r7002.conf</span></span><br><span class="line">cp redis.conf r7000.conf</span><br><span class="line">vim r7000.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 下面是我们需要修改的地方</span></span></span><br><span class="line">port 7000 # 端口号</span><br><span class="line">pidfile /var/run/redis_7000.pid # pid进程文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志和数据存储路径</span></span><br><span class="line">logfile &quot;/home/yihui/redis/log/7000/redis.log&quot;</span><br><span class="line">dir &quot;/home/yihui/redis/data/7000/&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后台启动</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启集群</span></span><br><span class="line">cluster-enabled yes</span><br></pre></td></tr></table></figure>
<p>启动Redis，设置集群，集群至少需要三主节点，设置主从时最少要六个节点，不是很有必要啊，直接不要从节点了：</p>
<p><img src="/post/ac35e331/Redis%E9%9B%86%E7%BE%A4%E8%AE%BE%E7%BD%AE.jpg" alt="img"></p>
<p>最后用<code>redis-cli</code>测试一下：</p>
<p><img src="/post/ac35e331/Redis%E9%9B%86%E7%BE%A4%E6%B5%8B%E8%AF%95.jpg" alt="img"></p>
<h3 id="番外">番外</h3>
<p>关于<code>hexo</code>中图片显示问题，<a href="https://blog.csdn.net/m0_43401436/article/details/107191688">这里</a>讲得很清楚，csdn 中难得的好文了。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>点触科技笔试记录</title>
    <url>/post/250e7dfe.html</url>
    <content><![CDATA[<h2 id="一：算法，背包问题">一：算法，背包问题</h2>
<p>描述：在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为Ai（i为n个物品的顺序下标），每个物品只能选择一次且物品大小均为正整数。</p>
<p>题解：</p>
<h2 id="二：场景，排行榜设计">二：场景，排行榜设计</h2>
<p>描述：</p>
<p>题解：</p>
<h2 id="三：设计模式，工厂模式">三：设计模式，工厂模式</h2>
<p>描述：比萨制造过程为<strong>准备、烘烤、切片、装盒</strong>，假设有一个比萨店，比萨店能制造<strong>厦门和深圳</strong>两种风格<br>
的比萨，每种风格比萨又分<strong>芝士、素食、蛤蜊、香肠</strong>四种类型，不同风格同种类型的比萨也不相同，用合适的<strong>设计模式</strong>实现这样的比萨店相关功能类。</p>
<p>题解：</p>
<h2 id="四：JS分解statement函数，从函数中分离出不同的关注点">四：JS分解statement函数，从函数中分离出不同的关注点</h2>
<p>描述：</p>
<p>题解：</p>
<h2 id="五：编程">五：编程</h2>
<p>描述：有n篇英文文章，编程实现计算出每篇文章的主题。</p>
<p>解答：</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>携程笔试记录</title>
    <url>/post/6f158289.html</url>
    <content><![CDATA[<h2 id="9-21-携程笔试（第二批）记录">9.21 携程笔试（第二批）记录</h2>
<h3 id="第一题：排列构造">第一题：排列构造</h3>
<p>题目描述：</p>
<p>长度为 a 的队列，构造长度相同的排列 b，要求b<sub>i</sub>≠a<sub>i</sub>，且b的字典序尽可能小。</p>
<p>排列——长为 n 的数组，1到n每个正整数都只出现了一次。</p>
<p>字典序——第一个不相等的元素小的那个排列的字典序更小。</p>
<p>输入输出：第一行输入 n 代表 a 的长度；第二行输入 n 个数代表a<sub>i</sub>。2≤n≤10^5。</p>
<p>示例：</p>
<p>3</p>
<p>1 2 3</p>
<p>输出：3 1 2</p>
<p>题解：</p>
<h3 id="第二题：字符串-s-转变成字符串-t">第二题：字符串 s 转变成字符串 t</h3>
<p>题目描述：字符串 s 转变成字符串 t。取字符 ch1, ch2（ch2可不在串s中），将s中的ch1变成ch2。用此操作将字符串 s 转变成字符串 t。若经过q次操作，可行则输出yes 否则输出no。</p>
<p>输入输出：s t 均为小写字母组成的串，长度相同，≤10^4。输入 q，代表操作次数；接下来两行输入串s和串t。1≤q≤10</p>
<p>示例：</p>
<p>3</p>
<p>ab</p>
<p>ba</p>
<p>abc</p>
<p>aaa</p>
<p>aaaa</p>
<p>abcd</p>
<p>输出：yes yes no（三行，每行一个）</p>
<p>题解：</p>
<h3 id="第三题：字母矩阵">第三题：字母矩阵</h3>
<p>题目描述：一个n行m列的全小写字母矩阵，求所有满足每个字母只出现一次的子矩阵个数。</p>
<p>输入输出：首行输入两个正整数n m；接下来n 行输入每行长度为m的串。1≤n,m≤500。输出，数量number。</p>
<p>示例：</p>
<p>2 3</p>
<p>aad</p>
<p>abc</p>
<p>输出：13</p>
<p>题解：</p>
<h3 id="第四题：位数修改">第四题：位数修改</h3>
<p>题目描述：对一个正整数，修改其k位，使其变成75的倍数，求所有的修改方案数量。（修改后为正整数，无前导零，答案对10^9+7取模。）</p>
<p>输入输出：首行输入整数n，第二行输入位数k。1≤n≤10^1000, 1≤k≤1000</p>
<p>示例：</p>
<p>355</p>
<p>2</p>
<p>输出：9（分别是150,225,300,450,525,675,750,825,975）</p>
<p>题解：</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>离人</title>
    <url>/post/14e24de8.html</url>
    <content><![CDATA[<h2 id="1">1</h2>
<p>不懂事的老小孩，家里人都不关注的笨蛋，忘了给自家孙子上户口的生产队队长，拿自己儿子名字贷款给队里的工程的老不修，“人穷水都穷”连个孙娃子都收拾不干净的老头——以上，就是多年以后还留在我脑海中关于爷爷的全部印象了。</p>
<p>还记得那个三年级的午后，外婆来学校接我，说带我去看爷爷，我懵懵懂懂地跟着去了，看完了，懵懵懂懂地走了，哦，原来是爷爷帮人插秧的时候晕倒了，没抢救回来，于是，我很自然的接受了这样一个事实——爷爷死了，那个编了一天的竹篾拿去换点钱给小孙子买饮料的老头死了。</p>
<p>因为家庭的原因，我从很小的时候就一直是跟着外公外婆家一起生活的，对于这个爷爷，了解也就十分有限。倒不如说，关于他的很多事，很多印象，全是从外公外婆和爸妈口中听来，最后自行拼接而成的。每逢过年，都是必须要要去上坟的，在这个时候，听一听爸妈讲讲他过去的事，听一听爸妈给他讲他走之后他儿孙的事，再祈愿老人家在天之灵给现世的人保佑，在香蜡钱纸燃烧的火光中、在噼里啪啦的鞭炮声中，代际间的传承就就以这样的形式完成了。</p>
<h2 id="2">2</h2>
<p>年龄和脾气之间肯定是有一定关系的，无他，从我自己的经验来看就是这样，从我身边的人变化来看也是这样。</p>
<p>小学的时候吧，我的邻居家有个年龄很大的老太太，她家养了一条老母狗，很凶，真的很凶，每天我去上学从他家门口经过都心惊肉跳，走的次数多了，最后还是没躲过被咬了一回，因此，我对老太太印象也非常不好。</p>
<p>那一年，老太太家的枇杷树结果了，很多很大，我很馋，馋但是不敢。后来，老太太叫我自己上树去摘就是了，小孩子哪能受得了鼓励，坐在树上就开始一顿吃。外公刚干完活回来，见我坐在邻居家的枇杷树上大吃，很生气地叫我下来，我没理他，没想到竟然扔小石子过来，于是，我大哭着回家了。外婆回来，知道了情况，抄起二指宽的篾条就朝外公身上打去，一边打一遍骂，“哪有你这样教育娃娃的，那是拿石头打的吗，不晓得轻重，你看我今天打不打得你好看”。</p>
<p>暴躁，不知轻重，大概就是那时候外公的脾气了。</p>
<p>上高中了，我运气好，在同学的推荐下得到了市高中的青睐，分数上线就要，免学杂费。当时也没有月假一说，法定假期中时间长点的才能回家，于是，回家的次数就这样变少了。奇怪的是，我跟外公这个老头的关系倒是莫名其妙好了很多，好像几天不见这个人就褪去了往日的暴躁，转身拥抱了相反的平和。家里的打米机不好用了，一看是筛子坏了，行，你小子去街上买一张回来吧；今天要抽水去灌那片花生地，走吧，咱爷俩一块把水管和水泵扛过去；读了几天书手脚也没变慢嘛，还阔以，今天就把这片谷子打完了；“人民渠嘛，还是我切修的，当时毛老汉……”；“嗯，东西拿齐没得，武汉也没得好远嘛，当年我也是切过那边了，你切了好生学习哈，上大学了也不是给你放松的，嗯，屋头我晓得，你走嘛”……</p>
<p>平和，宁静，像一坛老酒，这是那时候外公的脾气。</p>
<h2 id="3">3</h2>
<p>一晃又是几年，好似我从未认真看过外公这个老头一样，他怎么一下子这么瘦弱了，弯腰驼背的了，眼神没有往日的犀利，嘴角却含着似有若无的笑意，像村里那口老井，记录了一切但是又将其深深埋在水底，几无人可触达。</p>
<p>前不久爸打电话给我，告诉我外公确诊了胃癌，叫我给家里打个电话好歹问一下，但是我一直不敢往家里打电话，我在害怕，在逃避，害怕自己辜负他们的期待，害怕看见他们的眼神，害怕听见他们的声音，我在逃避自己的责任，但是我又还能再躲多久呢？</p>
<p>曾经我对皮包骨头这个词的印象只停留在字典里，直到我再见到我的外公，那是怎样的一副光景？曾经力担千斤的肌肉再没有一丝一毫留存在这个老人身上，肋骨勾勒出的胸膛就这样毫无遮掩地展现着，同弯曲的脊梁骨一起狰狞地展示着时间的伟力，展示着“病”这一人世间大苦楚的威力，眉头轻蹙的样子像是在忍受着无时无刻不在的痛楚，我简直不忍再看。面对着这一切，我无话可说，我无能为力，世上难道还有什么东西能再换回这个老人的时光吗？</p>
<p>树欲静而风不止，子欲养而亲不待。初闻不识曲中意，再听已是曲中人。罢，珍惜眼前人吧。</p>
<h2 id="end">end</h2>
<p>“真没想到我们在这样一个地方告别，但是跟人告别的时候，还是要用力一点，因为你多说一句，说不定就是最后一句，多看一眼，弄不好就是最后一眼。”——《后会无期》</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>过滤器Filter</title>
    <url>/post/31fabe4c.html</url>
    <content><![CDATA[<h3 id="Filter">Filter</h3>
<h4 id="filter-流程">filter 流程</h4>
<p><img src="/post/31fabe4c/Filter%E6%B5%81%E7%A8%8B.jpg" alt="Filter流程"></p>
<p>一个 http 请求过来之后：</p>
<ul>
<li>首先进入 filter，执行相关业务逻辑</li>
<li>若判定通行，则进入 Servlet 逻辑，Servlet 执行完毕之后，又返回 Filter，最后在返回给请求方</li>
<li>判定失败，直接返回，不需要将请求发给 Servlet</li>
</ul>
<h4 id="应用场景">应用场景</h4>
<ul>
<li>在 filter 层，获取用户的身份</li>
<li>可以考虑在 filter 层做一些常规的校验 (如参数校验，referer 校验、权限控制等)</li>
<li>可以在 filter 层做运维、安全防护相关的工作(如全链路打点，可以在 flter 层分配一个 traceld;也可以在这一层做限流等)</li>
</ul>
<h4 id="使用">使用</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;, filterName = &quot;reqRecordFilter&quot;, asyncSupported = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReqRecordFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">REQ_LOG</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;req&quot;</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回给前端的traceId，用于日志追踪</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GLOBAL_TRACE_ID_HEADER</span> <span class="operator">=</span> <span class="string">&quot;g-trace-id&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GlobalInitService globalInitService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StatisticsSettingService statisticsSettingService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            request = <span class="built_in">this</span>.initReqInfo((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);</span><br><span class="line">            CrossUtil.buildCors(request, (HttpServletResponse) servletResponse);</span><br><span class="line">            filterChain.doFilter(request, servletResponse);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            buildRequestLog(ReqInfoContext.getReqInfo(), request, System.currentTimeMillis() - start);</span><br><span class="line">            <span class="comment">// 一个链路请求完毕，清空MDC相关的变量(如GlobalTraceId，用户信息)</span></span><br><span class="line">            MdcUtil.clear();</span><br><span class="line">            ReqInfoContext.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  	# ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>init：初始化时执行</p>
</li>
<li>
<p>destory： 销毁时执行</p>
</li>
<li>
<p>doFilter：filter 规则命中的请求，都会走进来</p>
</li>
<li>
<ul>
<li>三个参数，注意第三个 FilterChain，这里是经典的责任链设计模式</li>
<li>执行 filterChain.doFilter(servletRequest，servletResponse) 表示会继续将请求执行下去若不执行这一句，表示这一次的 http 请求到此为止了，后面的走不下去了</li>
</ul>
</li>
</ul>
<h4 id="注册（过滤器Filter注册到Spring容器）">注册（过滤器Filter注册到Spring容器）</h4>
<ol>
<li>使用 @WebFilter 注解，标注到自己实现的过滤器上</li>
</ol>
<p>WebFilter 常用属性如下，其中 urIPatterns 最为常用，表示这个 flter 适用于哪些 url 请求(默认场景下全部请求都被拦截)</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>fileName</td>
<td>String</td>
<td>指定过滤器的 name 属性，等价于 <filter-name>。</filter-name></td>
</tr>
<tr>
<td>value</td>
<td>String[]</td>
<td>该属性等价于 urlPatterns 属性，但是两者不应同时使用。</td>
</tr>
<tr>
<td>urlPatterns</td>
<td>String[]</td>
<td>指定一组过滤器的URL匹配模式。等价于<url-pattern>标签。</url-pattern></td>
</tr>
<tr>
<td>srvletNames</td>
<td>String[]</td>
<td>指定过滤器将应用于哪些Servlet。取值是 @WebSerlvet 中的name属性的取值，或者是web.xml中的<servlet-name>的取值。</servlet-name></td>
</tr>
<tr>
<td>dispatcherTypes</td>
<td>DispatcherType</td>
<td>指定过滤器的转发模式，具体取值包括：ASYNC/ERROR/FORWARD/INCLUDE/REQUEST.</td>
</tr>
<tr>
<td>initParams</td>
<td>WebinitParam[]</td>
<td>指定一组过滤器初始化参数，等价于<init-param>标签。</init-param></td>
</tr>
<tr>
<td>asyncSupported</td>
<td>boolean</td>
<td>声明过滤器是否支持异步操作模式，等价于<async-supported>标签。</async-supported></td>
</tr>
<tr>
<td>description</td>
<td>String</td>
<td>该过滤器的描述信息，等价于<description>标签。</description></td>
</tr>
<tr>
<td>displayName</td>
<td>String</td>
<td>该过滤器的显示名，通常配合工具使用，等价于 <display-name> 标签</display-name></td>
</tr>
</tbody>
</table>
<p>使用这个注解时，请注意，需要在<strong>启动类/配置类</strong>上添加 <strong>ServletComponentScan</strong> 注解来启用.</p>
<p><strong>注意点1</strong>：@WebFilter 注解结合@Order 来定义 filter 注解，可能并不会生效。</p>
<p><strong>注意点2</strong>：@WebFilter 声明的Filter，优先级为 2147483647 (最低优先级）。</p>
<ol start="2">
<li>FilterRegistrationBean</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public FilterRegistrationBean&lt;Filter&gt; orderFilter() &#123;</span><br><span class="line">		FilterRegistrationBean&lt;Filter&gt; filter = new FilterRegistrationBean&lt;&gt;();</span><br><span class="line">		filter.setName(&quot;regRecordFilter&quot;);</span><br><span class="line">		filter.seturlPatterns(Arrays.asList(&quot;/**&quot;));</span><br><span class="line">		filter.setFilter(new RegRecordFilter());  //指定优先级</span><br><span class="line">		filter.setorder(-1);</span><br><span class="line">		return filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实例">实例</h4>
<p>技术派中，Filter 应用到了以下几个地方:</p>
<ul>
<li>身份识别，并保存身份到 RegInfoContext 上下文中。详情博文: <a href="https://www.yuque.com/itwanger/az7yww/yk1x4v6wt5gz103q">https://www.yuque.com/itwanger/az7yww/yk1x4v6wt5gz103q</a></li>
<li>记录请求记录，详情博文: <a href="https://www.yuque.com/itwanger/az7yww/wb3pz26699c86nuz">https://www.yuque.com/itwanger/az7yww/wb3pz26699c86nuz</a></li>
<li>添加跨域支持，详情博文: <a href="https://www.yuque.com/itwanger/az7yww/pznv1robndgbuyhh">https://www.yuque.com/itwanger/az7yww/pznv1robndgbuyhh</a></li>
</ul>
<h4 id="filter-在技术派中的应用总结">filter 在技术派中的应用总结</h4>
<p><img src="/post/31fabe4c/Filter%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.png" alt="Filter知识点总结"></p>
<h4 id="最后">最后</h4>
<p><a href="https://github.com/itwanger/paicoding">技术派项目地址</a></p>
]]></content>
      <categories>
        <category>coding</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
</search>
